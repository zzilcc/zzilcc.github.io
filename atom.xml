<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>黄紫茜的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-05T13:10:11.614Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>黄紫茜</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>js原型和原型链</title>
    <link href="http://yoursite.com/2019/04/30/js%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://yoursite.com/2019/04/30/js原型和原型链/</id>
    <published>2019-04-30T08:32:10.000Z</published>
    <updated>2019-05-05T13:10:11.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="prtotype和proto"><a href="#prtotype和proto" class="headerlink" title="prtotype和proto"></a>prtotype和<strong>proto</strong></h2><p>说到原型，我们必须要了解prototype和<strong>proto</strong>,这两个很多人可能总是会分不清，接下来我会尽可能以通俗易懂的语言去解释这两者的不同。</p><p>我们看到的大多数引用类型值：函数，数组，对象都是Object的实例，所以Object可以说是一个基本。</p><p>我们去创建一个Object的实例，有两种方法，一种是通过new</p><p>例如：</p><pre><code>var obj = new Object()</code></pre><p>还有一种通过对象字面量</p><pre><code>var obj = {}  </code></pre><p>每个构造函数都有一个原型对象，通过prototype去访问，比如Object.prototype,然后这个原型对象包含一个constructor属性，指向构造函数，也就是Object.prototype.constructor === Object，还包含了一些内置函数，或者自定义的函数。</p><p>然后实例化这个构造函数，得到的实例，有一个<strong>proto</strong>属性指向构造函数的原型对象。</p><p>下面是Object的一个例子。</p><p><img src="/2019/04/30/js原型和原型链/Object的原型.jpg" alt=""></p><p>所以我们可以看到obj.<strong>proto</strong>=== Object.prototype</p><p>总结：</p><ol><li>每个函数都有prototype指向原型对象</li><li>每个对象都有<strong>protot</strong>指向构造函数的原型对象</li></ol><p>在js中，函数是一种特殊的对象，所以函数也有<strong>proto</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;prtotype和proto&quot;&gt;&lt;a href=&quot;#prtotype和proto&quot; class=&quot;headerlink&quot; title=&quot;prtotype和proto&quot;&gt;&lt;/a&gt;prtotype和&lt;strong&gt;proto&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;说到原型，
      
    
    </summary>
    
    
      <category term="javaScript" scheme="http://yoursite.com/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>this和常用css</title>
    <link href="http://yoursite.com/2019/04/26/this%E5%92%8C%E5%B8%B8%E7%94%A8css/"/>
    <id>http://yoursite.com/2019/04/26/this和常用css/</id>
    <published>2019-04-26T01:44:50.000Z</published>
    <updated>2019-04-30T08:32:46.629Z</updated>
    
    <content type="html"><![CDATA[<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><h3 id="第一段代码"><a href="#第一段代码" class="headerlink" title="第一段代码"></a>第一段代码</h3><pre><code>var count = 1;function a () {    this.count ++    console.log(this.count)}a.count = 0;a()console.log(a.count)</code></pre><p>谣言： this指向自身</p><h3 id="第二段代码"><a href="#第二段代码" class="headerlink" title="第二段代码"></a>第二段代码</h3><p>重要的事情说三遍</p><p>this永远指向最后调用它的对象</p><p>this永远指向最后调用它的对象</p><p>this永远指向最后调用它的对象<br><a id="more"></a></p><pre><code>var name = &apos;windowName&apos;;function a () {    var name = &apos;aName&apos;;    console.log(&apos;a: &apos; + this.name)}a()console.log(&apos;window: &apos; + this.name)</code></pre><p>输出？</p><p>两个都是输出windowName，因为a函数在全局对象里调用的，所以this指向的是window，所以第一个代码a函数里this.count++,这个count是全局的coount，也就是window.count,a.count不会变,所以输出的是2，0。然后第二段代码两个输出都是windowName</p><h3 id="第三段代码"><a href="#第三段代码" class="headerlink" title="第三段代码"></a>第三段代码</h3><pre><code>var name = &apos;windowName&apos;;function a () {    var name = &apos;aName&apos;;    console.log(&apos;a: &apos; + this.name);}var obj = {    name: &apos;objName&apos;,    fn: a}obj.fn()</code></pre><p>输出？</p><p>因为最后调用this的对象是obj，所以this指向obj，this.name指的是obj.name</p><h3 id="第四段代码"><a href="#第四段代码" class="headerlink" title="第四段代码"></a>第四段代码</h3><pre><code>var name = &apos;windowName&apos;;function a () {    var name = &apos;aName&apos;;    console.log(&apos;a: &apos; + this.name);    function b() {        console.log(&apos;b: &apos; + this.name)     }     b();}a()console.log(&apos;window: &apos; + this.name)</code></pre><p>输出？</p><p>在js里，函数是一种特殊的对象，只要函数里没有被正常对象包裹着，函数调用this都是指向window。</p><p>所以这里输出都是windowName</p><h3 id="第五段代码"><a href="#第五段代码" class="headerlink" title="第五段代码"></a>第五段代码</h3><pre><code>var name = &apos;windowName&apos;;function a () {    var name = &apos;aName&apos;;    console.log(&apos;a: &apos; + this.name);}var obj = {    name: &apos;objName&apos;,    fn: a}var foo =  obj.fn foo()</code></pre><p>这里我们变形一下第三段代码，将obj.fn赋值给一个变量foo，然后再运行foo，这样会输出什么？</p><p>很神奇，这里会输出的是‘windowName’,而不是‘objName’，这是因为把obj.fn赋值给foo时，是相当于foo指向了fn函数，然后foo时再全局执行的，所以相当于window.foo,所以this指向是window，所以输出的是‘windowName’。</p><h3 id="第六段代码"><a href="#第六段代码" class="headerlink" title="第六段代码"></a>第六段代码</h3><pre><code>var name = &apos;windowName&apos;;setTimeout(function(){    var name = &apos;setTimeout_name&apos;    console.log(this.name)},1000)</code></pre><p>我们之前说过setTimeout是window的方法，setTimeout的回调函数是在window里执行的，所以setTimeout回调函数里的this指向的是window。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>this永远指向最后调用它的对象</p><p>this永远指向最后调用它的对象</p><p>this永远指向最后调用它的对象</p><h2 id="改变this指向"><a href="#改变this指向" class="headerlink" title="改变this指向"></a>改变this指向</h2><ol><li>使用es6的箭头函数</li><li>在函数内部使用_this = this</li><li>使用apply，call，bind</li><li>new实例话一个对象。 </li></ol><h3 id="es6的箭头函数"><a href="#es6的箭头函数" class="headerlink" title="es6的箭头函数"></a>es6的箭头函数</h3><p>es6的箭头函数的this始终指向的是函数定义时的this，而非执行时。</p><pre><code>var name = &apos;windowName&apos;;var obj = {    name: &apos;objName&apos;,    fn: function() {        setTimeout(()=&gt;{            console.log(this.name)        },0)    }}obj.fn()</code></pre><h3 id="this-that-self"><a href="#this-that-self" class="headerlink" title="_this,that,self"></a>_this,that,self</h3><p>这种方法最常见了，用一个变量_this,that,self保存一下调用这个函数的对象，然后在函数里用这个变量</p><pre><code>var name = &apos;windowName&apos;;var obj = {    name: &apos;objName&apos;,    fn: function() {        var _this = this;        setTimeout(function(){            console.log(_this.name)        },0)    }}obj.fn()</code></pre><h3 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call,apply,bind"></a>call,apply,bind</h3><pre><code>var name = &apos;window_name&apos;var a = {    name: &apos;a_name&apos;,    fn: function(age){        console.log(this.name);    }}var b = {    name: &apos;b_name&apos;,    fn1: function(){        console.log(this.name);    }}a.fn.apply(b)b.fn1.apply(a)b.fn1.apply(this)a.fn.call(b)b.fn1.call(a)b.fn1.call(this)a.fn.bind(b)()b.fn1.bind(a)()b.fn1.bind(this)()</code></pre><p>apply 语法 fun.apply(thisArg, [argsArr])</p><ul><li>thisArg fun函数运行时指定的this值</li><li>argsArr 一个数组或者类数组对象。</li></ul><p>call 语法 fun.call(thisArgs, arg1, arg2…)</p><p>apply和call的区别是call是接受多个参数，apply接受一个参数数组</p><pre><code>var a = {    name: &apos;a_name&apos;,    fn: function(age, sex){        debugger        var age = age;var sex = sex;        console.log(this.name);    }}var b = {    name: &apos;b_name&apos;,    fn1: function(age, sex){        debugger        console.log(this.name);    }}a.fn.apply(b,[ 11, &apos;man&apos;])b.fn1.call(b,  11, &apos;man&apos;)</code></pre><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>我们经常说没有对象，new一个就行。这里的new将this指向</p><pre><code>var Person (name) {    this.name = name}new Person(&apos;zzilcc&apos;)</code></pre><p>new 做了什么，下面解释一下</p><ol><li>创建了一个空对象obj</li><li>把obj的_proto_z指向Person的原型对象prototype，此时便建立了obj对象的原型链obj-&gt;Person.prototype-&gt;Object.prototype-&gt;null</li><li>在obj的执行环境调用Person的方法，也就是Person.call(obj,’zzilcc’),然后执行obj.name = ‘zzilcc’</li><li>将obj当作返回值返回</li></ol><p>所以我们用一个变量去接受下这个obj</p><pre><code>var person1 = new Person(&apos;zzilcc&apos;)person1.name === &apos;zzilcc&apos; // true</code></pre><h2 id="常用css属性"><a href="#常用css属性" class="headerlink" title="常用css属性"></a>常用css属性</h2><ol><li><p>css背景属性</p><ul><li>background: #fff url() center 100% no-repeat<ul><li>background-color</li><li>background-image</li><li>background-position</li><li>background-size</li><li>background-repeat</li></ul></li></ul></li><li><p>css边框属性</p><ul><li>border<ul><li>border-color</li><li>border-width</li><li>border-style</li></ul></li><li>border-top: 1px solid #fff<ul><li>border-top-color: #fff</li><li>border-top-width: 1px</li><li>border-top-style: solid(实线)/dotted(点状)/dashed(虚线)</li></ul></li><li>border-right<ul><li>border-right-color</li><li>border-right-width</li><li>border-right-style</li></ul></li><li>border-bottom<ul><li>border-bottom-color</li><li>border-bottom-width</li><li>border-bottom-style</li></ul></li><li>border-left<ul><li>border-left-color</li><li>border-left-width</li><li>border-left-style</li></ul></li></ul></li><li><p>css尺寸属性</p><ul><li>height</li><li>max-height</li><li>min-height</li><li>width</li><li>min-width</li><li>max-width</li></ul></li><li><p>css字体属性</p><ul><li>font<ul><li>font-size</li><li>font-family</li><li>font-style</li><li>font-weight</li></ul></li></ul></li><li><p>css外边距属性</p><ul><li>margin<ul><li>margin-top</li><li>margin-right</li><li>margin-bottom</li><li>margin-left</li></ul></li></ul></li><li><p>css内边距属性</p><ul><li>padding<ul><li>padding-top</li><li>padding-right</li><li>padding-bottom</li><li>padding-left</li></ul></li></ul></li><li><p>css定位属性</p><ul><li>position</li><li>top</li><li>right</li><li>bottom</li><li>left</li><li>overflow</li><li>float</li><li>display</li><li>z-index</li><li>vertical-align</li><li>cursor: default|pointer</li></ul></li><li><p>css文本属性</p><ul><li>color: #fff; // 颜色</li><li>line-height:40px; //行高 </li><li>text-align: left|center|right// 规定文本的水平对齐方式</li><li>text-indent: 2px|1% // 属性规定文本块中首行文本的缩进。</li><li>white-space:nowrap //     文本不会换行，文本会在在同一行上继续，直到遇到 <br> 标签为止</li><li>text-overflow:ellipsis // 规定当文本溢出包含元素时发生的事情。</li><li>word-break: normal|break-all|keep-all;// 规定非中日韩文本的换行规则。</li><li>word-wrap: normal|break-word // 单词分割且换行</li></ul></li></ol><h2 id="常用css解决某些问题"><a href="#常用css解决某些问题" class="headerlink" title="常用css解决某些问题"></a>常用css解决某些问题</h2><ol><li>css画各种形状</li></ol><h3 id="圆形"><a href="#圆形" class="headerlink" title="圆形"></a>圆形</h3><pre><code>div {    width: 100px;    height: 100px;    background: red;    border-radius: 50%;}&lt;div&gt;&lt;/div&gt;</code></pre><h3 id="三角形"><a href="#三角形" class="headerlink" title="三角形"></a>三角形</h3><pre><code>div {      width: 0;      border-left: 50px solid transparent;      border-right: 50px solid transparent;      border-bottom: 100px solid red;}</code></pre><ol start="2"><li><p>省略号</p><h3 id="省略号"><a href="#省略号" class="headerlink" title="省略号"></a>省略号</h3><pre><code>max-width: 100px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap</code></pre></li></ol><h2 id="绑定数据"><a href="#绑定数据" class="headerlink" title="绑定数据"></a>绑定数据</h2><h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><p>git reflog &amp;&amp; git reset –hard ‘哈希数’</p><p>遇到一些奇怪的现象时我们可以用git reflog 找到我们最新的一次commit时的哈希数。</p><p>然后灭霸一个响指可以消灭一半的‘人’</p><p>我们git reset –hard ‘哈希数’则能让我们回到刚刚commit完的时候，仿佛之前进行了一切操作犹如云烟飘散。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;this&quot;&gt;&lt;a href=&quot;#this&quot; class=&quot;headerlink&quot; title=&quot;this&quot;&gt;&lt;/a&gt;this&lt;/h2&gt;&lt;h3 id=&quot;第一段代码&quot;&gt;&lt;a href=&quot;#第一段代码&quot; class=&quot;headerlink&quot; title=&quot;第一段代码&quot;&gt;&lt;/a&gt;第一段代码&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;var count = 1;
function a () {
    this.count ++
    console.log(this.count)
}
a.count = 0;
a()
console.log(a.count)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;谣言： this指向自身&lt;/p&gt;
&lt;h3 id=&quot;第二段代码&quot;&gt;&lt;a href=&quot;#第二段代码&quot; class=&quot;headerlink&quot; title=&quot;第二段代码&quot;&gt;&lt;/a&gt;第二段代码&lt;/h3&gt;&lt;p&gt;重要的事情说三遍&lt;/p&gt;
&lt;p&gt;this永远指向最后调用它的对象&lt;/p&gt;
&lt;p&gt;this永远指向最后调用它的对象&lt;/p&gt;
&lt;p&gt;this永远指向最后调用它的对象&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="this | css" scheme="http://yoursite.com/tags/this-css/"/>
    
  </entry>
  
  <entry>
    <title>js作用域和闭包</title>
    <link href="http://yoursite.com/2019/04/15/js%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/"/>
    <id>http://yoursite.com/2019/04/15/js作用域和闭包/</id>
    <published>2019-04-15T11:28:34.000Z</published>
    <updated>2019-04-19T10:02:35.478Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、js引擎执行过程"><a href="#一、js引擎执行过程" class="headerlink" title="一、js引擎执行过程"></a>一、js引擎执行过程</h2><pre><code>var a;console.log(a);console.log(b);</code></pre><p>输出？</p><pre><code>a = 2;var a;console.log(a);</code></pre><p>输出？</p><pre><code>console.log(a);var a = 2;</code></pre><p>输出？</p><p>我们之前说过js代码是由上到下去执行的，但是上面代码的输出结果好像显示的不是这样，其实不是的，js代码确实是由上到下去执行的，只是执行的不是我们直接写的代码，而是我们代码通过编译后生成的代码。</p><p>我们可以将js引擎执行过程分为三个阶段，分别是语法分析，预编译和解释执行阶段。<br><a id="more"></a></p><h2 id="（1）语法分析"><a href="#（1）语法分析" class="headerlink" title="（1）语法分析"></a>（1）语法分析</h2><p>语法分析主要是对代码进行语法检查，如果语法有错，会抛出错误，如果没有错，则进入预编译阶段，</p><h2 id="（2）预编译"><a href="#（2）预编译" class="headerlink" title="（2）预编译"></a>（2）预编译</h2><p>我们可以将预编译分成四个步骤</p><ol><li>创建GO（全局）/ AO（活动）对象</li><li>找形参和变量声明，将变量和形参名作为GO/AO属性名，值为undefined</li><li>将实参和形参统一</li><li>在函数体里找函数声明，值赋予函数体</li></ol><h3 id="函数声明和函数表达式的区别"><a href="#函数声明和函数表达式的区别" class="headerlink" title="函数声明和函数表达式的区别"></a>函数声明和函数表达式的区别</h3><p>主要看第一个词是不是function,第一个词是function为函数声明，其他的都是函数表达式</p><pre><code>function () {} // 函数声明var a = function () {} // 函数表达式</code></pre><p>示例： （代码已经过语法检查，没有语法错误）</p><pre><code>function a () {    var b =10;    function c () {        var b =123;        console.log(b);        function d (){}    }    console.log(b);    console.log(c);}var b =123;a();</code></pre><ol><li><p>一进来默认的是全局对象GO，在此是window对象</p></li><li><p>找变量声明b，将其作为window的属性，值为undefined </p></li><li><p>找函数声明，发现a函数, 将其作为window属性，值为a函数的函数体</p></li></ol><p>此时Go对象为： </p><pre><code>GO = {    b: undefined,    a: function () {        var b =10;        function c () {            var b =123;            console.log(b);            function d (){}        }        console.log(b);        console.log(c);    }}</code></pre><p>所以此时代码可以理解成 </p><pre><code>var b;var a = function(){    // a的函数体};b = 123;a();</code></pre><h2 id="（3）解释执行"><a href="#（3）解释执行" class="headerlink" title="（3）解释执行"></a>（3）解释执行</h2><p>此时引擎开始执行代码</p><p>把123赋值给b，运行a，运行a之前也会进行预编译。</p><pre><code>function a () {    var b =10;    function c () {        var b =123;        console.log(b);        function d (){}    }    console.log(b);    console.log(c);}</code></pre><ol><li>新建一个AO对象</li><li>查找变量声明，发现b,给AO对象添加一个属性b，值为undefined</li><li>查找函数声明，发现c函数，给AO对象添加一个属性c，值为c函数体</li></ol><p>AO对象</p><pre><code>AO = {    b: undefined,    c: function () {        var b =123;        console.log(b);        function d (){}    }}</code></pre><p>此时代码可以理解成</p><pre><code>function a () {    var b;    function c () {        var b =123;        console.log(b);        function d (){}    }    b = 10;    console.log(b);    console.log(c);}</code></pre><p>然后开始执行a函数</p><h2 id="变量和函数提升的一些注意事项"><a href="#变量和函数提升的一些注意事项" class="headerlink" title="变量和函数提升的一些注意事项"></a>变量和函数提升的一些注意事项</h2><p>重名的声明后一个会覆盖前一个</p><pre><code>function foo () {    console.log(a)}function foo () {    console.log(b)}console.log(foo)</code></pre><p>如果函数声明和变量声明重名了，函数声明会优先</p><pre><code>function foo () {}var foo;console.log(foo)</code></pre><h2 id="二、js作用域"><a href="#二、js作用域" class="headerlink" title="二、js作用域"></a>二、js作用域</h2><h3 id="作用域是什么？"><a href="#作用域是什么？" class="headerlink" title="作用域是什么？"></a>作用域是什么？</h3><p>作用域是根据名称查找变量一套规则。可以把作用域假设成一个管家。</p><h3 id="作用域的类型"><a href="#作用域的类型" class="headerlink" title="作用域的类型"></a>作用域的类型</h3><p>作用域可以分为全局作用域和局部作用域。</p><p>在执行<code>&lt;script&gt;&lt;/script&gt;</code>块或者js文件时，会生成一个全局作用域和一个window对象，在全局作用域里定义的变量和函数会变成window对象的属性。</p><p>局部作用域包括函数作用域和块级作用域</p><p>每次声明一个函数，就会生成一个函数作用域。</p><p>块级作用域： </p><pre><code>1. with（不推荐）2. try/catch catch会创建一个块级作用域3. let</code></pre><p>注意： 作用域可以嵌套，但是不能重叠。</p><pre><code>var a = 1;function get2 () {    var a = 2;    console.log(&apos;get2 a: &apos;+ a);    function get3 () {        console.log(&apos;get3 a: &apos; + a);    }    get3();    console.log(&apos;get3.prototype: &apos;);    console.log(get3.prototype);}function set2 () {}console.log(&apos;get2.prototype: &apos;);console.log(get2.prototype);get2();</code></pre><p>输出结果</p><p><img src="/2019/04/15/js作用域和闭包/作用域1.png" alt=""></p><p>可以看到我们在全局声明了一个函数叫get2，产生了一个函数作用域，这个作用域是被全局作用域包裹着，然后在get2函数里我们也声明了一个get3函数，也产生了一个函数作用域，这个作用域是被get2的作用域包裹着，所以是一层套一层。</p><p><img src="/2019/04/15/js作用域和闭包/作用域嵌套.jpg" alt=""></p><p>###执行环境和作用域</p><p>执行环境是js中很重要的一个概念，他包括三部分： 变量对象（AO），作用域链，this。</p><p>执行环境有三个类型</p><pre><code>1. 全局执行环境 （js默认执行环境，在web浏览器的话是window对象）2. 函数执行环境 （每个函数自己的执行环境）3. eval执行环境</code></pre><p><img src="/2019/04/15/js作用域和闭包/eventLoop.png" alt=""></p><p>每个执行环境都有一个变量对象，环境中定义的函数和变量都保存在这个对象中。</p><pre><code>var c = 1;function a () {    console.log(c)    return function b () {        console.log(c)    }}a()let aa = a()aa()</code></pre><p>当执行到一个函数a时，该函数a的执行环境会被推进一个执行栈，函数a里调用了其他函数b的话，会将调用的函数b的执行环境推进栈，然后执行完b函数的代码后，b执行环境被推出栈，然后继续执行a函数的代码，a执行完后，把a的执行环境推出栈，以此类推。</p><p>被推出栈的执行环境会被销毁，保存在其中的所有变量和函数定义也会被销毁，全局执行环境在页面关闭或者浏览器关闭时被销毁。</p><p><img src="/2019/04/15/js作用域和闭包/执行栈.jpg" alt=""></p><pre><code>function aa () {    for(var a = 0; a &lt; 5; a++){        console.log(a)    }}console.log(a)for(var b = 0; b &lt; 5; b++){    console.log(b)}console.log(b)</code></pre><p>在函数外部是不能访问到函数内部定义的变量，所以第一个输出a会报错。然后b会输出5，因为js没有块级作用域，所以声明的b是被当作window的属性的，所以可以访问到。</p><p><img src="/2019/04/15/js作用域和闭包/作用域链.jpg" alt=""></p><p>当代码在一个环境执行的时候会创建变量对象的一个作用域链，全局执行环境的变量对象始终都是作用域链的最后一个。</p><p>很明显，a函数有自己的作用域，然后a函数又是在全局定义的，所以被包裹在全局作用域里，所以a的作用域链是自身作用域-全局作用域，在a中查找一个变量是，会在自身作用域查找（也就是找自身的变量对象里有没有这个属性），如果没有查找到就沿着作用域链上去找，找他的上一级作用域链，在这里是全局作用域。</p><p>我们之前说过作用域根据名称查找变量一套规则，可以把作用域理解成管家。</p><p>全局执行环境是一个酒店，函数执行环境是一个房间。</p><p>全局作用域是总管家，a函数作用域是a管家，依次类推。</p><p>我们以下面例子来说：</p><pre><code>var c = 1;function a () {    console.log(c)    return function b () {        console.log(c)    }}a()let aa = a()aa()</code></pre><p>js引擎执行代码，从上到下执行，执行到a函数时发现<code>console.log(a)</code>，这时候引擎和作用域的对话如下：</p><p><img src="/2019/04/15/js作用域和闭包/js引擎与作用域聊天.jpeg" alt=""></p><p>b函数里<code>console.log(c)</code>里查找c以此类推，一层层找。如果在某个作用域里找到了，就不会继续找了，只会返回当前找到的值。</p><p>作用域链是单向的，只能从内到外，外面的执行环境是访问不到函数内部的变量。</p><h2 id="三、闭包"><a href="#三、闭包" class="headerlink" title="三、闭包"></a>三、闭包</h2><pre><code>function foo () {    var a = 2;    function bar () {        console.log(a)    }    return bar;}var f = foo();f();</code></pre><p>我们来执行一下这段代码，</p><p>首先是语法检查，看有没有语法错误，没有，下一步</p><p>创建了全局对象GO，然后进行声明查找，先找变量声明，发现var a = foo();然后声明了一个a，作为GO的属性，值为undefined，然后查找函数声明，发现function foo，然后声明了一个函数foo作为GO的属性，值为foo的函数体。</p><p>然后开始解释执行代码，从上至下，首先将全局执行环境推进栈。</p><p>然后var f = foo() 执行foo函数。</p><p>将foo函数执行环境推进执行栈，然后进行第1-第2步，然后开始执行foo预编译后的代码，给a赋值为2，然后返回了一个函数bar。</p><p>将foo返回的bar赋值给f。这时候foo函数执行完，按照之前我们说的，函数执行完对应函数执行环境栈会被推出执行栈，但是这里没有，这就是闭包的神奇之处。</p><p>f()执行f函数，也就是foo里的bar函数。</p><p>在foo()执行之后，为什么内部作用域还在，没有被回收，是因为有‘人’在使用这个作用域，也就是f()，因为他保持着对foo作用域的引用，所以这个作用域没有被回收，这个引用就是闭包。</p><pre><code>var fn;function foo () {    var a = 2;    function baz () {        console.log(a);    }    fn = baz;}function bb () {    fn();}foo();bb();</code></pre><p>也就是，将函数里的内部函数传递到他定义时所在定义域A之前，这个函数都会保留着对原始定义域A的引用，无论在何时调用这个内部函数都会使用闭包。</p><pre><code>function sleep (message) {    setTimeout(function(){        console.log(message)    }, message)}sleep(&apos;hello&apos;);</code></pre><p>这里也体现了闭包，我们可以先把代码再分解一下。</p><pre><code>function sleep (message) {    function a () {        console.log(message)    }    setTimeout(a, 1000)}sleep(&apos;hello&apos;);</code></pre><p>我们在sleep函数里定义里一个函数a，然后将这个函数a当作参数传给了setTimeout函数，然后执行sleep函数，设置了一个定时器，此时sleep运行完了，理论上他的执行环境要被弹出执行栈，但是因为1秒后这个setTimeout函数时在全局执行环境里去执行的，也就是不是在sleep函数里执行，所以a函数当作参数执行时会保留着对sleep作用域的引用，所以此时输出message是‘hello’。</p><p>这就是闭包的神奇之处。</p><pre><code>for (var i = 0; i &lt; 5; i++) {    setTimeout(function(){        console.log(i)    }, i * 1000)}</code></pre><p>上篇博客说这个程序是隔秒输出5，那么我们想要隔秒输出0，1，2，3，4呢？</p><p>这时候我们就可以利用函数作用域了，我们可以在for循环里定义一个函数，然后将每次循环的i传进函数里，函数里用一个变量存储，这样就能保存每次的i的值。</p><pre><code>for (var i = 0; i &lt; 5; i++) {    function aa(){        var j = i;        setTimeout(function(){            console.log(j)        }, j * 1000)    }    aa(i)}</code></pre><p>然后我们再优化一下这个函数，</p><pre><code>for (var i = 0; i &lt; 5; i++) {    function aa(j){        setTimeout(function(){            console.log(j)        }, j * 1000)    }    aa(i)}</code></pre><p>在aa函数的形参里接收i的值。</p><p>然后我们再可以优化一下</p><pre><code>for (var i = 0; i &lt; 5; i++) {    (function(j){        setTimeout(function(){            console.log(j)        }, j * 1000)    })(i)}</code></pre><p>在这里我们定义了一个匿名函数，然后立即执行了它。</p><p>上面的立即执行函数还有一种写法，把(i)放到（）里</p><pre><code>for (var i = 0; i &lt; 5; i++) {    (function(j){        setTimeout(function(){            console.log(j)        }, j * 1000)    }(i))}</code></pre><p>一个函数怎么执行，一般是函数名+(),比如前面的aa(),然后我们要怎么让一个匿名函数执行呢，匿名函数没有函数名，其实只要把匿名函数的函数声明转换成一个函数表达式然后再加()就可以。</p><p>那么问题就变成了怎么把函数声明变成函数表达式</p><p>上面代码里用一对括号把函数括起来是其中一种方法，在函数前加上一元操作符<code>+</code>,<code>-</code>,<code>!</code>也可以将函数声明转换成表达式。</p><pre><code>-function    (j) {    console.log(j)}(1)+function    (j) {    console.log(j)}(1)!function    (j) {    console.log(j)}(1)</code></pre><p>但是不推荐用<code>+,-,!</code>，因为如果函数有返回值的话，<code>+,-,!</code>会和返回值进行操作。</p><pre><code>var result = -function    (j) {    return j}(1) // result: -1</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、js引擎执行过程&quot;&gt;&lt;a href=&quot;#一、js引擎执行过程&quot; class=&quot;headerlink&quot; title=&quot;一、js引擎执行过程&quot;&gt;&lt;/a&gt;一、js引擎执行过程&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;var a;
console.log(a);
console.log(b);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a = 2;
var a;
console.log(a);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(a);
var a = 2;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出？&lt;/p&gt;
&lt;p&gt;我们之前说过js代码是由上到下去执行的，但是上面代码的输出结果好像显示的不是这样，其实不是的，js代码确实是由上到下去执行的，只是执行的不是我们直接写的代码，而是我们代码通过编译后生成的代码。&lt;/p&gt;
&lt;p&gt;我们可以将js引擎执行过程分为三个阶段，分别是语法分析，预编译和解释执行阶段。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="js作用域 闭包" scheme="http://yoursite.com/tags/js%E4%BD%9C%E7%94%A8%E5%9F%9F-%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript运行机制</title>
    <link href="http://yoursite.com/2019/04/12/JavaScript%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/04/12/JavaScript运行机制/</id>
    <published>2019-04-11T16:13:56.000Z</published>
    <updated>2019-04-15T13:15:23.609Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-1-前言"><a href="#0-1-前言" class="headerlink" title="0.1. 前言"></a>0.1. 前言</h2><h3 id="0-1-1-ES5，ES6和JavaScript的关系"><a href="#0-1-1-ES5，ES6和JavaScript的关系" class="headerlink" title="0.1.1. ES5，ES6和JavaScript的关系"></a>0.1.1. ES5，ES6和JavaScript的关系</h3><p>众所周知，JavaScript是一位网景公司的奇人布兰登艾奇花了十天就开发出来的。一开始JavaScript叫LiveScript，当时Java特别火，为了蹭个热度，网景公司将其改名成了JavaScript。</p><p>微软在IE3的时候加入了JavaScript的实现，为了避免纠纷，命名为JScript。还有其他公司自己研发了JavaScript，所以这样兼容性就称为一个很头疼的事情，所以业内人士强烈呼吁定制一个标准。</p><p>1996年，网景公司将JavaScript提交给国际标准化组织ECMA，次年，该组织发布了浏览器脚本语言的标准，并将这种语言称为ECMAScript，也就是我们常说的ES。所以ES是一种标准，JavaScript是ES的实现。</p><p>ES5是指ECMAScript5.0，ECMAScript5.1版本，ES6是泛指，指5.1版本以后的JavaScript的下一代标准。</p><a id="more"></a><h2 id="0-2-编译性语言-vs-解释性语言"><a href="#0-2-编译性语言-vs-解释性语言" class="headerlink" title="0.2. 编译性语言 vs 解释性语言"></a>0.2. 编译性语言 vs 解释性语言</h2><p>高级语言要经过翻译，称为机器语言，然后才能被计算机识别。</p><p>翻译分为编译和解释。</p><p>编译性语言在程序运行前有一个专门的编译过程，把程序编译成计算机可执行的文件，比如.exe,以后要运行的话就不用在编译了，直接执行就可以了。Java就是比较典型的编译性语言。Java有一句很有名的口号：一次编译，到处运行。</p><p>解释性语言也是要转换成计算机能识别的语言，只是它是在代码运行时执行，所以需要将解释器安装在环境中。</p><p>JavaScript，python是解释性语言。</p><p>需要注意的一点是解释性语言不是说没有编译，它们有的会有编译特性，即时编译的。</p><h2 id="0-3-浏览器内核"><a href="#0-3-浏览器内核" class="headerlink" title="0.3. 浏览器内核"></a>0.3. 浏览器内核</h2><p>浏览器内核指的是浏览器运行的最核心的程序，分为两个部分，JS引擎和渲染引擎。</p><p><img src="/2019/04/12/JavaScript运行机制/浏览器内核.jpg" alt=""></p><p><img src="/2019/04/12/JavaScript运行机制/js引擎.jpg" alt=""></p><p>JavaScript引擎的主要作用是，读取网页中的JavaScript代码，对其处理后运行。</p><h2 id="0-4-引子"><a href="#0-4-引子" class="headerlink" title="0.4. 引子"></a>0.4. 引子</h2><pre><code>console.log(0)setTimeout(function(){    console.log(1)},0)console.log(2)</code></pre><p>输出结果是什么？</p><h2 id="0-5-单线程"><a href="#0-5-单线程" class="headerlink" title="0.5. 单线程"></a>0.5. 单线程</h2><p>单线程说明在同一个时间里只能做一件事情，有人会说js为什么是单线程，不能多线程，多线程效率不更高吗。原因是js主要用来做页面交互，操作DOM。如果是多线程的话，有可能会发生两个线程同时对一个DOM进行操作，比如一个是添加了一个节点，一个是删除节点，那么浏览器怎么去执行？所以为了避免复杂性，js就是单线程的。</p><h2 id="0-6-事件循环机制"><a href="#0-6-事件循环机制" class="headerlink" title="0.6. 事件循环机制"></a>0.6. 事件循环机制</h2><p>事件循环机制分为浏览器和node事件循环机制，在此主要介绍浏览器事件循环机制。</p><p><img src="/2019/04/12/JavaScript运行机制/eventLoop.png" alt=""></p><p>在js中任务分为两种，同步任务和异步任务。</p><p>所谓同步就是函数或方法执行时要接收到返回的值或者消息才会往下执行，相当于打电话，你说一句，我说一句，一句接一句。</p><p>异步则是函数或方法执行时，不需要等待收到返回的信息和值，直接向系统委托一个异步过程，系统接收到返回结果时，系统会触发委托的异步过程，从而完成一个完整的流程。</p><p>一般异步任务有：</p><ol><li>setTimeout和setlnterval</li><li>DOM事件</li><li>ES6中的Promise</li><li>Ajax异步请求</li></ol><p>事件循环机制的流程是这样的：</p><ol><li>主流程上有一个执行栈，同步任务依次进栈排队，任务从栈的顶部开始执行，执行完的任务会被弹出去。</li><li>异步任务有了结果的时候，会在任务队列里放入‘回调’事件。</li><li>执行栈里所有的同步任务运行完后，会去任务队列里查看，是否还有任务，如果有的话就会将任务读进执行栈中，开始执行。</li><li>主线程不断重复以上3个行为。</li></ol><p>因为这个过程是循环不断的，所以称为事件循环机制。</p><h3 id="0-6-1-练习题-写出以下输出结果"><a href="#0-6-1-练习题-写出以下输出结果" class="headerlink" title="0.6.1. 练习题 写出以下输出结果"></a>0.6.1. 练习题 写出以下输出结果</h3><p>练习题1</p><pre><code>console.log(&apos;a&apos;)while(true){}console.log(&apos;b&apos;)</code></pre><p>练习题2</p><pre><code>console.log(&apos;1&apos;)setTimeout(function(){     console.log(&apos;2&apos;) },0)while(true){}</code></pre><p>练习题3</p><pre><code>for(var i = 0; i &lt; 5; i++) {    setTimeout(function(){        console.log(i)    },1000)} </code></pre><p>练习题4</p><pre><code>for(var i = 0; i &lt; 5; i++) {    setTimeout(function(){        console.log(i)    },1000 * i)} </code></pre><p>作业</p><p>怎么依次隔秒输出0，1，2，3，4</p><h2 id="0-7-css常见布局"><a href="#0-7-css常见布局" class="headerlink" title="0.7. css常见布局"></a>0.7. css常见布局</h2><h3 id="0-7-1-上定高，中间分左右，左定宽，右自适应"><a href="#0-7-1-上定高，中间分左右，左定宽，右自适应" class="headerlink" title="0.7.1. 上定高，中间分左右，左定宽，右自适应"></a>0.7.1. 上定高，中间分左右，左定宽，右自适应</h3><h3 id="0-7-2-div垂直水平居中"><a href="#0-7-2-div垂直水平居中" class="headerlink" title="0.7.2. div垂直水平居中"></a>0.7.2. div垂直水平居中</h3><ol><li><p>行内元素居中 缺点： 会继承，影响到后代行内内容，子元素大于父元素宽度时无效</p><p> text-align: center</p></li><li><p>单个块级元素 必须定宽，且元素宽度要小于父元素宽度</p><p> width: 100px // 定宽<br> margin: 0 auto</p></li><li><p>多个块级元素</p><p> <code>#parant</code> { text-aligin: center}</p><p> <code>#son</code> {display: inline-block}</p></li><li><p>使用绝对定位 （子元素定宽定高）</p><p> <code>#parant</code> { </p><pre><code>position: relativewidth: 100px</code></pre><p> }</p><p> <code>#son</code> {</p><pre><code>position: absoluteleft: 50%width： 100pxheight：100pxmargin-left: -50px // 或者translateX(-50%)margin-top：-50px; // translateY(-50%)</code></pre><p> }</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0-1-前言&quot;&gt;&lt;a href=&quot;#0-1-前言&quot; class=&quot;headerlink&quot; title=&quot;0.1. 前言&quot;&gt;&lt;/a&gt;0.1. 前言&lt;/h2&gt;&lt;h3 id=&quot;0-1-1-ES5，ES6和JavaScript的关系&quot;&gt;&lt;a href=&quot;#0-1-1-ES5，ES6和JavaScript的关系&quot; class=&quot;headerlink&quot; title=&quot;0.1.1. ES5，ES6和JavaScript的关系&quot;&gt;&lt;/a&gt;0.1.1. ES5，ES6和JavaScript的关系&lt;/h3&gt;&lt;p&gt;众所周知，JavaScript是一位网景公司的奇人布兰登艾奇花了十天就开发出来的。一开始JavaScript叫LiveScript，当时Java特别火，为了蹭个热度，网景公司将其改名成了JavaScript。&lt;/p&gt;
&lt;p&gt;微软在IE3的时候加入了JavaScript的实现，为了避免纠纷，命名为JScript。还有其他公司自己研发了JavaScript，所以这样兼容性就称为一个很头疼的事情，所以业内人士强烈呼吁定制一个标准。&lt;/p&gt;
&lt;p&gt;1996年，网景公司将JavaScript提交给国际标准化组织ECMA，次年，该组织发布了浏览器脚本语言的标准，并将这种语言称为ECMAScript，也就是我们常说的ES。所以ES是一种标准，JavaScript是ES的实现。&lt;/p&gt;
&lt;p&gt;ES5是指ECMAScript5.0，ECMAScript5.1版本，ES6是泛指，指5.1版本以后的JavaScript的下一代标准。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>D3.js画3D方柱</title>
    <link href="http://yoursite.com/2019/03/28/D3.js%E7%94%BB3D%E6%96%B9%E6%9F%B1/"/>
    <id>http://yoursite.com/2019/03/28/D3.js画3D方柱/</id>
    <published>2019-03-28T08:24:45.000Z</published>
    <updated>2019-03-28T09:45:39.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="D3-js入门实例-3D方柱"><a href="#D3-js入门实例-3D方柱" class="headerlink" title="D3.js入门实例-3D方柱"></a>D3.js入门实例-3D方柱</h2><p>最近由于项目需要去实现3D可视化，所以学了一下D3.js。使用版本是v4.x。<br><a id="more"></a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们先定义下要引用的参数</p><pre><code>let param = {    data: [        {            xName: &apos;1月&apos;，            value: &apos;0.01&apos;        },        {            xName: &apos;2月&apos;，            value: &apos;0.1&apos;        },        {            xName: &apos;3月&apos;，            value: &apos;1000&apos;        },        {            xName: &apos;4月&apos;，            value: &apos;7&apos;        },        {            xName: &apos;5月&apos;，            value: &apos;22&apos;        },        {            xName: &apos;6月&apos;，            value: &apos;90&apos;        },        {            xName: &apos;7月&apos;，            value: &apos;700&apos;        }    ],    padding: { // svg内部padding        top: 20,        bottom: 20,        left: 20,        right: 20    },    svgHeight: 500, // svg高度    svgWdith: 500, // svg宽度    id: &apos;#js-svg&apos; // svg标签}</code></pre><h3 id="比例尺"><a href="#比例尺" class="headerlink" title="比例尺"></a>比例尺</h3><p>我们画一个柱状图，y轴的数据大小如上，最大值和最小值之间间隔由差不多1000，我们不可能在y轴坐标上显示0到1000都显示出来,这时候我们需要一个映射关系，由某个区域的值去映射到另一个区域，但是它们之间的关系不变。</p><p>在这里，我主要介绍两个常用比例尺，线性比例尺和序数比例尺。</p><p>这个实例中，我们X轴用的是序数比例尺，Y轴用的是线性比例尺。</p><h4 id="线性比例尺（Y轴）"><a href="#线性比例尺（Y轴）" class="headerlink" title="线性比例尺（Y轴）"></a>线性比例尺（Y轴）</h4><p>定义一个Y轴比例尺函数</p><pre><code>let drawYscale () {}</code></pre><p>在函数里定义一个线性比例尺</p><pre><code>d3.scaleLinear()</code></pre><p>接下来我们要规定其定义域 domain(arr)</p><pre><code>d3.scaleLinear().domain(param.data.map((d) =&gt; {    return d.value}))</code></pre><p>注意：这里domain(arr)接受一个数值数组，数组需要包含两个及两个以上值，而且如果不是数值会被强制转换成数值类型。多个值会形成分段比例尺。</p><p>然后我们规定值域 range([range])</p><pre><code>d3.scaleLinear().domain(param.data.map((d) =&gt; {    return d.value})).range([svgHeight - padding.top - padding.bottom, 0])</code></pre><p>range和domain一样，接受一个数组，和domain不一样的是数组不一定是要数值类型。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;D3-js入门实例-3D方柱&quot;&gt;&lt;a href=&quot;#D3-js入门实例-3D方柱&quot; class=&quot;headerlink&quot; title=&quot;D3.js入门实例-3D方柱&quot;&gt;&lt;/a&gt;D3.js入门实例-3D方柱&lt;/h2&gt;&lt;p&gt;最近由于项目需要去实现3D可视化，所以学了一下D3.js。使用版本是v4.x。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="D3.js" scheme="http://yoursite.com/tags/D3-js/"/>
    
  </entry>
  
  <entry>
    <title>Git浅解</title>
    <link href="http://yoursite.com/2018/09/05/Git%E6%B5%85%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/09/05/Git浅解/</id>
    <published>2018-09-05T12:16:00.000Z</published>
    <updated>2019-03-17T13:07:33.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git浅解"><a href="#Git浅解" class="headerlink" title="Git浅解"></a><center>Git浅解</center></h1><h2 id="一、为什么选择Git"><a href="#一、为什么选择Git" class="headerlink" title="一、为什么选择Git"></a>一、为什么选择Git</h2><p>比如我们写东西的时候刚开始写了一部分，先保存为了文章1，然后后续写的时候，改了一些东西，删除了之前的一部分，但是你又可能需要之前的部分，所以你会另存为文章2，所以这样下去，等你的文章写完，可能会有文章1,2,3,4。。。很多个副本，然后你想去找其中的一段，但是又可能不记得在哪了，所以要一个个文件查看，这样就没有效率，重复做了很多事情，而且很乱。</p><p>然后Git可以帮你解决这些问题，它能帮我们记录每次文件的改动，而且可以多人协同完成，这样我们可以快速，高效的进行版本管理。</p><p>GIt是分布式版本控制系统。</p><p>Git不需要联网，每个人都可以拷贝一份完整的版本库到本地，然后在本地进行一系列操作。</p><h2 id="二、学习Git前须知"><a href="#二、学习Git前须知" class="headerlink" title="二、学习Git前须知"></a>二、学习Git前须知</h2><h3 id="（1）git文件的四种状态"><a href="#（1）git文件的四种状态" class="headerlink" title="（1）git文件的四种状态"></a>（1）git文件的四种状态</h3><ol><li>modified 修改了，但没有被保存在本地版本库</li><li>staged（已暂存）</li><li>untracked（）</li><li>commit（已提交）</li></ol><h3 id="（2）git的五个区域"><a href="#（2）git的五个区域" class="headerlink" title="（2）git的五个区域"></a>（2）git的五个区域</h3><h2 id="三、一般使用Git的流程"><a href="#三、一般使用Git的流程" class="headerlink" title="三、一般使用Git的流程"></a>三、一般使用Git的流程</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Git浅解&quot;&gt;&lt;a href=&quot;#Git浅解&quot; class=&quot;headerlink&quot; title=&quot;Git浅解&quot;&gt;&lt;/a&gt;&lt;center&gt;Git浅解&lt;/center&gt;&lt;/h1&gt;&lt;h2 id=&quot;一、为什么选择Git&quot;&gt;&lt;a href=&quot;#一、为什么选择Git&quot; cl
      
    
    </summary>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》DOM扩展</title>
    <link href="http://yoursite.com/2018/09/04/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8BDOM%E6%89%A9%E5%B1%95/"/>
    <id>http://yoursite.com/2018/09/04/《JavaScript高级程序设计》DOM扩展/</id>
    <published>2018-09-04T07:46:57.000Z</published>
    <updated>2018-09-07T07:11:24.329Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DOM扩展"><a href="#DOM扩展" class="headerlink" title="DOM扩展"></a><center>DOM扩展</center></h1><h2 id="一、选择符API（重要）"><a href="#一、选择符API（重要）" class="headerlink" title="一、选择符API（重要）"></a>一、选择符API（重要）</h2><p>平时我们写代码的时候最常用的一个操作就是根据css选择符选择与某个模式匹配的DOM元素，比如$(“css选择符”)。但是用jquery的话我们必须引用jquery库。现在我们可以不需要引js库就可以实现这个功能。</p><p>选择符API的核心是两个方法：querySelector()和querySelectorAll()。还有一个matchesSelector()方法。</p><p>Document、Element，DocumentFragment三种类型的元素都有这两个方法。<br><a id="more"></a><br>兼容性(2018.09.04查询)<br><img src="/2018/09/04/《JavaScript高级程序设计》DOM扩展/jrx.png" alt=""></p><h3 id="1-querySelector"><a href="#1-querySelector" class="headerlink" title="1. querySelector()"></a>1. querySelector()</h3><p>该方法接收一个css选择器，返回与该模式匹配的第一个元素，如果没有找到匹配的元素，则会返回null。如果传入了不被支持的选择符，会报错。</p><p>通过Document类型调用该方法，会在文档元素的范围内查找匹配的元素。而通过Element类型调用，只会在该元素后代元素范围内查找匹配的元素。</p><p><code>html</code></p><pre><code>&lt;span class=&quot;outside&quot;&gt;outside&lt;/span&gt;&lt;div id=&quot;my-id&quot;&gt;        &lt;span class=&quot;outside&quot;&gt;my-id outside&lt;/span&gt;     &lt;span id=&quot;inside&quot;&gt;inside&lt;/span&gt;     &lt;div class=&quot;lonely&quot;&gt;lonely&lt;/div&gt;     &lt;div class=&quot;outer&quot;&gt;          &lt;div class=&quot;inner&quot;&gt;inner&lt;/div&gt;     &lt;/div&gt;&lt;/div&gt;</code></pre><p>Document</p><p><code>js</code></p><pre><code>var lonely = document.querySelector(&quot;#my-id .lonely&quot;);var outside1 = document.querySelector(&quot;#outside1&quot;); //nullvar inside = document.querySelector(&quot;#.inside&quot;);//报错</code></pre><p>结果：</p><p><img src="/2018/09/04/《JavaScript高级程序设计》DOM扩展/querySelector.png" alt=""></p><p>Element</p><pre><code>var myId = document.querySelector(&quot;#my-id&quot;);var outer = myId.querySelector(&quot;.outer&quot;);var outside = myId.querySelector(&quot;.outside&quot;);</code></pre><p><img src="/2018/09/04/《JavaScript高级程序设计》DOM扩展/querySelector-element.png" alt=""></p><h3 id="2-querySelectorAll"><a href="#2-querySelectorAll" class="headerlink" title="2.querySelectorAll()"></a>2.querySelectorAll()</h3><p>该方法接收的参数也是一个css选择符，返回的是一个NodeList的实例，返回的是所有匹配的元素而不仅仅是返回的一个元素。</p><p>NodeList 对象是一个节点的集合，是由 Node.childNodes 和 document.querySelectorAll 返回的.</p><p>大多数情况下，我们使用Node.childNodes返回的NodeList是一个实时的集合，也就是页面节点又变化是，NodeList会跟着改变。</p><pre><code>var myId = document.querySelector(&quot;#my-id&quot;);var childNodes = myId.childNodes; //9myId.appendChild(document.createElement(&apos;div&apos;));var childNodes2 = myId.childNodes;//10</code></pre><p><img src="/2018/09/04/《JavaScript高级程序设计》DOM扩展/childnodes.png" alt=""> </p><p>querySelectorAll()返回的是一个静态的nodeList，是一个快照。这样可以避免使用NodeList对象通常会引起的大多数性能问题。</p><pre><code>var myId = document.querySelector(&quot;#my-id&quot;);var nodes = document.querySelectorAll(&quot;div&quot;);console.log(&quot;nodes:&quot;);console.log(nodes);myId.appendChild(document.createElement(&apos;div&apos;));var nodes2 = document.querySelectorAll(&quot;div&quot;);console.log(&quot;nodes2:&quot;);console.log(nodes2);console.log(&quot;nodes:&quot;);console.log(nodes);</code></pre><p><img src="/2018/09/04/《JavaScript高级程序设计》DOM扩展/querySelectorAll.png" alt=""></p><p> 只要传给querySelectorAll()方法的css选择符有效，该方法都会返回一个NodeList对象，如果没有找到匹配的元素，NodeList就是空的。  </p><pre><code>var aNodes = document.querySelectorAll(&quot;a&quot;);   console.log(&quot;aNodes&quot;);console.log(aNodes);</code></pre><p><img src="/2018/09/04/《JavaScript高级程序设计》DOM扩展/nodelist-null.png" alt=""><br>思考：下面两个获取方法得到的内容是一样的么？</p><pre><code>var div = document.querySelectorAll(&quot;#my-id div div&quot;);console.log(&quot;div:&quot;);console.log(div);var div2 = document.querySelector(&quot;#my-id&quot;).querySelectorAll(&quot;div div&quot;);console.log(&quot;div2:&quot;);console.log(div2);</code></pre><p><img src="/2018/09/04/《JavaScript高级程序设计》DOM扩展/querySelectorAll2.png" alt=""></p><p>原因：CSS选择器是独立于整个页面的！</p><p>这里的querySelectorAll里面的选择器也同样是这也全局特性。document.querySelector(“#my-id”).querySelectorAll(“div div”)翻译成白话文就是：查询#my-id的子元素，同时满足整个页面下div div选择器条件的DOM元素们。</p><p>使用场景？</p><h3 id="3-matchesSelector（）方法"><a href="#3-matchesSelector（）方法" class="headerlink" title="3.matchesSelector（）方法"></a>3.matchesSelector（）方法</h3><p>这个方法接收一个参数，css选择符，如果调用元素与该选择符匹配，返回true，否则为false。</p><p>if(document.body.webkitMatchesSelector(“body”)){<br>        console.log(“webkitMatchesSelector”);<br>    }</p><h2 id="二、元素遍历"><a href="#二、元素遍历" class="headerlink" title="二、元素遍历"></a>二、元素遍历</h2><p> 对于元素间的空格，IE9及之前的版本不会返回文本节点，这样就导致了在使用childNodes和firstChild等属性时行为不一致。</p><p> 所以Element Traversal API 为DOM元素添加了以下5个属性。</p><p> childElementCount： 返回子元素（不包括文本节点和注释）的个数</p><p> firstElementChild：只想第一个子元素</p><p> lastElementChild： 指向最后一个元素</p><p> previousElmentSlibling：指向前一个同辈元素</p><p> nextElementSibling：指向后一个同辈元素</p><h2 id="三、HTML5（重要）"><a href="#三、HTML5（重要）" class="headerlink" title="三、HTML5（重要）"></a>三、HTML5（重要）</h2><h3 id="1-与类相关的扩充"><a href="#1-与类相关的扩充" class="headerlink" title="1.与类相关的扩充"></a>1.与类相关的扩充</h3><ol><li><p>getElementsByClassName()<br> 该方法接收一个参数，即包含一或多个类名的字符串，返回带有指定类的所有元素的NodeList。类名的先后顺序无所谓。</p></li><li><p>classLists属性</p><pre><code>&lt;div id=&quot;dd&quot; class=&quot;bd user do&quot;&gt;2222&lt;/div&gt;var dd = document.querySelector(&quot;#dd&quot;);console.log(dd.classList);</code></pre></li></ol><p>add(value): 将给定的字符串添加到列表中，如果值有，就不添加</p><p>contains(value): 表示列表中是否存在给定的值，如果存在则返回true，如果不存在false</p><p>remove(value):从列表中删除给定的字符串</p><p>toggle(value):如果列表中已经存在给定的值，删除它，如果列表中每一给定的值，添加它。</p><h3 id="2-自定义数据属性"><a href="#2-自定义数据属性" class="headerlink" title="2 自定义数据属性"></a>2 自定义数据属性</h3><p>html5规定要添加非标准的属性，但是要加前缀data-，目的是为元素提供与渲染无关的信息，或者提供语义信息</p><p>例如：</p><pre><code>&lt;div id=&quot;myDiv&quot; data-appId=&quot;123&quot; data-myname=&quot;hzq&quot;&gt;</code></pre><p>t添加了自定义属性后，我们可以通过元素的dataset属性来访问自定义属性的值</p><h3 id="3-插入标记"><a href="#3-插入标记" class="headerlink" title="3.插入标记"></a>3.插入标记</h3><p>使用场景：</p><p>我们需要给文档插入大量新的标记，我们不仅要创建一系列DOM节点，然后还要小心的按照正确的顺序把他们连接起来。</p><h4 id="a：innerHTML属性"><a href="#a：innerHTML属性" class="headerlink" title="a：innerHTML属性"></a>a：innerHTML属性</h4><p>在读模式，innerHTML属性返回与调用元素的所有子节点（包括元素，注释和文本节点）对应的HTML标记。</p><p>在写模式，innnerHTML会根据制定的值创建新的DOM树，然后用这个DOM树完全替换调用元素原先的所有子节点。</p><pre><code>&lt;div id=&quot;content&quot;&gt;    &lt;p&gt;hello&lt;/p&gt;    &lt;ul&gt;        &lt;li&gt;item 1&lt;/li&gt;        &lt;li&gt;item 1&lt;/li&gt;        &lt;li&gt;item 1&lt;/li&gt;     &lt;/ul&gt; &lt;/div&gt;var innerHTML = document.querySelector(&quot;#content&quot;).innerHTML;console.log(innerHTML);</code></pre><p>返回的是</p><pre><code>&lt;p&gt;hello&lt;/p&gt;    &lt;ul&gt;        &lt;li&gt;item 1&lt;/li&gt;        &lt;li&gt;item 1&lt;/li&gt;        &lt;li&gt;item 1&lt;/li&gt;    &lt;/ul&gt;</code></pre><p> 写模式：</p><pre><code>document.querySelector(&quot;#content&quot;).innerHTML = &quot;&lt;p&gt;hello,world&lt;/p&gt;&quot;;   var innerHTML = document.querySelector(&quot;#content&quot;).innerHTML; console.log(innerHTML);//&lt;p&gt;hello,world&lt;/p&gt;</code></pre><p>并不是所有元素都支持innerHTML属性，不支持的有：<br>    <code>&lt;col</code>&gt;,<code>&lt;colgroup</code>&gt;,<code>&lt;frameset&gt;</code>,<code>&lt;head&gt;</code>,<code>&lt;html&gt;</code>,<code>&lt;style&gt;</code>,<code>&lt;table&gt;</code>,<code>&lt;tbody&gt;</code>,<code>&lt;thead&gt;</code>,<code>&lt;tfoot&gt;</code>,<code>&lt;tr&gt;</code></p><h4 id="b-outerHTML"><a href="#b-outerHTML" class="headerlink" title="b: outerHTML"></a>b: outerHTML</h4><p>在读模式，outerHTML返回调用它的元素及所有子节点的HTML标签，在写模式下，outerHTML会根据制定的HTML字符串去创建新的DOM子树，然后用这个DOM树去完全替换调用元素。</p><h4 id="c：内存与性能问题"><a href="#c：内存与性能问题" class="headerlink" title="c：内存与性能问题"></a>c：内存与性能问题</h4><p>我们在使用这两个属性时，可能删除了之前的元素，元素上有一个事件处理程序，从文档树中删除了元素，但是元素与事件处理程序之间的绑定关系在内存中并没有删除，这样日积月累，页面占有的内存会越来越多，所以我们使用上面的方法时最好手动删除要被删除的元素的事件处理程序和js对象属性。</p><h3 id="4-scrollIntoView"><a href="#4-scrollIntoView" class="headerlink" title="4.scrollIntoView()"></a>4.scrollIntoView()</h3><p>为了方便开发人员更好的控制页面滚动，HTML5选择了scrollIntoView()作为标准方法。</p><p>scrollIntoView()可以在所有HTML元素上调用，通过滚动浏览器窗口或者某个容器元素，调用元素就会出现在视口中。如果给这个方法传入true作为参数，或者不传入参数，那么窗口滚动之后会 让调用元素的顶部与视口顶部尽可能齐平。如果传入false作为参数，调用元素会尽可能全部出现在视口中，可能的话调用元素的底部会与视口底部齐平。</p><p>移动端开发可能用的比较多，input和键盘。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;DOM扩展&quot;&gt;&lt;a href=&quot;#DOM扩展&quot; class=&quot;headerlink&quot; title=&quot;DOM扩展&quot;&gt;&lt;/a&gt;&lt;center&gt;DOM扩展&lt;/center&gt;&lt;/h1&gt;&lt;h2 id=&quot;一、选择符API（重要）&quot;&gt;&lt;a href=&quot;#一、选择符API（重要）&quot; class=&quot;headerlink&quot; title=&quot;一、选择符API（重要）&quot;&gt;&lt;/a&gt;一、选择符API（重要）&lt;/h2&gt;&lt;p&gt;平时我们写代码的时候最常用的一个操作就是根据css选择符选择与某个模式匹配的DOM元素，比如$(“css选择符”)。但是用jquery的话我们必须引用jquery库。现在我们可以不需要引js库就可以实现这个功能。&lt;/p&gt;
&lt;p&gt;选择符API的核心是两个方法：querySelector()和querySelectorAll()。还有一个matchesSelector()方法。&lt;/p&gt;
&lt;p&gt;Document、Element，DocumentFragment三种类型的元素都有这两个方法。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>变基git rebase中的基是什么</title>
    <link href="http://yoursite.com/2018/08/28/%E5%8F%98%E5%9F%BAgit-rebase%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>http://yoursite.com/2018/08/28/变基git-rebase中的基是什么/</id>
    <published>2018-08-27T16:01:26.000Z</published>
    <updated>2018-08-29T06:42:11.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="变基-git-rebase-中的基是什么？"><a href="#变基-git-rebase-中的基是什么？" class="headerlink" title="变基(git rebase)中的基是什么？"></a>变基(git rebase)中的基是什么？</h1><p>git rebase 在官网中的定义是：重新应用commits到要合并到的分支的顶端。（一个英语渣的直译，见笑了）。其实也可以这么说是重新应用commits到要合并到的分支的最新提交。如果现在还没有理解，没有关系，现在我开始仔细说明git rebase都干了什么。</p><p>假设我们现在是A研发人员，此时本地分支是master,然后远程有两个分支：origin/master,origin/develop。此时我们接到一个任务，我们要在develop分支上开发一个功能，所以此时我们要切换分支。<br><a id="more"></a></p><p><img src="/2018/08/28/变基git-rebase中的基是什么/changj.png" alt=""></p><p>切换分支我们需要用到的命令是：</p><pre><code>git checkout -b local_develop origin/develop</code></pre><p>该命令其实做了两个操作，第一个是拷贝了远程的origin/develop到本地，致使本地多了一个分支，第二个是把该分支命名为local_develop。</p><p>假设此时远程的origin/develop分支上已经有两个提交。，所以我们查看远程分支的日志（git log origin/develop）可以看到提交的树状图如下：</p><p><img src="/2018/08/28/变基git-rebase中的基是什么/001.png" alt=""></p><p>此时你本地的提交日志（git log）的树状图如下：</p><p><img src="/2018/08/28/变基git-rebase中的基是什么/002.png" alt=""></p><p>经过一段时间，你把功能开发完成了，此时提交代码(git commit -m “[+]添加功能”)，把你本地的代码提交到远程分支上。这时候你发现在你提交之前，有其他的同事在develop分支（这里指的是origin/develop）上提交了两次代码。所以此时的树状图是这样的：远程分支的提交已经有四次了，此时你的提交编号应该为5.</p><p><img src="/2018/08/28/变基git-rebase中的基是什么/003.png" alt=""></p><p>commit后，如果有修改过但是未commit的文件，我们应该执行驻藏命令 git stash 将这些文件保留到驻藏区，然后进行代码的拉取git fetch ，然后执行合并分支，git rebase. </p><p>该命令会执行两个步骤，第一个是把你本地分支的新添加的全部的commit的补丁（patch）,我理解为是备份，也就是把他们的备份临时放到.git/rebase目录下，然后把commit撤销掉。<br>也就是这样：</p><p><img src="/2018/08/28/变基git-rebase中的基是什么/004.png" alt=""></p><p>第二个步骤是在要合并到的分支（origin/develop）的最新的commit的基础上应用这些补丁。也就是把4和5’进行合并，然后推送代码 git push.</p><p><img src="/2018/08/28/变基git-rebase中的基是什么/005.png" alt=""></p><p>到这里，我们可以知道变基的基是什么了吧。就是要要合并到的分支（origin/develop）的最新的提交（在上面例子里，这个基就是4）。</p><p>明白了git rebase的操作后，我们可以发现，如果使用git rebase命令来合并分支的话，分支的树状图都是“单线”，都是一条直线。这样的树状图是非常优美的。</p><p>现在我们也可以来了解一下另一个合并分支的命令(git merge).</p><p>merge命令非常简单粗暴，就是把你本地最新的提交和远程最新的提交合并一下，得到一份最新的提交。</p><p><img src="/2018/08/28/变基git-rebase中的基是什么/006.png" alt=""></p><p>用merge命令的话树状图就会看着很乱，有各种线交叉，看着非常不友好。</p><p>所以拉代码推荐git fetch + git rebase.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;变基-git-rebase-中的基是什么？&quot;&gt;&lt;a href=&quot;#变基-git-rebase-中的基是什么？&quot; class=&quot;headerlink&quot; title=&quot;变基(git rebase)中的基是什么？&quot;&gt;&lt;/a&gt;变基(git rebase)中的基是什么？&lt;/h1&gt;&lt;p&gt;git rebase 在官网中的定义是：重新应用commits到要合并到的分支的顶端。（一个英语渣的直译，见笑了）。其实也可以这么说是重新应用commits到要合并到的分支的最新提交。如果现在还没有理解，没有关系，现在我开始仔细说明git rebase都干了什么。&lt;/p&gt;
&lt;p&gt;假设我们现在是A研发人员，此时本地分支是master,然后远程有两个分支：origin/master,origin/develop。此时我们接到一个任务，我们要在develop分支上开发一个功能，所以此时我们要切换分支。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript的創建方法</title>
    <link href="http://yoursite.com/2018/08/23/JavaScript%E7%9A%84%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/08/23/JavaScript的创建对象方法/</id>
    <published>2018-08-23T03:36:01.000Z</published>
    <updated>2018-08-23T03:39:06.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript创建对象的几种方法"><a href="#JavaScript创建对象的几种方法" class="headerlink" title="JavaScript创建对象的几种方法"></a>JavaScript创建对象的几种方法</h1><h2 id="一、理解对象"><a href="#一、理解对象" class="headerlink" title="一、理解对象"></a>一、理解对象</h2><p>ECMA-262把对象定义为： 无序属性的集合，其属性可以包含基本值，对象或者函数。每个对象都是基于一个引用<br>类型创建的，这个引用类型可以是原生类型，比如Object，Array等，也可以是自己定义的类型。<a id="more"></a></p><h2 id="二、常用方法"><a href="#二、常用方法" class="headerlink" title="二、常用方法"></a>二、常用方法</h2><h3 id="（1）创建单个对象"><a href="#（1）创建单个对象" class="headerlink" title="（1）创建单个对象"></a>（1）创建单个对象</h3><p>情景模式： 现在我们要创建一家公司的人员。<br>创建单个对象，也就是我们要创建一个人员。</p><h4 id="a-创建Object实例"><a href="#a-创建Object实例" class="headerlink" title="a. 创建Object实例"></a>a. 创建Object实例</h4><pre><code>传说女娲造人，Object其实可以想象成女娲，所有的对象都是Object的实例。   var person = new Object();   person.name = &quot;zzilcc&quot;;   person.age = 23;</code></pre><p>new 其实做了四件事情。</p><pre><code>1. 创建了一个对象2. 把当前作用域赋值给这个对象3. 执行构造函数里的代码4. 返回这个对象但是我们更常用的方法是对象字面量方法。简单好理解。</code></pre><h4 id="b-对象字面量方法"><a href="#b-对象字面量方法" class="headerlink" title="b .对象字面量方法"></a>b .对象字面量方法</h4><pre><code>var person = {    name: &quot;bbb&quot;,    age: 23,    sayName: function(){        console.log(this.name);    }}</code></pre><h3 id="2-创建多个对象"><a href="#2-创建多个对象" class="headerlink" title="(2) 创建多个对象"></a>(2) 创建多个对象</h3><h4 id="a-工厂模式"><a href="#a-工厂模式" class="headerlink" title="a. 工厂模式"></a>a. 工厂模式</h4><p>此时，如果我们要创建多个人员，我们可能会这样写</p><pre><code>var person1 = new Object();person1.name = &quot;aaa&quot;;person1.age = 23;person1.sayName = function(){    console.log(this.name);};var person2 = new Object();person2.name = &quot;bbb&quot;;person2.age = 23;person2.sayName = function(){    console.log(this.name);};var person3 = new Object();person3.name = &quot;ccc&quot;;person3.age = 23;person3.sayName = function(){    console.log(this.name);};var person4 = new Object();person4.name = &quot;ddd&quot;;person4.age = 23;person4.sayName = function(){    console.log(this.name);};</code></pre><p>这是我们会发现，我们写了大量重复的代码，能不能把相同代码放到一起，每次调用一下就好了，所以就有了工厂模式。</p><pre><code>function  createPerson (name,age) {    var o = new Object();    o.name = name;    o.age = age;    o.sayName = function(){        console.log(this.name);    }}var person1 = createPerson(&quot;aaa&quot;,23);var person2 = createPerson(&quot;bbb&quot;,21);var person3 = createPerson(&quot;ccc&quot;,24);var person4 = createPerson(&quot;ddd&quot;,22);</code></pre><p>这样我们创建相似对象就可以减少重复代码量。但是这个方法有的缺点就是无法解决对象识别的问题。也就是通过工厂模式产生的对象只能知道是“女娲”（object）造出来的实例，他们之间不能细分到是这是男人还是女人。</p><h4 id="b-构造函数模式"><a href="#b-构造函数模式" class="headerlink" title="b. 构造函数模式"></a>b. 构造函数模式</h4><p>这时候构造函数模式就可以解决对象识别的问题了。因为构造函数可以用来创建特定类型的对象。构造函数可以想象成女娲的各种法术，一种法术产生一种类型的人员，比如这种法术是生成“女性”，那种法术是生成“男性”。构造函数有原生构造函数和自定义的构造函数，非常人性化。</p><pre><code>function Male(name,age){    this.sex = &quot;male&quot;;    this.name = name;    this.age = age;    this.sayName = function(){        console.log(this.name)    }}var male1 = Male(&quot;aa&quot;,23);var male2 = Male(&quot;xx&quot;,22);按照惯例，构造函数的函数名首字母要大写。我们可以通过instanceof操作符检测对象类型。使用构造函数意味着把它实例标识为一种特定的类型，比如男人，女人，老人，小孩等等。这也是工厂函数无法解决的问题。console.log(male1 instanceof Object); //trueconsole.log(male2 instanceof Object); //trueconsole.log(male1 instanceof Male); //trueconsole.log(male1 instanceof Male); //true</code></pre><p>male1,,male2是Object的实例，也是Male的实例。</p><p>但是这个方法也是有自己的缺点的，也就是每个方法都要在每个实例上重新创建一遍。</p><pre><code>function Male(name,age){    this.sex = &quot;male&quot;;    this.name = name;    this.age = age;    this.sayName = function(){        console.log(this.name)    }}</code></pre><p>也就是我们每次new Male()的时候，我们都要去重新创建一次sayName方法。<br>        因为函数也是一个对象，所以上面的函数我们可以改写成</p><pre><code>function Male(name,age){        this.sex = &quot;male&quot;;        this.name = name;        this.age = age;        this.sayName = new Function(&quot;console.log(this.name)&quot;);    }</code></pre><p>也就是我们每次new Male()的时候我们都创建了一个Function的实例，那为什么我们不能在全局环境中创建一个，然后再Male函数里调用。</p><p>所以我们可以改写成下面这样：</p><pre><code>function Male(name,age){        this.sex = &quot;male&quot;;        this.name = name;        this.age = age;        this.sayName = sayName;    }    function sayName(){        console.log(this.name);    }</code></pre><p>但是这么干的话，其实也不合适，因为sayName函数明明是为你Male所用的，但是你却把它放到全局里，这不符合全局的概念。<br>而且要是构造很熟有很多函数的话，那么全局作用域就有很多“全局”函数，那样我们自定义的引用类型就没有封装性可言了。</p><h4 id="c-原型模式"><a href="#c-原型模式" class="headerlink" title="c. 原型模式"></a>c. 原型模式</h4><p>我们创建的每个函数都有一个原型（prototype）属性,这个属性是一个指针，指向一个对象。这个对象包含了一些属性和方法，这些属性和方法是被特定类型的所有实例共享的。也就是说prototype是我们通过构造函数创建的对象实例的原型对象。也就是我们把想要所有对象实例都共享的方法和实行都添加到原型中，而不是构造函数中。</p><pre><code>funtiton Person(){};Person.prototype.name = &quot;aa&quot;;Person.prototype.age = 23;Person.sayName.sayName = function() {    console.log(this.name)}var person1 = new Person();person1.sayName();//&quot;aa&quot;</code></pre><p>我们把公用属性和方法放到了Person的原型中， 所以每个实例访问的都是同一组属性和同一个方法。这样就不用把方法放到全局环境去写了，就解决了构造函数把私有方法放到全局的问题</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JavaScript创建对象的几种方法&quot;&gt;&lt;a href=&quot;#JavaScript创建对象的几种方法&quot; class=&quot;headerlink&quot; title=&quot;JavaScript创建对象的几种方法&quot;&gt;&lt;/a&gt;JavaScript创建对象的几种方法&lt;/h1&gt;&lt;h2 id=&quot;一、理解对象&quot;&gt;&lt;a href=&quot;#一、理解对象&quot; class=&quot;headerlink&quot; title=&quot;一、理解对象&quot;&gt;&lt;/a&gt;一、理解对象&lt;/h2&gt;&lt;p&gt;ECMA-262把对象定义为： 无序属性的集合，其属性可以包含基本值，对象或者函数。每个对象都是基于一个引用&lt;br&gt;类型创建的，这个引用类型可以是原生类型，比如Object，Array等，也可以是自己定义的类型。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript对象" scheme="http://yoursite.com/tags/JavaScript%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>vue指令</title>
    <link href="http://yoursite.com/2018/07/16/vue%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/07/16/vue指令/</id>
    <published>2018-07-16T06:09:37.000Z</published>
    <updated>2018-08-29T06:40:14.726Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue指令"><a href="#vue指令" class="headerlink" title="vue指令"></a>vue指令</h1><p>这章介绍的是vue的一些指令，是以“v-”开头的指令，它的值预估是单个<br>JavaScript表达式(v-for例外)。指令的作用是在表达式的值改变的时候，<br>将产生的影响，响应的作用在DOM上。<a id="more"></a></p><h2 id="v-if、v-else和v-else-if"><a href="#v-if、v-else和v-else-if" class="headerlink" title="v-if、v-else和v-else-if"></a>v-if、v-else和v-else-if</h2><p>使用场景：我们需要进行条件判断来决定这个元素是否显示的时候，就需要用到这些指令。</p><p>有v-else指令的元素必须跟在带有v-if或者v-else-if的元素后面，否则将不会被识别</p><p>使用方法：</p><pre><code>&lt;div id=&quot;app&quot;&gt;    &lt;div v-if=&quot;param&quot;&gt;        登陆成功       &lt;!--param的值为true的时候--&gt;    &lt;/div&gt;    &lt;div v-else&gt;        请登录    &lt;!--param的值为false的时候--&gt;    &lt;/div&gt;&lt;/div&gt;var vue = new Vue({    el: &quot;#app&quot;,    data: {        param: true    }});</code></pre><p>v-else-if 是在2.1.0版本新增的一个指令。学过c,c++,java语言的都应该可以理解，也就是否则如果，可以连续使用，该指令也是只能跟在v-if后面。</p><p>使用方法：</p><pre><code>&lt;div id=&quot;app&quot;&gt;    &lt;div v-if=&quot;param===0&quot;&gt;         &lt;!--param的值为0的时候--&gt;    &lt;/div&gt;    &lt;div v-else-if=&quot;param===1&quot;&gt;         &lt;!--param的值为1的时候--&gt;    &lt;/div&gt;    &lt;div v-else-if=&quot;param===2&quot;&gt;         &lt;!--param的值为2的时候--&gt;    &lt;/div&gt;    &lt;div v-else&gt;         &lt;!--param的值是非1，非2，非0的时候--&gt;    &lt;/div&gt;&lt;/div&gt;var vue = new Vue({    el: &quot;#app&quot;,    data: {        param: 0    }});</code></pre><h2 id="v-show和v-once"><a href="#v-show和v-once" class="headerlink" title="v-show和v-once"></a>v-show和v-once</h2><p>v-show指令也是用于条件展示的，用法和v-if一样，只不过没有v-else指令在后面。</p><p>不同的是带有v-show的元素是一开始就会被渲染并保留在DOM中，它是决定的是css属性display来显示或者不显示元素。而v-if是条件渲染，为真才渲染，若为假是不会渲染出相应的元素的，也就是为假的时候DOM上是找不到该元素的。</p><p>v-once顾名思义，一次性的插值。</p><p>此时渲染结果为 Hello!,若是后期我们把message的值改为Hello,world！,元素p里的内容还是Hello!，不会随着data里的message的改变而改变</p><h2 id="v-text和v-html"><a href="#v-text和v-html" class="headerlink" title="v-text和v-html"></a>v-text和v-html</h2><p>v-text的作用等价于两个双括号,用两个双括号不好的地方是当网速很慢或者js报错的时候，会直接显示两个双括号，但是使用v-text就不会，所以在实际开发的时候，建议使用v-text。</p><pre><code>&lt;div id=&quot;app&quot;&gt;    &lt;p&gt;{{message}}&lt;/p&gt; == &lt;p v-text=&quot;message&quot;&gt;&lt;/p&gt;&lt;/div&gt;var vue = new Vue({    el: &quot;#app&quot;,    data: {        message: &quot;Hello!&quot;    }});</code></pre><p>v-html: 会将元素当成html标签解析然后输出。</p><pre><code>&lt;div id=&quot;app&quot;&gt;    &lt;p v-text=&quot;message&quot;&gt;&lt;/p&gt;    &lt;p v-html=&quot;message&quot;&gt;&lt;/p&gt;&lt;/div&gt;var vue = new Vue({    el: &quot;#app&quot;,    data: {        message: &quot;&lt;h1&gt;hello&lt;/h1&gt;&quot;    }});</code></pre><p>输出结果为：</p><p><img src="/2018/07/16/vue指令/v-html.png" alt=""></p><p>注意： 在站点上动态的渲染任意的HTML可能会很危险，因为它很容易导致XSS攻击，所以最好慎用。</p><h2 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h2><p>v-bind一般用来绑定元素属性，属性值可以是字符串，对象或数组。可以用来绑定class、style或者是图片，链接的地址属性src、href等。v-bind可以简写成“:”。</p><pre><code>&lt;style&gt;.fd-head {    color: red;}.fd-nav {    background-color: yellow;}.active {    font-size: 20px;}.text-danger {    color: red;    border: 1px solid &apos;#000&apos;;}&lt;/style&gt;&lt;div id=&quot;app&quot;&gt;    &lt;h1&gt;1. 绑定到src和href属性上&lt;/h1&gt;        &lt;img v-bind:src=&quot;imgSrc&quot;&gt;        &lt;a :href=&quot;url&quot;&gt;github传送门&lt;/a&gt;    &lt;h1&gt;2. 绑定到样式&lt;/h1&gt;        &lt;div :class=&quot;{&apos;fd-head&apos;:isOk, &apos;active&apos;:isActive}&quot;&gt;            &lt;p&gt;(1)一般绑定方法&lt;/p&gt;            字体为红色        &lt;/div&gt;        &lt;div class=&quot;fd-nav&quot; :class=&quot;{&apos;fd-head&apos;:isOk, &apos;active&apos;:isActive}&quot;&gt;            &lt;p&gt;(2)v-bind:class也可以与普通的class属性共存&lt;/p&gt;            字体为红色且背景颜色为黄色        &lt;/div&gt;        &lt;div :class=&quot;isTrue?fd-head:active&quot;&gt;            &lt;p&gt;用三元运算符来选择样式,字体大小为20px&lt;/p&gt;        &lt;/div&gt;        &lt;div :class=&quot;[activeClass,errorClass]&quot;&gt;            绑定到数组        &lt;/div&gt;    &lt;h1&gt;3. 绑定内联样式style&lt;/h1&gt;        &lt;h2&gt;对象语法&lt;/h2&gt;        &lt;div :style=&quot;{color:activeColor,fontSize:fontSize + &apos;px&apos;,&apos;background-color&apos;:bgcolor}&quot;&gt;            (1)我们给:style赋值的是一个对象，该对象语法看上去有点像css，但其实是一个JavaScript对象，css的属性名可以用驼峰式，这样就需要用括号括起来，或者用短横线分隔，这样就需要用括号括起来。        &lt;/div&gt;        &lt;div :style=&quot;styleObj1&quot;&gt;            &lt;p&gt;(2)或者我们直接绑定到一个样式对象，这样比较简单明了。        &lt;/div&gt;        &lt;h2&gt;数组语法&lt;/h2&gt;        &lt;div :style=&quot;[styleObj1,styleObj2,styleObj3]&quot;&gt;            &lt;p&gt;数组语法可以将多个样式对象应用到同一个元素上。        &lt;/div&gt;&lt;/div&gt;var vue = new Vue({    el: &quot;#app&quot;,    data: {        imgSrc: &quot;http://2b.zol-img.com.cn/product/131/741/ceUvYp3mRk5w.jpg&quot;,        url: &quot;https://github.com/zzilcc&quot;,        isOk: true,        isActive: false,        isTrue: false,        activeClass: &apos;active&apos;,        errorClass: &apos;text-danger&apos;,        activeColor: &apos;red&apos;,        &apos;fd-head&apos;: &apos;fd-head&apos;,        active: &apos;active&apos;,        fontSize: 30,        bgcolor: &apos;blue&apos;,        styleObj1: {            color: &apos;red&apos;,            fontSize: &apos;13px&apos;        },        styleObj2: {            position: &apos;relative&apos;        },        styleObj3: {            backgroundColor: &apos;blue&apos;        }    }})</code></pre><p>结果为：<br><img src="/2018/07/16/vue指令/v-bind1.png" alt=""></p><p><img src="/2018/07/16/vue指令/v-bind2.png" alt=""></p><h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><p>v-model指令主要用来在表单<code>&lt;input&gt;</code>及<code>&lt;textarea&gt;</code>元素上进行双向数据绑定。v-model会忽略所有表单元素的value,checked,selected特性的初始值，而总是将Vue实例的数据当做数据来源。</p><h3 id="文本绑定"><a href="#文本绑定" class="headerlink" title="文本绑定"></a>文本绑定</h3><pre><code>&lt;div id=&quot;app&quot;&gt;    &lt;input v-model=&quot;message&quot; placeholder=&quot;请输入&quot;&gt;    &lt;p&gt; Message is : &lt;span v-text=&quot;message&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;var vue = new Vue({    el: &quot;#app&quot;,    data: {        message: &quot;&quot;    }})</code></pre><p><img src="/2018/07/16/vue指令/v-model1.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;vue指令&quot;&gt;&lt;a href=&quot;#vue指令&quot; class=&quot;headerlink&quot; title=&quot;vue指令&quot;&gt;&lt;/a&gt;vue指令&lt;/h1&gt;&lt;p&gt;这章介绍的是vue的一些指令，是以“v-”开头的指令，它的值预估是单个&lt;br&gt;JavaScript表达式(v-for例外)。指令的作用是在表达式的值改变的时候，&lt;br&gt;将产生的影响，响应的作用在DOM上。&lt;/p&gt;
    
    </summary>
    
      <category term="vue" scheme="http://yoursite.com/categories/vue/"/>
    
    
      <category term="Vue.js" scheme="http://yoursite.com/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>vue基础</title>
    <link href="http://yoursite.com/2018/07/16/vue%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/07/16/vue基础/</id>
    <published>2018-07-16T03:28:25.000Z</published>
    <updated>2018-08-23T03:28:40.822Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue-js是什么"><a href="#Vue-js是什么" class="headerlink" title="Vue.js是什么"></a>Vue.js是什么</h2><p>Vue是一个前端框架，官方的解释是一套用于构建用户界面的渐进式框架。相对于React,AngularJS框架来说是比较轻量级的，然后比较容易上手，所以一开始选择学哪个框架的时候就选择了Vue,正好入职的第一家公司也是使用这个框架。<br><a id="more"></a></p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>Vue有两个版本，一个开发版本，包含完整的警告和调试模式；一个是生产版本，删除了警告，进行了压缩。</p><p>GitHub地址传送门：<a href="https://github.com/vuejs/vue" target="_blank" rel="noopener">github</a></p><h2 id="Vue实例"><a href="#Vue实例" class="headerlink" title="Vue实例"></a>Vue实例</h2><p>我们一般通过Vue函数创建一个新的Vue实例。</p><pre><code>var vue = new Vue({    //选项});</code></pre><h2 id="声明式渲染"><a href="#声明式渲染" class="headerlink" title="声明式渲染"></a>声明式渲染</h2><p>Vue是声明式渲染，这是Vue的核心，我看过比较好的解释就是“我们只需要告诉程序我们想要什么效果，其他交给程序去做”。</p><p>官网的例子就很好理解：</p><pre><code>&lt;div id=&quot;app&quot;&gt;    {{message}} //Hi&lt;/div&gt;var vue = new Vue ({    el: &quot;#app&quot;,    data: {        message: &apos;Hi!&apos;    }}) </code></pre><p>  通过这样我们已经把数据渲染进DOM，而且是响应式的。主要data里的message值发生变化，在页面上也会跟着变化。</p><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><p>当创建一个实例后，我们可以传入一个选项对象，下面列出一些常用选项：</p><ul><li>el</li><li>data</li><li>methods</li><li>computed</li></ul><h3 id="el"><a href="#el" class="headerlink" title="el"></a>el</h3><p> 选择挂载目标，可以是css选择器，也可以是html元素，在实例挂载后，元素可以通过vue.$el访问。</p><p> 如果是在实例化时存在这个选项，实例将立即进入编译过程，否则需要显式调用vue.$mount()手动开始编译。</p><h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><p> Vue实例的数据对象。Vue是响应式的数据变化的，因为Vue会递归的将data的属性转换为getter/setter。data对象必须是纯粹的对象，也就是含有零个或多个的键值对。</p><p> 实例创建后，可以通过vue.$data访问，并且Vue实例，也就是vue实际上也代理了data对象上的不是以“_”或者“$”开头的属性。也就是vue.$data.a等价于 vue.a.</p><pre><code>&lt;div id=&quot;app&quot;&gt;    {{message}}  //Hello,world&lt;/div&gt;var vue = new Vue({    el: &quot;#app&quot;,    data: {        message: &quot;Hello world!&quot;    }});vue.$data.message === vue.message //true</code></pre><h3 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h3><p> 用来定义一些方法，用这些方法是实现你想要的一些功能，比如点击事件，或者发送ajax请求等等。这些方法可以通过实例来访问，或者在指令表达式中使用，方法中的this会自动绑定为Vue实例。</p><pre><code>&lt;div id=&quot;app&quot;&gt;     {{message}}  //Hello     &lt;button v-on:click=&quot;show&quot;&gt;展示完整信息&lt;/button&gt;//点击按钮后会出现Hello,world!&lt;/div&gt;var vue = new Vue({    el: &quot;#app&quot;,    data: {        message: &quot;Hello&quot;    },    methods: {        show: function() {            return message = + &quot;,world!&quot;        }    }})</code></pre><p> 在这个例子我们使用v-on命令，用来监听事件，这个命令下节会解释。我们在button标签里绑定了点击事件，所以一点击的时候，就会触发了show函数，该函数就会执行，所以message的值为“Hello,world！”。</p><h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><p> 计算属性，它是基于依赖进行缓存的，只有相关的依赖的值发生了改变，才会重新执行函数，否则只会返回之前的结果。</p><p> 类型：{[key: string]: Function|{get: Function,set: Function}}</p><pre><code>var vue = new Vue({    el: &quot;#app&quot;,    data: {        a: 1    },    computed: {        add: function() {             return this.a + 1        }    }})</code></pre><p> or</p><pre><code>var vue = new Vue({    el: &quot;#app&quot;,    data: {        a: 1    },    computed: {        add: {            get: function() {                return this.a + 1            },            set: function(data) {                this.a = data -1            }        }    }})</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Vue-js是什么&quot;&gt;&lt;a href=&quot;#Vue-js是什么&quot; class=&quot;headerlink&quot; title=&quot;Vue.js是什么&quot;&gt;&lt;/a&gt;Vue.js是什么&lt;/h2&gt;&lt;p&gt;Vue是一个前端框架，官方的解释是一套用于构建用户界面的渐进式框架。相对于React,AngularJS框架来说是比较轻量级的，然后比较容易上手，所以一开始选择学哪个框架的时候就选择了Vue,正好入职的第一家公司也是使用这个框架。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="vue" scheme="http://yoursite.com/categories/vue/"/>
    
    
      <category term="Vue.js" scheme="http://yoursite.com/tags/Vue-js/"/>
    
  </entry>
  
</feed>
