<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>黄紫茜的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-12-03T14:14:10.601Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>黄紫茜</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《剑指offer》面试题3 数组中重复的数字</title>
    <link href="http://yoursite.com/2020/12/03/%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%983-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2020/12/03/《剑指offer》面试题3-数组中重复的数字/</id>
    <published>2020-12-03T13:42:48.000Z</published>
    <updated>2020-12-03T14:14:10.601Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《剑指offer》面试题3-数组中重复的数字"><a href="#《剑指offer》面试题3-数组中重复的数字" class="headerlink" title="《剑指offer》面试题3 数组中重复的数字"></a>《剑指offer》面试题3 数组中重复的数字</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>找出数组中重复的数字。</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p>示例 1：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">2 &lt;&#x3D; n &lt;&#x3D; 100000</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）</p><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><h3 id="方法一-双层循环对比"><a href="#方法一-双层循环对比" class="headerlink" title="方法一  双层循环对比"></a>方法一  双层循环对比</h3><p>a:  [2, 3, 1, 0, 2, 5, 3]</p><p>b:  [2, 3, 1, 0, 2, 5, 3]</p><p>拿第一层循环数组的i依次对比第二层循环的数组的i+1元素。</p><p>a 取2，然后分别遍历[3,1,0,2,5,3], 如果有重复的，就return，没有的话就i+1，依次类推。</p><p>代码如下</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var findRepeatNumber &#x3D; function(nums) &#123;</span><br><span class="line">  let len &#x3D; nums.length;</span><br><span class="line">  for (let i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">  for (let j &#x3D; i+1; j &lt; len; j++) &#123;</span><br><span class="line">  if (nums[i] &#x3D;&#x3D;&#x3D; nums[j])&#123;</span><br><span class="line">  return nums[i]</span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为有两层遍历，所以时间复杂度是O(n^2)</p><h3 id="方法二-一层循环-哈希表"><a href="#方法二-一层循环-哈希表" class="headerlink" title="方法二 一层循环 + 哈希表"></a>方法二 一层循环 + 哈希表</h3><ol><li>首先定义一个Map</li><li>然后遍历数组，判断Map里没有这个值，没有的话set一下，有的话说明这个值已经重复了，所以可以直接输出</li></ol><p>代码如下</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var findRepeatNumber &#x3D; function(nums) &#123;</span><br><span class="line">    let map &#x3D; new Map()</span><br><span class="line">    let len &#x3D; nums.length</span><br><span class="line">    for (let i &#x3D;0; i&lt;len;i++) &#123;</span><br><span class="line">        if (map.has(nums[i]))&#123;</span><br><span class="line">            return nums[i];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            map.set(nums[i], 1)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为只有一层遍历，所以时间复杂度是O(n)</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从时间复杂度上看，当然是建议使用方法二。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《剑指offer》面试题3-数组中重复的数字&quot;&gt;&lt;a href=&quot;#《剑指offer》面试题3-数组中重复的数字&quot; class=&quot;headerlink&quot; title=&quot;《剑指offer》面试题3 数组中重复的数字&quot;&gt;&lt;/a&gt;《剑指offer》面试题3 数组中重复的
      
    
    </summary>
    
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>js Number类型的最大安全值为什么是1-2^53至2^53-1</title>
    <link href="http://yoursite.com/2020/08/27/js-Number%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%89%E5%85%A8%E5%80%BC%E8%8C%83%E5%9B%B4%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF1-2%5E53%E8%87%B32%5E53-1/"/>
    <id>http://yoursite.com/2020/08/27/js-Number类型的安全值范围为什么是1-2^53至2^53-1/</id>
    <published>2020-08-27T07:32:14.000Z</published>
    <updated>2020-09-01T07:08:09.266Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近才发现自己一直混淆了Number.Max_Value和Number.MAX_SAFE_INTEGER，然后经过一段的研究和学习，终于搞懂了。耐心看完这一篇你会了解到IEEE 754标准的浮点数的表示，了解到JS Number对象的最大（小）值，最大（小）安全值都是怎么来的；NAN，正负无穷大，正0，负0在计算机中都是怎么存储的；还有为什么0.1+0.2==0.3 为什么是false</p><h2 id="为什么是1-2-53至2-53-1"><a href="#为什么是1-2-53至2-53-1" class="headerlink" title="为什么是1-2^53至2^53-1"></a>为什么是1-2^53至2^53-1</h2><h3 id="双精度浮点数-（IEEE-754）"><a href="#双精度浮点数-（IEEE-754）" class="headerlink" title="双精度浮点数 （IEEE 754）"></a>双精度浮点数 （IEEE 754）</h3><p>JavaScript的Number类型为双精度IEEE 754 64位浮点类型。我们来看下图</p><p><img src="js-Number%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%89%E5%85%A8%E5%80%BC%E8%8C%83%E5%9B%B4%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF1-2%5E53%E8%87%B32%5E53-1/%E5%8F%8C%E7%B2%BE%E5%BA%A6%E6%A0%BC%E5%BC%8F.png" alt=""></p><p>IEEE 754 双精度的格式：<code>(-1)^s*1.M*2^(E-127)</code></p><h4 id="符号位"><a href="#符号位" class="headerlink" title="符号位"></a>符号位</h4><p>1 代表负，0代表正</p><h4 id="指数位"><a href="#指数位" class="headerlink" title="指数位"></a>指数位</h4><p>指数位是IEEE 754的阶码，是用移码表示，移码和补码只有符号位是相反的，所以补码的符号位1代表正数，0代表负数 </p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近才发现自己一直混淆了Number.Max_Value和Number.MAX_SAFE_INTEGER，然后经过一段的研究和学习，终于搞懂
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="javaScript Number IEEE754" scheme="http://yoursite.com/tags/javaScript-Number-IEEE754/"/>
    
  </entry>
  
  <entry>
    <title>diff算法详解</title>
    <link href="http://yoursite.com/2020/08/13/diff%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/08/13/diff算法详解/</id>
    <published>2020-08-13T15:15:02.000Z</published>
    <updated>2020-08-13T15:15:02.531Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>LeetCode 120题 三角形最小路径和解题过程</title>
    <link href="http://yoursite.com/2020/07/30/LeetCode-120%E9%A2%98-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C%E8%A7%A3%E9%A2%98%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/07/30/LeetCode-120题-三角形最小路径和解题过程/</id>
    <published>2020-07-30T14:39:17.000Z</published>
    <updated>2020-07-30T15:48:42.824Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近一两个月每天下班去健身房锻炼1到2个小时，回到家比较晚，又累（借口），所以就没有刷力扣了。</p><p>最近感觉，不行了，还是要继续刷题，不能太颓废。所以又开始刷题之旅。</p><p>之前一想到动态规划，什么状态方程，状态转移，看到就很头疼，现在开始攻克他。</p><p>这道题我还没有出生的时候就已经出现，是比我还老的一道经典题，用它来理解动态规划是比较好的。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p><p>相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。</p><p>例如，给定三角形：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">     [2],</span><br><span class="line">    [3,4],</span><br><span class="line">   [6,5,7],</span><br><span class="line">  [4,1,8,3]</span><br><span class="line">]</span><br><span class="line">&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 &#x3D; 11）。</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。</span><br><span class="line"></span><br><span class="line">## 解题思路及代码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">其实我们可以把这个想象成一道数学题。</span><br><span class="line"></span><br><span class="line">写数学题第一步是什么，写假设，假设x是什么，y是什么，然后找出x,y之间的关系。</span><br><span class="line"></span><br><span class="line">这道题也是这样的。</span><br><span class="line"></span><br><span class="line">### 动态规划</span><br><span class="line"></span><br><span class="line">首先我们要知道它是要找到自顶向下的最小路径和，所以我们需要用一个数组去存储从顶到每个坐标的最小路径和，这样，我们算到最后一行的时候，只需要到比较最后一行到时候到最小值。</span><br><span class="line"></span><br><span class="line">所以dp[i][j]代表着从顶到该坐标（i，j）的最小路径和，假设行数是row，列数是col，所以我们最后只需要找到第row行中最小的dp[row - 1 ][j]（0 &lt;&#x3D; j &lt; col）</span><br><span class="line"></span><br><span class="line">然后移动的时候是有条件的，每一步只能移动到下一行中相邻的结点上。</span><br><span class="line"></span><br><span class="line">所以我们可以得到常规情况下:</span><br></pre></td></tr></table></figure><p>dp[i][j] = Math.min(dp[i - 1][j], dp[i - 1][ j - 1]) + triangle[i][j]</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">然后我们考虑边界情况，左边界的话，也就是j&#x3D;&#x3D;&#x3D;0的时候：</span><br></pre></td></tr></table></figure><p>dp[i][j] = dp[i - 1][j]+ triangle[i][j] </p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">右边界，也就是 i&#x3D;&#x3D;&#x3D;j的时候</span><br></pre></td></tr></table></figure><p>dp[i][j] = dp[i - 1][j - 1]+ triangle[i][j] </p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">所以我们很容易得到如下代码</span><br></pre></td></tr></table></figure><p>/**</p><ul><li>@param {number[][]} triangle</li><li>@return {number}</li><li>/<br>var minimumTotal = function(triangle) {<br>  let row = triangle.length<br>  if(row === 0) return 0<br>  let col = triangle[row - 1].length<br>  let dp = Array.from({length: row}, x =&gt; Array.from({length: col}))<br>  dp[0][0] = triangle[0][0]<br>  for (let i = 1; i &lt; row; i++) {<pre><code>for (let j = 0; j &lt;= i; j++) {    if (j === 0) {        dp[i][j] = dp[i - 1][j]+ triangle[i][j]     }else if (i === j) {        dp[i][j] = dp[i - 1][j - 1]+ triangle[i][j]     }else {        dp[i][j] = Math.min(dp[i - 1][j], dp[i - 1][ j - 1]) + triangle[i][j]    }}</code></pre>  }<br>  let min = Math.min(…dp[row - 1])<br>  return min<br>};<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 优化1 - 时间</span><br><span class="line"></span><br><span class="line">首先我们知道最后返回的是一个最小路径和，我们从顶到下去计算的话，最后要去判断一下最后一行中的最短路径的最小值，那么我们反过来呢，逆向思维，我们从底部开始往上走，最后我们走到顶的时候只有一个值了，那个值就是我们要找的最小值,这样就不需要去判断边界条件了。</span><br><span class="line"></span><br><span class="line">所以我们可以把遍历的稍稍改动一下：</span><br></pre></td></tr></table></figure>/**</li><li>@param {number[][]} triangle</li><li>@return {number}</li><li>/<br>var minimumTotal = function(triangle) {<br>  let row = triangle.length<br>  if(row === 0) return 0<br>  let col = triangle[row - 1].length<br>  let dp = Array.from({length: row}, x =&gt; Array.from({length: col}).fill(0))<br>  for (let k = 0; k &lt; col; k++) {<pre><code>dp[row - 1][k] = triangle[row - 1][k]</code></pre>  }<br>  for (let i = row - 2; i &gt;= 0; i–) {<pre><code>for (let j = 0; j &lt;= i; j++) {    dp[i][j] = Math.min(dp[i + 1][j], dp[i + 1][ j + 1]) + triangle[i][j]}</code></pre>  }<br>  return dp[0][0]<br>};<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 优化2 - 空间</span><br><span class="line"></span><br><span class="line">我们前面的方法都是用的二维数组存储每个坐标上的最小路径和，比如我们计算第二行的最小路径和的时候，第四行的数据我们已经用不上了，因为第三行的数据把第四行的数据加上了，所以其实我们只需要维护一个长度为col的数组，每次计算后将上次的值覆盖就可以了，</span><br></pre></td></tr></table></figure>/**</li><li>@param {number[][]} triangle</li><li>@return {number}</li><li>/<br>var minimumTotal = function(triangle) {<br>let row = triangle.length<br>if (row === 0) return 0<br>let dp = new Array(row +1).fill(0)<br>for (let i = row - 1; i &gt;=0; i–) {<br>  for (let j = 0; j &lt;= i; j++) {<pre><code>dp[j] = Math.min(dp[j], dp[j+1]) + triangle[i][j]</code></pre>  }<br>}<br>return dp[0]<br>};<br>```</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近一两个月每天下班去健身房锻炼1到2个小时，回到家比较晚，又累（借口），所以就没有刷力扣了。&lt;/p&gt;
&lt;p&gt;最近感觉，不行了，还是要继续刷
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 面试题53 - I. 在排序数组中查找数字 I</title>
    <link href="http://yoursite.com/2020/04/21/LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9853-I-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97-I/"/>
    <id>http://yoursite.com/2020/04/21/LeetCode-面试题53-I-在排序数组中查找数字-I/</id>
    <published>2020-04-21T14:53:24.000Z</published>
    <updated>2020-07-30T14:29:54.475Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面试题53-I-在排序数组中查找数字-I"><a href="#面试题53-I-在排序数组中查找数字-I" class="headerlink" title="面试题53 - I. 在排序数组中查找数字 I"></a>面试题53 - I. 在排序数组中查找数字 I</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>统计一个数字在排序数组中出现的次数。</p><p>示例 1:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p>限制：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;&#x3D; 数组长度 &lt;&#x3D; 50000</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路解析"><a href="#思路解析" class="headerlink" title="思路解析"></a>思路解析</h2><h3 id="暴力循环法"><a href="#暴力循环法" class="headerlink" title="暴力循环法"></a>暴力循环法</h3><p>题目看上去是很简单，就是找到一个目标数字在数组中出现的次数，不管数组是有序还是无序的，我们都可以用的一种方法就是暴力循环法</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>定义一个count来记录目标值出现的次数，初始值为0，然后遍历这个数组，然后如果当前值和目标值target一致，那么count就加一，最后return count。这种解法的时间复杂度是O(N)</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; target</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> search = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i === target) &#123;</span><br><span class="line">    count++</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="改良的暴力循环"><a href="#改良的暴力循环" class="headerlink" title="改良的暴力循环"></a>改良的暴力循环</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>因为数组已排序了，所以我们其实可以不用遍历全部，用双指针分别从头部和尾部开始同时遍历，然后找到目标值的左右边界的位置，然后通过计算得到count。其实就是比全部遍历少了目标值出现的次数，它的算法复杂度还是O(n)</p><pre><code>count = 右边界的index - 左边界的index + 1</code></pre><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; target</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> search = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> [left,  right] = [<span class="number">0</span>, nums.length - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right &amp;&amp; (nums[left] !== target || nums[right] !== target)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left === right &amp;&amp; nums[left] !== target) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[left] !== target) &#123;</span><br><span class="line">    left++;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[right] !== target)&#123;</span><br><span class="line">    right--;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right - left + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>除了遍历，我们在排序数组中查找值还可以用的一种方法是二分法，思路还是和改良的暴力循环法一样，先找到左右边界，然后做计算。时间复杂度为O(logn)</p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; target</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> search = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> end =  nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 查找右边界</span></span><br><span class="line">    <span class="keyword">while</span>(start &lt;= end) &#123;</span><br><span class="line">        mid = <span class="built_in">Math</span>.ceil((start + end) / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">            start = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            end = mid <span class="number">-1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    right = start - <span class="number">1</span>; <span class="comment">// 右边界</span></span><br><span class="line">  <span class="comment">// 查找左边界</span></span><br><span class="line">    start = <span class="number">0</span>;</span><br><span class="line">    mid = <span class="number">0</span>; </span><br><span class="line">    end =  nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(start &lt;= end) &#123;</span><br><span class="line">        mid = <span class="built_in">Math</span>.ceil((start + end) / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            start = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            end = mid <span class="number">-1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    left = end + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> right - left + <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;面试题53-I-在排序数组中查找数字-I&quot;&gt;&lt;a href=&quot;#面试题53-I-在排序数组中查找数字-I&quot; class=&quot;headerlink&quot; title=&quot;面试题53 - I. 在排序数组中查找数字 I&quot;&gt;&lt;/a&gt;面试题53 - I. 在排序数组中查找数字 I&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;统计一个数字在排序数组中出现的次数。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;figure class=&quot;hljs highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: nums &amp;#x3D; [5,7,7,8,8,10], target &amp;#x3D; 8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;示例 2:&lt;/p&gt;
&lt;figure class=&quot;hljs highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: nums &amp;#x3D; [5,7,7,8,8,10], target &amp;#x3D; 6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;


&lt;p&gt;限制：&lt;/p&gt;
&lt;figure class=&quot;hljs highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;0 &amp;lt;&amp;#x3D; 数组长度 &amp;lt;&amp;#x3D; 50000&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="哈希" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>算法题-找出数组中只出现一次的数字</title>
    <link href="http://yoursite.com/2020/03/29/%E7%AE%97%E6%B3%95%E9%A2%98-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2020/03/29/算法题-找出数组中只出现一次的数字/</id>
    <published>2020-03-29T02:52:18.000Z</published>
    <updated>2020-07-30T14:29:54.642Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法题-找出数组中只出现一次的数字"><a href="#算法题-找出数组中只出现一次的数字" class="headerlink" title="算法题-找出数组中只出现一次的数字"></a>算法题-找出数组中只出现一次的数字</h2><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p>示例 1:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line">输入: [4,1,2,1,2]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;算法题-找出数组中只出现一次的数字&quot;&gt;&lt;a href=&quot;#算法题-找出数组中只出现一次的数字&quot; class=&quot;headerlink&quot; title=&quot;算法题-找出数组中只出现一次的数字&quot;&gt;&lt;/a&gt;算法题-找出数组中只出现一次的数字&lt;/h2&gt;&lt;p&gt;给定一个非空整数数组
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Jest在vue+ts项目中的使用</title>
    <link href="http://yoursite.com/2019/12/22/Jest%E5%9C%A8vue+ts%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/12/22/Jest在vue+ts项目中的使用/</id>
    <published>2019-12-22T13:01:20.000Z</published>
    <updated>2020-07-30T14:29:54.455Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇主要分享了怎么在vue+ts项目中搭建Jest环境，这一篇主要是分享Jest联合vue官方出的单元测试库vue-test-utils一起在项目的使用</p><h1 id="Jest"><a href="#Jest" class="headerlink" title="Jest"></a>Jest</h1><h2 id="匹配器"><a href="#匹配器" class="headerlink" title="匹配器"></a>匹配器</h2><p>基本的测试我们通过expect(value)去实现，比如我们有一个函数sum, 它的返回值是20，然后我们要校验它的返回值是不是20，就可以这么写测试</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test(&#39;test function sum&#39;, () &#x3D; &gt; &#123;</span><br><span class="line">    expect(sum()).toBe(20)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>toBe函数就是一个匹配，校验expect的参数的结果是不是和toBe的参数一致，如果一致，验证通过，否则验证不通过。</p><p>除了toBe，还有很多匹配器，可以去官网看下 <a href="https://jestjs.io/docs/zh-Hans/using-matchers" target="_blank" rel="noopener">API</a></p><p>toBe是使用<code>Object.is()</code>,如果需要测试精确的相等，需要用toEqual</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test(&#39;object assignment&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  const data &#x3D; &#123;one: 1&#125;;</span><br><span class="line">  data[&#39;two&#39;] &#x3D; 2;</span><br><span class="line">  expect(data).toEqual(&#123;one: 1, two: 2&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>下面图中显示了我们常用的一些匹配器</p><p><img src="Jest%E5%9C%A8vue+ts%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/%E5%8C%B9%E9%85%8D%E5%99%A8.png" alt=""></p><p>所有匹配器都可以用<code>.not</code>取反</p><h2 id="异步测试"><a href="#异步测试" class="headerlink" title="异步测试"></a>异步测试</h2><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><h2 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h2><h3 id="beforeEach"><a href="#beforeEach" class="headerlink" title="beforeEach"></a>beforeEach</h3><h3 id="beforeAll"><a href="#beforeAll" class="headerlink" title="beforeAll"></a>beforeAll</h3><h3 id="afterEach"><a href="#afterEach" class="headerlink" title="afterEach"></a>afterEach</h3><h3 id="afterAll"><a href="#afterAll" class="headerlink" title="afterAll"></a>afterAll</h3><h2 id="分组–describe"><a href="#分组–describe" class="headerlink" title="分组–describe"></a>分组–describe</h2><p>作用域</p><h2 id="Mock"><a href="#Mock" class="headerlink" title="Mock"></a>Mock</h2><h1 id="Vue-Test-Utils"><a href="#Vue-Test-Utils" class="headerlink" title="Vue Test Utils"></a>Vue Test Utils</h1><p>Vue Test Utils  是vue官方的test工具</p><h2 id="引入Vue-Test-Utils"><a href="#引入Vue-Test-Utils" class="headerlink" title="引入Vue Test Utils"></a>引入Vue Test Utils</h2><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mount, shallowMount, createLocalVue &#125; from &#39;@vue&#x2F;test-utils&#39;</span><br></pre></td></tr></table></figure><p>可以在测试文件的顶部通过上面的代码引入Vue Test Utils </p><h2 id="Wrapper"><a href="#Wrapper" class="headerlink" title="Wrapper"></a>Wrapper</h2><p>Vue Test Utils 是一个基于包裹器的 API。</p><p>一个 Wrapper 是一个包裹器，它包括了一个挂载组件或 vnode，以及测试该组件或 vnode 的方法。</p><h3 id="Wrapper-属性"><a href="#Wrapper-属性" class="headerlink" title="Wrapper 属性"></a>Wrapper 属性</h3><p><img src="Jest%E5%9C%A8vue+ts%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/%E5%B1%9E%E6%80%A7.png" alt=""></p><h3 id="Wrapper-方法"><a href="#Wrapper-方法" class="headerlink" title="Wrapper 方法"></a>Wrapper 方法</h3><p><img src="Jest%E5%9C%A8vue+ts%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/%E6%96%B9%E6%B3%95.png" alt=""></p><h2 id="api"><a href="#api" class="headerlink" title="api"></a>api</h2><p><img src="Jest%E5%9C%A8vue+ts%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/api.png" alt=""></p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>测试查询的表单的输入框的初始值是不是都是空</li><li>测试添加按钮是不是正常</li><li>测试table请求是不是返回正常（或者下拉框的请求是不是正常）</li><li>测试操作列是不是正常</li><li>测试事件点击时候的操作正常不正常</li><li>dialog的表单的初始值是不是正常</li><li>dialog的按钮点击事件是不是正常</li><li>？ 下拉框的事件</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上一篇主要分享了怎么在vue+ts项目中搭建Jest环境，这一篇主要是分享Jest联合vue官方出的单元测试库vue-test-utils一
      
    
    </summary>
    
    
      <category term="单元测试" scheme="http://yoursite.com/categories/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="Jest" scheme="http://yoursite.com/tags/Jest/"/>
    
  </entry>
  
  <entry>
    <title>Jest在vue-cli3中的应用</title>
    <link href="http://yoursite.com/2019/12/13/Jest%E5%9C%A8vue+ts%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2019/12/13/Jest在vue+ts项目中的环境搭建/</id>
    <published>2019-12-13T06:43:17.000Z</published>
    <updated>2020-07-30T14:29:54.473Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是单元测试"><a href="#什么是单元测试" class="headerlink" title="什么是单元测试"></a>什么是单元测试</h1><p>先上个图<br><img src="Jest%E5%9C%A8vue+ts%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/%E6%B5%8B%E8%AF%95%E6%A6%82%E5%9B%BE.png" alt=""></p><p>这个图我们很熟悉，这个在大学某软件课程里会看到这个，这是一个简易的软件的生命周期。</p><p>可以看到我们单元测试对应的是编码。单元测试是对我们软件中的最小可测试单元进行检查和验证，比如一个函数，一个模块。单元测试一般来说是开发人员去执行，剩下的集成测试，系统测试等由专业的测试人员来进行。</p><p>单元测试不需要访问数据库</p><p>单元测试不需要访问网络</p><p>单元测试不需要访问文件系统</p><a id="more"></a><h1 id="为什么要使用单元测试"><a href="#为什么要使用单元测试" class="headerlink" title="为什么要使用单元测试"></a>为什么要使用单元测试</h1><ol><li>可以验证代码的正确性，在上线前心里有底</li><li>一次编写，多次运行，就不需要我们在代码里console打印</li><li>便于重构，有测试用例在，我们方便知道重构后的代码是否正确</li></ol><h1 id="怎么使用单元测试-–Jest"><a href="#怎么使用单元测试-–Jest" class="headerlink" title="怎么使用单元测试 –Jest"></a>怎么使用单元测试 –Jest</h1><h2 id="Jest是什么"><a href="#Jest是什么" class="headerlink" title="Jest是什么"></a>Jest是什么</h2><blockquote><p>Jest是一个JavaScript测试框架，旨在确保任意JavaScript代码的正确性。 它允许你用可访问的、熟悉的和功能丰富的 API 来写测试，让你快速获得结果。<br>Jest文档齐全，仅需很少的配置，可以扩展到符合你的要求。<br>Jest使测试变得愉快。                —Jest 核心团队</p></blockquote><h2 id="引入jest"><a href="#引入jest" class="headerlink" title="引入jest"></a>引入jest</h2><p>引入方式分为两种，一种是创建项目时引入，一种是创建时没有引入，后期引入。</p><h3 id="初始化时引入"><a href="#初始化时引入" class="headerlink" title="初始化时引入"></a>初始化时引入</h3><p>用git bash执行<code>vue create demo</code>时发现交互提示符不工作，</p><p><img src="Jest%E5%9C%A8vue+ts%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/%E6%B2%A1%E6%9C%89%E4%BA%A4%E4%BA%92.jpg" alt=""></p><p>搜了一下，发现要通过<code>winpty vue.cmd create demo</code>去运行，<br>然后不想每次都写那么长的命令的话，可以在Git/etc下的bash.bashrc文件的最后一行加入如下代码</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias vue&#x3D;&#39;winpty vue.cmd&#39;</span><br></pre></td></tr></table></figure><p>这样就能可以用<code>vue create</code></p><p><img src="Jest%E5%9C%A8vue+ts%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/%E6%9C%89%E4%BA%A4%E4%BA%92.jpg" alt=""></p><p>单元测试中选中Jest即可</p><h3 id="后期引入"><a href="#后期引入" class="headerlink" title="后期引入"></a>后期引入</h3><p>昨天下午大佬说你现在好像没有什么事情了，我把Jest加入到了项目，你自己看看，看懂了做个分享。</p><p>所以没有接触过单元测试的我开始了 <del>走向掉更多头发</del> 走向光明的道路。</p><p>我们主要是介绍后期引入这种方法，<del>愚蠢</del>机智的我通过上面的方法创建了一个新项目，然后去package.json，看用到了哪些包，然后下载下来,主要用到下面这几个</p><h4 id="jest-amp-amp-ts-jest-amp-amp-types-jest"><a href="#jest-amp-amp-ts-jest-amp-amp-types-jest" class="headerlink" title="jest &amp;&amp; ts-jest &amp;&amp; @types/jest"></a>jest &amp;&amp; ts-jest &amp;&amp; @types/jest</h4><p>首先我们在项目的根目录在终端打开，输入</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -D jest ts-jest @types&#x2F;jest</span><br></pre></td></tr></table></figure><h4 id="vue-cli-plugin-babel"><a href="#vue-cli-plugin-babel" class="headerlink" title="@vue/cli-plugin-babel"></a>@vue/cli-plugin-babel</h4><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue add @vue&#x2F;cli-plugin-babel</span><br></pre></td></tr></table></figure><h4 id="vue-cli-plugin-unit-jest"><a href="#vue-cli-plugin-unit-jest" class="headerlink" title="@vue/cli-plugin-unit-jest"></a>@vue/cli-plugin-unit-jest</h4><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue add @vue&#x2F;cli-plugin-unit-jest</span><br></pre></td></tr></table></figure><p>运行后会发现，package.json会多了如下三行</p><p><img src="Jest%E5%9C%A8vue+ts%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/package.png" alt=""></p><p>Vue Test Utils 是 Vue.js 官方的单元测试实用工具库。</p><p>可以看到我们scripts多了一个命令<code>test:unit</code>,我们可以改写成”test”: “jest”，不改也没有什么问题</p><p>我们安装这个@vue/cli-plugin-unit-jest依赖的时候，会在根目录下生成一个test文件夹，和一个jest配置文件jest.config.js</p><p><img src="Jest%E5%9C%A8vue+ts%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/%E7%9B%AE%E5%BD%95.png" alt=""></p><p>Jest识别三种测试文件，以.test.j/ts结尾的文件，以.spec.j/ts结尾的文件，和放到<strong>tests</strong> 文件夹中的文件</p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p><strong>怎么具体使用在Jest将在下篇文章中详细介绍</strong></p><p>想要了解更多知识，可以关注我的公众号</p><p><img src="Jest%E5%9C%A8vue+ts%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/WechatIMG68.jpeg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是单元测试&quot;&gt;&lt;a href=&quot;#什么是单元测试&quot; class=&quot;headerlink&quot; title=&quot;什么是单元测试&quot;&gt;&lt;/a&gt;什么是单元测试&lt;/h1&gt;&lt;p&gt;先上个图&lt;br&gt;&lt;img src=&quot;Jest%E5%9C%A8vue+ts%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/%E6%B5%8B%E8%AF%95%E6%A6%82%E5%9B%BE.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个图我们很熟悉，这个在大学某软件课程里会看到这个，这是一个简易的软件的生命周期。&lt;/p&gt;
&lt;p&gt;可以看到我们单元测试对应的是编码。单元测试是对我们软件中的最小可测试单元进行检查和验证，比如一个函数，一个模块。单元测试一般来说是开发人员去执行，剩下的集成测试，系统测试等由专业的测试人员来进行。&lt;/p&gt;
&lt;p&gt;单元测试不需要访问数据库&lt;/p&gt;
&lt;p&gt;单元测试不需要访问网络&lt;/p&gt;
&lt;p&gt;单元测试不需要访问文件系统&lt;/p&gt;
    
    </summary>
    
    
      <category term="单元测试" scheme="http://yoursite.com/categories/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="Vue Jest" scheme="http://yoursite.com/tags/Vue-Jest/"/>
    
  </entry>
  
  <entry>
    <title>攻克JavaScript异步编程</title>
    <link href="http://yoursite.com/2019/08/25/%E6%94%BB%E5%85%8BJavaScript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/08/25/攻克JavaScript异步编程/</id>
    <published>2019-08-25T06:47:19.000Z</published>
    <updated>2020-07-30T14:29:54.627Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>揭秘输入地址到显示页面背后发生的故事</title>
    <link href="http://yoursite.com/2019/08/12/%E6%8F%AD%E7%A7%98%E8%BE%93%E5%85%A5%E5%9C%B0%E5%9D%80%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E8%83%8C%E5%90%8E%E5%8F%91%E7%94%9F%E7%9A%84%E6%95%85%E4%BA%8B/"/>
    <id>http://yoursite.com/2019/08/12/揭秘输入地址到显示页面背后发生的故事/</id>
    <published>2019-08-12T06:48:43.000Z</published>
    <updated>2020-07-30T14:29:54.619Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>工作了一年多，发现自己其实学习路线是存在问题的，刚开始学习前端就是直接学习着三个基础HTML，CSS,JavaScript，然后就学习框架vue，然后vue脚手架，vuex，路由，webpack这些。</p><p>从来没有考虑过本质，比如浏览器的运行，渲染机制，浏览器怎么和服务器通行等等。所有的认知都只是停留在表面。</p><p>所以意识到自己的短板后，开始深入学习。</p><a id="more"></a><h2 id="浏览器组成"><a href="#浏览器组成" class="headerlink" title="浏览器组成"></a>浏览器组成</h2><p>首先我们要知道浏览器的组成。我们知道不同浏览器具体实现是有不同的，但是它们设计思想是一样的，所以可以将浏览器抽象成下面的图。</p><p><img src="%E6%8F%AD%E7%A7%98%E8%BE%93%E5%85%A5%E5%9C%B0%E5%9D%80%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E8%83%8C%E5%90%8E%E5%8F%91%E7%94%9F%E7%9A%84%E6%95%85%E4%BA%8B/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BB%84%E6%88%90.jpg" alt=""></p><p><img src="%E6%8F%AD%E7%A7%98%E8%BE%93%E5%85%A5%E5%9C%B0%E5%9D%80%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E8%83%8C%E5%90%8E%E5%8F%91%E7%94%9F%E7%9A%84%E6%95%85%E4%BA%8B/%E6%9E%B6%E6%9E%84table.png" alt=""></p><h2 id="浏览器历史"><a href="#浏览器历史" class="headerlink" title="浏览器历史"></a>浏览器历史</h2><p>在2007年前大多数浏览器都是单进程的，也就是所有功能都运行在一个进程中。那时候浏览器需要借助插件去实现web视频，web游戏，但是插件是很不稳定的，常常会崩溃，由于是单进程，所以其中一个模块崩溃会导致整个浏览器崩溃。所以后面出现了多进程浏览器，不同功能模块运行在不同的进程，相互之间独立。</p><h3 id="单进程浏览器"><a href="#单进程浏览器" class="headerlink" title="单进程浏览器"></a>单进程浏览器</h3><p>单进程浏览器有如下的缺点：</p><ol><li>不稳定</li><li>不流畅</li><li>不安全</li></ol><p>插件和渲染引擎模块在当时具有不稳定性，因而导致浏览器不稳定。不流畅是因为所有模块都要在一个进程运行，也就是每个模块是等待上一个模块运行结束后才能运行，所以页面肯定是不流畅的，加载时间慢。不安全是如果在插件中有病毒，那么就会导致整个浏览器崩溃掉。</p><h3 id="多进程浏览器"><a href="#多进程浏览器" class="headerlink" title="多进程浏览器"></a>多进程浏览器</h3><p>现在市面上大多数的浏览器都是多进程的。以谷歌为例，我们开始打开一个页签，这里我打开了谷歌搜索。我们可以看到一开始就有5个进程。</p><p><img src="%E6%8F%AD%E7%A7%98%E8%BE%93%E5%85%A5%E5%9C%B0%E5%9D%80%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E8%83%8C%E5%90%8E%E5%8F%91%E7%94%9F%E7%9A%84%E6%95%85%E4%BA%8B/%E8%BF%9B%E7%A8%8B.png" alt=""></p><p>进程我们可以分为：浏览器主进程，GPU进程，网络进程，渲染进程，插件进程。</p><p>图中第一个显示‘浏览器’指的就是浏览器主进程。主要负责掌控全场，包括浏览器的界面的显示，用户交互（前进，后退等等）、负责各个页面的管理，子进程的创建与销毁等、存储功能等。</p><p>GPU进程一开始是为了3D绘制，但是后面谷歌浏览的ui界面都用GPU渲染，所以GPU单独成为了一个进程。</p><p>网络进程（Network Service）是最近才单独成为一个进程，之前是运行在主进程，主要负责网络资源的加载。</p><p>渲染进程：主要任务是将html，css，js转换成用户可以交互的页面，默认情况下一个页签会生成一个进程。</p><p>插件进程：之前说过，插件是不稳定的，所以要把插件单独作为一个进程。</p><h3 id="面向服务架构"><a href="#面向服务架构" class="headerlink" title="面向服务架构"></a>面向服务架构</h3><p>多进程模型虽然解决了单进程的许多问题，但是也带来了一些问题，比如内存占用变高了，因为每一个进程都有公共基础模块的副本，还有体系结构变复杂了，模块之间耦合性高，扩展性差。现在谷歌团队根据‘面向服务的架构（SOA）’思想设计了一个新的架构。原来的模块都独立成一个个服务，服务可以在进程中运行。但是这个架构过渡是需要一定的时间。</p><h2 id="再也不怕别人问我输入url后发生了什么"><a href="#再也不怕别人问我输入url后发生了什么" class="headerlink" title="再也不怕别人问我输入url后发生了什么"></a>再也不怕别人问我输入url后发生了什么</h2><p>首先上个总体图</p><p><img src="%E6%8F%AD%E7%A7%98%E8%BE%93%E5%85%A5%E5%9C%B0%E5%9D%80%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E8%83%8C%E5%90%8E%E5%8F%91%E7%94%9F%E7%9A%84%E6%95%85%E4%BA%8B/%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.jpg" alt=""></p><p>我们之前说过现代浏览器主要是多进程浏览器，然后实现一个页面的展示依靠多个进程之间相互协作。主要有浏览器主进程，网络进程，渲染进程。</p><p>输入url后到页面展示主要可以分为两个流程：导航流程和渲染流程。</p><p>导航流程页分为用户输入过程、url请求过程、提交文档过程。</p><h3 id="导航流程"><a href="#导航流程" class="headerlink" title="导航流程"></a>导航流程</h3><h4 id="用户输入过程"><a href="#用户输入过程" class="headerlink" title="用户输入过程"></a>用户输入过程</h4><p>我们在地址栏输入一个地址url，然后回车，这时候浏览器主进程会判断是输入的是地址还是搜索关键字，如果是地址的话，那么进入url请求过程，如果是关键字搜索的话，那么就会根据浏览器默认的搜索引擎生成新的url，然后将生成的url通过进程间通信IPC传递给网络进程。</p><h4 id="url请求过程"><a href="#url请求过程" class="headerlink" title="url请求过程"></a>url请求过程</h4><h5 id="查看缓存"><a href="#查看缓存" class="headerlink" title="查看缓存"></a>查看缓存</h5><p>拿到URL后第一个会检查有没有缓存，如果有缓存那么就读取缓存，如果没有缓存，则进行下一步。</p><h5 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h5><p>识别url，抽取出域名，然后进行DNS解析。</p><p>DNS为Domain Name System的简写。意为域名系统。为什么要解析域名？这是因为在互联网中我们要访问其他服务器是通过ip地址进行通信，但是ip地址不利于人们记忆，所以人们通过域名去记忆，比如cn.bing.com、<a href="http://www.google.com。所以我们需要将域名解析成ip地址，然后发起请求。" target="_blank" rel="noopener">www.google.com。所以我们需要将域名解析成ip地址，然后发起请求。</a></p><p>找了许多文章来看，各有说各的，我也不懂怎么去验证谁是对的，所以在这里就不细说DNS解析过程了。</p><p>假装拿到了ip地址。</p><h5 id="发起http请求"><a href="#发起http请求" class="headerlink" title="发起http请求"></a>发起http请求</h5><h5 id="生成http请求报文"><a href="#生成http请求报文" class="headerlink" title="生成http请求报文"></a>生成http请求报文</h5><p>详情可以移步<a href="https://zzilcc.github.io/2019/06/16/浏览器缓存详解/" target="_blank" rel="noopener">浏览器缓存详解</a> 里面有关于http请求报文的详细介绍。</p><h6 id="建立TCP连接（三次握手）"><a href="#建立TCP连接（三次握手）" class="headerlink" title="建立TCP连接（三次握手）"></a>建立TCP连接（三次握手）</h6><p>我们首先来看下TCP/IP协议栈</p><p><img src="%E6%8F%AD%E7%A7%98%E8%BE%93%E5%85%A5%E5%9C%B0%E5%9D%80%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E8%83%8C%E5%90%8E%E5%8F%91%E7%94%9F%E7%9A%84%E6%95%85%E4%BA%8B/TCP.jpg" alt=""></p><blockquote><p>TCP （传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，然后TCP把数据流分区成适当长度的报文段（通常受该计算机连接的网络的数据链路层的最大传输单元（MTU）的限制）。之后TCP把结果包传给IP层，由它来通过网络将包传送给接收端实体的TCP层。TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。 –百度百科</p></blockquote><p>我们知道TCP可以给我们提供可靠的数据传递，在协议栈途中我们可以看到TCP报文的首部，与建立TCP连接相关的几个字段为序号（seq），确认号（ack），六个标志中的ACK，SYN这共四个字段。</p><pre><code>1. 序号（seq）：报文的序号，建立连接的话序号是随机生成的。2. 确认序号（ack）：只有六个标志位中的ACK为1的时候，确认序号才有效，ack=seq+13. ACK：决定确认序号ack是否有效4. SYN：发起一个新连接</code></pre><p>TCP的可靠性就是靠序号和确认序号去实现。</p><p><img src="%E6%8F%AD%E7%A7%98%E8%BE%93%E5%85%A5%E5%9C%B0%E5%9D%80%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E8%83%8C%E5%90%8E%E5%8F%91%E7%94%9F%E7%9A%84%E6%95%85%E4%BA%8B/%E5%BB%BA%E7%AB%8BTCP%E8%BF%9E%E6%8E%A5.jpg" alt=""></p><p>建立TCP连接的过程如下：</p><ol><li>客户端发送SYN=1，seq=x的报文给服务端，表示要创建一个新连接，报文的序号为x</li><li>服务端接收到后会返回SYN=1，ACK=1，表示已经接收到发起连接到请求，seq=k，ack=x+1，而且期待下次接收到是x+1序号到报文，然后服务器的报文的序号是k</li><li>看上去现在一来一回，感觉上就应该可以建立连接了，但是为什么还有第三次握手，这是为了很久以前的客户端的报文莫名的到了服务端，而且此时客户端已经不需要建立连接了，但是如果只有两次握手就建立的连接的话，那么此时服务器就会确定建立连接，并且等待客户端传输数据，那么就造成了服务端资源的浪费。所以需要进行第三次握手，也就是客户端返回一个ACK=1，ack=k+1表示已经知道服务端收到刚刚发送的连接发起请求报文</li></ol><h6 id="传递数据"><a href="#传递数据" class="headerlink" title="传递数据"></a>传递数据</h6><p>建立好TCP连接后可以开始向服务器传递数据了。</p><h6 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h6><p>数据传递结束后，我们要关闭连接，也就是要进行四次挥手。</p><p>除了之前接触到的字段外，四次挥手相关的一个字段为FIN，意为要关闭连接。</p><p><img src="%E6%8F%AD%E7%A7%98%E8%BE%93%E5%85%A5%E5%9C%B0%E5%9D%80%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E8%83%8C%E5%90%8E%E5%8F%91%E7%94%9F%E7%9A%84%E6%95%85%E4%BA%8B/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.jpg" alt=""></p><ol><li>首先客户端数据传递完成发起关闭连接请求,FIN=1,seq=x,x等于上一个客户端接收的报文的序号+1</li><li>然后服务端接收到后返回报文ACK=1，seq=k，ack=x+1，告诉客户端序号为x的包我已经接收到了，期待下次接收到x+1序号的包，然后服务端本次的序号是k</li><li>然后服务端可能这时候还有传递一些数据给客户端，客户端虽然发起了关闭连接请求，但是还是可以接收报文，然后服务端此时的序号假设是w，此时服务端数据发送完毕后，发起关闭连接请求，所以FIN=1，然后期待接收到x+1序号到报文（ACK=1，ack=x+1）。</li><li>客户端接收到服务端的关闭连接请求，则告诉服务端我接收到了你的请求ACK=1，然后序号为x+1。</li></ol><p>此时客户端和服务端都关闭了连接。</p><h5 id="服务器响应"><a href="#服务器响应" class="headerlink" title="服务器响应"></a>服务器响应</h5><p>http响应报文详情可以移步<a href="https://zzilcc.github.io/2019/06/16/浏览器缓存详解/" target="_blank" rel="noopener">浏览器缓存详解</a> 里面有关于http响应报文的详细介绍。</p><p>服务器响应和请求差不多，也是进行三次握手，传递数据，然后四次挥手。</p><h4 id="提交文档过程"><a href="#提交文档过程" class="headerlink" title="提交文档过程"></a>提交文档过程</h4><p>网络进程获取到响应数据后会告诉浏览器主进程，主进程会发起提起文档请求给渲染进程，告诉渲染进程可以准备了，渲染进程接收到主进程传递过来的文档信息后，会和网络进程建立一个数据传输通道，网络进程会将响应数据传递给渲染进程，数据传递结束后，渲染进程会告诉浏览器主进程，主进程则开始更新页面。</p><p>所以我们在一个旧页面的地址栏输入一个新地址回车后，旧页面会保持一段时间才会更新为新页面，就是因为在执行这个导航过程。</p><p>到此导航过程结束，下面开始详细介绍渲染过程。</p><h3 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h3><p>渲染流程主要是在渲染进程中去执行，渲染进程中又分了几个线程去实现不同的功能。主要有以下几个线程。</p><h4 id="GUI渲染线程"><a href="#GUI渲染线程" class="headerlink" title="GUI渲染线程"></a>GUI渲染线程</h4><ol><li>负责渲染浏览器界面，包括解析HTML、CSS、构建DOM树、Render树、布局与绘制等</li><li>当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行</li></ol><h4 id="JavaScript引擎线程"><a href="#JavaScript引擎线程" class="headerlink" title="JavaScript引擎线程"></a>JavaScript引擎线程</h4><ol><li>主要负责处理Javascript脚本程序</li><li>等待任务队列的任务的到来，然后加以处理，</li></ol><h4 id="定时触发线程"><a href="#定时触发线程" class="headerlink" title="定时触发线程"></a>定时触发线程</h4><p>setTimeout和setInteval，主要负责浏览器定时和计数。</p><h4 id="事件触发线程"><a href="#事件触发线程" class="headerlink" title="事件触发线程"></a>事件触发线程</h4><p>当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理</p><h4 id="异步请求线程"><a href="#异步请求线程" class="headerlink" title="异步请求线程"></a>异步请求线程</h4><p>使用XMLHttpRequest (XHR)对象可以与服务器交互，XHR发起连接后，浏览器主线程会新开一个异步请求线程，检测到状态变更时，如果设置有回调函数，那么将产生状态变更事件放到任务队列里等待js引擎去处理</p><h4 id="渲染过程详解"><a href="#渲染过程详解" class="headerlink" title="渲染过程详解"></a>渲染过程详解</h4><ol><li>构建 DOM 树。</li><li>构建 CSSOM 树。</li><li>将 DOM 与 CSSOM 合并成一个渲染树。</li><li>根据渲染树来布局，以计算每个节点的几何信息。</li><li>将各个节点绘制到屏幕上。</li></ol><h5 id="构建DOM树"><a href="#构建DOM树" class="headerlink" title="构建DOM树"></a>构建DOM树</h5><p>服务器返回给浏览器的html数据不是我们看到<code>&lt;html&gt;</code>,<code>&lt;body&gt;</code>等，而是一些字节数据，我们需要将这个些字节数据一步步转换成DOM树，转换过程如下：</p><p>Bytes–&gt;Characters–&gt;Tokens–&gt;Nodes–&gt;DOM</p><ol><li>获取到响应数据到字节</li><li>开始解析这些字节，根据文件的指定编码（例如 UTF-8）将它们转换成字符串</li><li>字符串转换成Token，也就是<code>&lt;html&gt;</code>,<code>&lt;body&gt;</code>等，Token中会标识出当前Token是“开始标签”或是“结束标签”亦或是“文本”等信息</li><li>解析token生成节点对象，不是等到所有token都生成后才去生成节点对象，而是生成一个token，就马上生成一个节点对象，带有结束标签标识的Token不会创建节点对象</li><li>遍历节点，构建DOM树</li></ol><p>解析HTML的时候读到引入外部css或js文件，渲染进程会将请求发送到网络进程，由网络进程去下载对应的css文件或js文件。不同的是，如果是js文件，这会阻断HTML的解析，js下载完成后会在js引擎线程立即执行，此时GUI渲染线程会被挂起。如果是css文件的话，不会阻断HTML的解析。</p><p>一个简单的例子</p><p><img src="%E6%8F%AD%E7%A7%98%E8%BE%93%E5%85%A5%E5%9C%B0%E5%9D%80%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E8%83%8C%E5%90%8E%E5%8F%91%E7%94%9F%E7%9A%84%E6%95%85%E4%BA%8B/DOM%E6%A0%91.jpg" alt=""></p><h5 id="构建CSSOM树"><a href="#构建CSSOM树" class="headerlink" title="构建CSSOM树"></a>构建CSSOM树</h5><p>构建CSSOM树其实和构建DOM很类似。css文件被下载后会开始进行CSSOM构建。</p><p>Bytes–&gt;Characters–&gt;Tokens–&gt;Nodes–&gt;CSSOM</p><p>上面说过构建CSSOM不会阻塞HTML解析，但是如果在js中操作了CSSOM，那么需要等到响应css文件下载并构建CSSOM后，js才会继续执行，在这期间HTML解析会一直被挂起，所以我们在HTML文件引入css，js文件的顺序很重要，css优先，放在头部引入，js滞后，放在页面底部。</p><p>解析HTML的时候，遍历节点时将节点插入到DOM树上，同时去查找css，然后把对应的样式规则应用到元素及节点上，查找样式表是按照从右到左的顺序去匹配的。</p><p>比如： div p {color: #333;}，会先寻找所有p标签并判断它的父标签是否为div之后才会决定要不要采用这个样式进行渲染。</p><p>所以，我们平时写CSS时，尽量用id和class，千万不要过渡层叠。</p><p>一个简单的例子</p><p><img src="%E6%8F%AD%E7%A7%98%E8%BE%93%E5%85%A5%E5%9C%B0%E5%9D%80%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E8%83%8C%E5%90%8E%E5%8F%91%E7%94%9F%E7%9A%84%E6%95%85%E4%BA%8B/CSSOM%E6%A0%91.jpg" alt=""></p><h5 id="将DOM树和CSSOM树合成渲染树"><a href="#将DOM树和CSSOM树合成渲染树" class="headerlink" title="将DOM树和CSSOM树合成渲染树"></a>将DOM树和CSSOM树合成渲染树</h5><p>浏览器会先从DOM树的根节点开始遍历每个可见节点。可见节点就是display不为none的元素，对每个可见节点，找到其CSS样式规则并应用。</p><p>渲染树和DOM树最大的区别是DOM包括了所有节点，渲染树只包括了可视节点。</p><p>一个简单的例子</p><p><img src="%E6%8F%AD%E7%A7%98%E8%BE%93%E5%85%A5%E5%9C%B0%E5%9D%80%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E8%83%8C%E5%90%8E%E5%8F%91%E7%94%9F%E7%9A%84%E6%95%85%E4%BA%8B/%E6%B8%B2%E6%9F%93%E6%A0%91.jpg" alt=""></p><h5 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h5><p>渲染树合成后并不包含元素的位置和大小信息，将其放在浏览器窗口的正确位置。计算这些值的过程称为布局或重排或则回流。比如我们在布局完成后对DOM进行了修改，那么需要重新计算这些值，这个过程就叫做回流或者重排。</p><h5 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h5><p>在绘制阶段，系统会遍历渲染树，将内容显示在屏幕上。同样绘制成功后再对dom进行操作的话，需要重新绘制，也叫做重绘。</p><p>重绘：屏幕的一部分重画，不影响整体布局，比如某个CSS的背景色变了，但元素的几何尺寸和位置不变。</p><p>回流： 意味着元件的几何尺寸变了，我们需要重新验证并计算渲染树。是渲染树的一部分或全部发生了变化。</p><p>一般情况下回流消耗比重绘大，但是不管是回流还是重绘，我们都应该尽量避免。</p><p>下面这些情况会引起回流</p><ol><li>DOM操作，增删查改</li><li>变更内容</li><li>激活伪类</li><li>访问或改变某些CSS属性（包括修改样式表或元素类名或使用JavaScript操作等方式）</li><li>浏览器窗口变化（滚动或尺寸变化）</li></ol><h6 id="如何减少重绘和回流"><a href="#如何减少重绘和回流" class="headerlink" title="如何减少重绘和回流"></a>如何减少重绘和回流</h6><ol><li>减少回流的影响范围，也就是我们元素的样式尽量不要通过父级元素去影响子元素，而是直接加在子元素上</li><li>少用style，多用class</li><li>减少DOM的层级</li><li>避免复杂的css选择器，这样可以减少匹配事件。</li><li>使用 transform 替代 top</li><li>使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局）</li><li>不要把节点的属性值放在一个循环里当成循环里的变量。</li></ol><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="html"><a href="#html" class="headerlink" title="html"></a>html</h3><pre><code>1. 降低dom复杂程度2. meta定义文档编码</code></pre><h3 id="css"><a href="#css" class="headerlink" title="css"></a>css</h3><pre><code>1. 压缩css文件2. 减少元素标签作为对后一个选择对象</code></pre><h3 id="js"><a href="#js" class="headerlink" title="js"></a>js</h3><pre><code>1. 减少用js去操作样式2. 减少定时器的实用，并且不用时要销毁3. 对高频的回调要进行节流和防抖4. 耗时长的代码放到Web Worker中运行</code></pre><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><pre><code>1. 懒加载图片2. 图片压缩处理</code></pre><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><pre><code>1. 减少请求资源大小或者次数　</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/" target="_blank" rel="noopener">https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/</a></li><li><a href="http://www.dailichun.com/2018/03/12/whenyouenteraurl.html" target="_blank" rel="noopener">http://www.dailichun.com/2018/03/12/whenyouenteraurl.html</a></li><li><a href="https://www.cnblogs.com/lanxiansen/p/10972802.html" target="_blank" rel="noopener">https://www.cnblogs.com/lanxiansen/p/10972802.html</a></li><li><a href="https://www.cnblogs.com/lhb25/p/how-browsers-work.html#Painting" target="_blank" rel="noopener">https://www.cnblogs.com/lhb25/p/how-browsers-work.html#Painting</a></li></ol><h2 id="赏"><a href="#赏" class="headerlink" title="赏"></a>赏</h2><p><img src="%E6%8F%AD%E7%A7%98%E8%BE%93%E5%85%A5%E5%9C%B0%E5%9D%80%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E8%83%8C%E5%90%8E%E5%8F%91%E7%94%9F%E7%9A%84%E6%95%85%E4%BA%8B/wxZf.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;工作了一年多，发现自己其实学习路线是存在问题的，刚开始学习前端就是直接学习着三个基础HTML，CSS,JavaScript，然后就学习框架vue，然后vue脚手架，vuex，路由，webpack这些。&lt;/p&gt;
&lt;p&gt;从来没有考虑过本质，比如浏览器的运行，渲染机制，浏览器怎么和服务器通行等等。所有的认知都只是停留在表面。&lt;/p&gt;
&lt;p&gt;所以意识到自己的短板后，开始深入学习。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端工程化" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
      <category term="http 浏览器" scheme="http://yoursite.com/tags/http-%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>算法题-有效的括号</title>
    <link href="http://yoursite.com/2019/08/06/%E7%AE%97%E6%B3%95%E9%A2%98-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <id>http://yoursite.com/2019/08/06/算法题-有效的括号/</id>
    <published>2019-08-06T12:49:28.000Z</published>
    <updated>2020-07-30T14:29:54.643Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>注意空字符串可被认为是有效字符串。</li></ol><a id="more"></a><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: &quot;()&quot;</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: &quot;(]&quot;</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">示例 4:</span><br><span class="line">输入: &quot;([)]&quot;</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">示例 5:</span><br><span class="line">输入: &quot;&#123;[]&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>第一种错误思路，开括号(‘{‘,’(‘,’[‘)和闭括号(‘}’,’)’,’]’)分别用两个堆栈去存储，然后再每个弹出来对比是不是一对。但是这样只是对((([[{}])))，()[]{},左右括号刚好分离的，如果是[{}()]这样的就识别不了,所以我们不能先把开括号和闭括号分别分离后再对比，而且两个堆栈空间消耗大，那么能不能用一个堆栈就解决。</p><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>然后就想到遍历字符串的时候，如果是开括号的话就推入栈，然后如果是闭括号的话，就把开括号栈的栈顶的字符推出来，看和闭括号是不是一对，怎么判断是不是一对，我们可以定一个map对象:</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = &#123;</span><br><span class="line"><span class="string">'&#123;'</span>: <span class="string">'&#125;'</span>,</span><br><span class="line"><span class="string">'['</span>: <span class="string">']'</span>,</span><br><span class="line"><span class="string">'('</span>: <span class="string">')'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后如果不是一对的话就返回false，如果是的话就继续遍历，直到遍历完了，如果开括号栈的长大于0，那么就返回false（因为开括号的数量大于闭括号的数量），否则返回true.</p><p>那么我们还要考虑到一个问题就是一开始就是闭括号，那么我们肯定返回false</p><p>还有如果是空串的话，我是直接返回的true。</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; s</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValid = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map = &#123;</span><br><span class="line">        <span class="string">'&#123;'</span>: <span class="string">'&#125;'</span>,</span><br><span class="line">        <span class="string">'['</span>: <span class="string">']'</span>,</span><br><span class="line">        <span class="string">'('</span>: <span class="string">')'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s === <span class="string">''</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> stack1 = [];</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] === <span class="string">'&#125;'</span> || s[<span class="number">0</span>] === <span class="string">']'</span> || s[<span class="number">0</span>] === <span class="string">')'</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> (s.length % <span class="number">2</span> !== <span class="number">0</span> ) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] !== <span class="string">'&#125;'</span> &amp;&amp; s[i] !== <span class="string">']'</span> &amp;&amp; s[i] !== <span class="string">')'</span> ) &#123;</span><br><span class="line">                stack1.push(s[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(map[stack1.pop()] !== s[i] ) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> !stack1.length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是一看感觉代码太多了，能不能再优化一下，把特殊情况不要单独放出来。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>第一个优化，空字符串的情况</p><p>我们其实不用判断是不是空串，因为他不会走for遍历，然后stack1.length就是0，所以会返回true.</p><p>第二个优化就是第一个字符是闭括号或则是闭括号和开括号数量不等情况其实都能在for循环里解决，因为遍历到闭括号时会去比对开括号栈，如果第一个就是闭括号的话，那么开括号栈推出的应该是undefined，肯定不等于闭括号，所以会返回false。</p><p>第三个优化，我判断一个字符是不是开括号是通过<code>if(s[i] !== &#39;}&#39; &amp;&amp; s[i] !== &#39;]&#39; &amp;&amp; s[i] !== &#39;)&#39;)</code>去实现，其实可以写为<code>if (s[i] in map)</code></p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; s</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValid = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map = &#123;</span><br><span class="line">        <span class="string">'&#123;'</span>: <span class="string">'&#125;'</span>,</span><br><span class="line">        <span class="string">'['</span>: <span class="string">']'</span>,</span><br><span class="line">        <span class="string">'('</span>: <span class="string">')'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> stack1 = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] <span class="keyword">in</span> map) &#123;</span><br><span class="line">            stack1.push(s[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(map[stack1.pop()] !== s[i] ) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !stack1.length</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。&lt;/p&gt;
&lt;p&gt;有效字符串需满足：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;左括号必须用相同类型的右括号闭合。&lt;/li&gt;
&lt;li&gt;左括号必须以正确的顺序闭合。&lt;/li&gt;
&lt;li&gt;注意空字符串可被认为是有效字符串。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="JavaScript 算法" scheme="http://yoursite.com/tags/JavaScript-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JS实现常用排序算法</title>
    <link href="http://yoursite.com/2019/08/04/JS%E5%AE%9E%E7%8E%B0%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/08/04/JS实现常用排序算法/</id>
    <published>2019-08-04T06:34:15.000Z</published>
    <updated>2020-07-30T14:29:54.445Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们生活中排序无处不在，比如考试结束后，老师需要对学生成绩由高到低进行排序，还有我们排名单时有时候也按照字典序排序等等，下面就介绍几种常用的排序算法及js实现。</p><a id="more"></a><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序，顾名思义，就是一个个向上冒泡。具体思想是比较两个相邻的项，如果第一个比第二个大，那么就交换它们。用两层for循环去实现，所以第一次循环后，最大的那个数到达了最右边，下一次循环第二大的数就紧挨着最大的数，以此类推。</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span> (<span class="params">arr, index1, index2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> temp = arr[index1];</span><br><span class="line">arr[index1] = arr[index2];</span><br><span class="line">arr[index2] =temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> len = arr.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">change(arr, j, j+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到冒泡排序的时间复杂度是O(n^2)。所以冒泡排序运行时间相对来说是比较久的。</p><p>比如数组是[2,4,1,6,9,7,5],第一轮循环后数组为[2,1,4,6,7,5,9],第二轮循环后数组为[1,2,4,6,5,7,9],我们知道第一轮循环后，最后一个数肯定是最大的。所以第二轮最后不应该去比较7和9。第三轮也是如此，不应该比较6，7，9。</p><p>所以我们可以改进一下冒泡排序，我们内循环的次数减去外循环中已跑过的轮数。</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> len = arr.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len<span class="number">-1</span>-i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">change(arr, j, j+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们生活中排序无处不在，比如考试结束后，老师需要对学生成绩由高到低进行排序，还有我们排名单时有时候也按照字典序排序等等，下面就介绍几种常用的排序算法及js实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法题-找出所有父节点</title>
    <link href="http://yoursite.com/2019/07/28/%E7%AE%97%E6%B3%95%E9%A2%98-%E6%89%BE%E5%87%BA%E6%89%80%E6%9C%89%E7%88%B6%E8%8A%82%E7%82%B9/"/>
    <id>http://yoursite.com/2019/07/28/算法题-找出所有父节点/</id>
    <published>2019-07-28T07:54:18.000Z</published>
    <updated>2020-07-30T14:29:54.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2><p>已知数据格式，实现一个函数 fn 找出链条中所有的父级id</p><a id="more"></a><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json = [</span><br><span class="line">&#123;</span><br><span class="line">id: <span class="string">'1'</span>,</span><br><span class="line">name: <span class="string">'广东省'</span>,</span><br><span class="line">children: [</span><br><span class="line">&#123;</span><br><span class="line">id: <span class="string">'11'</span>,</span><br><span class="line">name: <span class="string">'深圳市'</span>,</span><br><span class="line">children: [</span><br><span class="line">&#123;</span><br><span class="line">id: <span class="string">'111'</span>,</span><br><span class="line">name: <span class="string">'福田区'</span>,</span><br><span class="line">children: []</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">id: <span class="string">'112'</span>,</span><br><span class="line">name: <span class="string">'龙华区'</span>,</span><br><span class="line">children: []</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = <span class="string">'112'</span></span><br><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">fn(value) <span class="comment">// 输出 ['1'， '11'， '112']</span></span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="方法一-递归实现深度遍历，并添加path数组，记录父路径"><a href="#方法一-递归实现深度遍历，并添加path数组，记录父路径" class="headerlink" title="方法一 递归实现深度遍历，并添加path数组，记录父路径"></a>方法一 递归实现深度遍历，并添加path数组，记录父路径</h3><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="string">'112'</span>;</span><br><span class="line"><span class="keyword">var</span> fn = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">var</span> stack = json;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">var</span> node = stack.pop();<span class="keyword">debugger</span></span><br><span class="line"><span class="keyword">if</span>(node.children.length) &#123;</span><br><span class="line">stack.push(...node.children.map(<span class="function"><span class="params">x</span>=&gt;</span>(&#123;...x, <span class="attr">path</span>: (node.path || node.id) + <span class="string">'-'</span> + x.id&#125;)))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(node.id === value) &#123;</span><br><span class="line"><span class="keyword">return</span> node.path.split(<span class="string">'-'</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">while</span>(stack.length) </span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line">fn(value) <span class="comment">// 输出 [1， 11， 112]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;算法题&quot;&gt;&lt;a href=&quot;#算法题&quot; class=&quot;headerlink&quot; title=&quot;算法题&quot;&gt;&lt;/a&gt;算法题&lt;/h2&gt;&lt;p&gt;已知数据格式，实现一个函数 fn 找出链条中所有的父级id&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>20190727算法题-两数之和</title>
    <link href="http://yoursite.com/2019/07/27/20190727%E7%AE%97%E6%B3%95%E9%A2%98-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://yoursite.com/2019/07/27/20190727算法题-两数之和/</id>
    <published>2019-07-27T15:02:13.000Z</published>
    <updated>2020-07-30T14:29:54.443Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2><p>给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。</p><p>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。</p><p>示例：</p><p>给定 nums = [2, 7, 11, 15], target = 9</p><p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p><a id="more"></a><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一-双层for循环"><a href="#方法一-双层for循环" class="headerlink" title="方法一 双层for循环"></a>方法一 双层for循环</h3><p>我们用双层for循环，遍历每个元素el，找到是否有target-el的元素存在数组里，找到则输出索引。</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(nums[i] === target - nums[j] &amp;&amp; i!==j) &#123;</span><br><span class="line"><span class="keyword">return</span> [i, j]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的时间复杂度是 O(n^2)，空间复杂度为O(1)</p><p>很明显，这样的方法耗时太久，不好。</p><h3 id="方法二-利用对象查找"><a href="#方法二-利用对象查找" class="headerlink" title="方法二 利用对象查找"></a>方法二 利用对象查找</h3><p>因为在一个对象里找到是否有某个属性值，时间复杂度为O(1),所以我们可以第一次遍历数组，生成一个对象，然后第二次遍历，去找对象中是否有target-nums[i]的值，有的话返回。这样总的时间复杂度为O(n)，比第一种方法要好一些，只是需要一些内存去存储对象，空间复杂度为O(n),相当于拿空间换时间。</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">obj[nums[i]] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(obj[target - nums[i]] &amp;&amp; i == obj[target - nums[i]]) &#123;</span><br><span class="line"><span class="keyword">return</span> [i, obj[target - nums[i]]]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法三-优化第二种方法"><a href="#方法三-优化第二种方法" class="headerlink" title="方法三 优化第二种方法"></a>方法三 优化第二种方法</h3><p>上面我们执行了两次for循环，我们进行一下优化，在一次循环里解决。第一次循环将数组生成对象时就返回去检查对象里是否有符合target - nums[i]的属性值，有则返回。</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(obj[target - nums[i]] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> [obj[target - nums[i]], i]</span><br><span class="line">&#125;</span><br><span class="line">obj[nums[i]] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;算法题&quot;&gt;&lt;a href=&quot;#算法题&quot; class=&quot;headerlink&quot; title=&quot;算法题&quot;&gt;&lt;/a&gt;算法题&lt;/h2&gt;&lt;p&gt;给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。&lt;/p&gt;
&lt;p&gt;你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;给定 nums = [2, 7, 11, 15], target = 9&lt;/p&gt;
&lt;p&gt;因为 nums[0] + nums[1] = 2 + 7 = 9&lt;br&gt;所以返回 [0, 1]&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>20190727算法题-降维数组</title>
    <link href="http://yoursite.com/2019/07/27/20190727%E7%AE%97%E6%B3%95%E9%A2%98-%E9%99%8D%E7%BB%B4%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2019/07/27/20190727算法题-降维数组/</id>
    <published>2019-07-27T14:34:40.000Z</published>
    <updated>2020-07-30T14:29:54.444Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法题目："><a href="#算法题目：" class="headerlink" title="算法题目："></a>算法题目：</h2><p>已知如下数组：</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, [<span class="number">11</span>, <span class="number">12</span>, [<span class="number">12</span>, <span class="number">13</span>, [<span class="number">14</span>] ] ] ], <span class="number">10</span>];</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="要求1：-将多维数组降成一维数组"><a href="#要求1：-将多维数组降成一维数组" class="headerlink" title="要求1： 将多维数组降成一维数组"></a>要求1： 将多维数组降成一维数组</h3><h4 id="方法一：-es6的flat"><a href="#方法一：-es6的flat" class="headerlink" title="方法一： es6的flat()"></a>方法一： es6的flat()</h4><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.flat(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h4 id="方法二：-投机取巧"><a href="#方法二：-投机取巧" class="headerlink" title="方法二： 投机取巧"></a>方法二： 投机取巧</h4><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.toString().split(<span class="string">','</span>);</span><br></pre></td></tr></table></figure><p>或者</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.join().split(<span class="string">','</span>);</span><br></pre></td></tr></table></figure><h4 id="方法三：-递归"><a href="#方法三：-递归" class="headerlink" title="方法三： 递归"></a>方法三： 递归</h4><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flat</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> result = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_flat</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">value, index</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">_flat(value)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">result.push(value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">_flat(arr)</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">flat(arr)</span><br></pre></td></tr></table></figure><p>简写：</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> flat = <span class="function"><span class="params">arr</span> =&gt;</span> [].concat(...arr.map(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">Array</span>.isArray(v) ? flat(v) : v))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;算法题目：&quot;&gt;&lt;a href=&quot;#算法题目：&quot; class=&quot;headerlink&quot; title=&quot;算法题目：&quot;&gt;&lt;/a&gt;算法题目：&lt;/h2&gt;&lt;p&gt;已知如下数组：&lt;/p&gt;
&lt;figure class=&quot;hljs highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; arr = [[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;], [&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;], [&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;, [&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;, [&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;13&lt;/span&gt;, [&lt;span class=&quot;number&quot;&gt;14&lt;/span&gt;] ] ] ], &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript数据结构</title>
    <link href="http://yoursite.com/2019/07/27/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2019/07/27/JavaScript数据结构/</id>
    <published>2019-07-27T06:26:30.000Z</published>
    <updated>2020-07-30T14:29:54.449Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>想要做一个技术人，数据结构和算法都是必须的，在大学中，最让我头疼的也是这两门课，总觉得脑豁疼，毕业工作后一直想要找时间学习，但是奈何在前公司总是搬砖，做一些简单的工作，现离职后开始找工作，终于抽出时间开始学习数据结构和算法。数据结构和算法对我来说是难以翻越两座大山，但是做人要不断挑战自己，这一篇博客主要是记录一下学习数据结构的成果。</p><p>数据结构按可以分为逻辑结构和物理结构。把数据结构比作人的话，物理结构就是看得见，摸得着的人体，逻辑结构就是人的精神和思想。</p><p>物理结构分为顺序存储结构和链式存储结构。顺序存储结构有数组，链式存储结构有链表。</p><p>逻辑结构分为线性结构和非线性结构。线性结构主要有顺序表，栈，队列。非线性结构主要有树，图。</p><a id="more"></a><h2 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h2><h3 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h3><p>顺序存储结构顾名思义就是数据在内存中是顺序存储。</p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组是最简单的数据结构，它一般来说存储着有限个相同类型的变量，在js中，数组可以保存着不同类型的值，但是不推荐这么用。</p><p>我们知道，内存是由一个个连续的内存单元组成，数组中的每个元素都连续存储在内存中，而且是顺序存储。</p><h5 id="创建和初始化数组"><a href="#创建和初始化数组" class="headerlink" title="创建和初始化数组"></a>创建和初始化数组</h5><p>创建和初始化数组有三种方式，一种是通过构造函数，一种是字面量，最后一种是Array.of()。</p><p>第一种： </p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>) <span class="comment">// 创建一个空数组，数组长度为10</span></span><br><span class="line"><span class="keyword">let</span> arr1 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">'10'</span>) <span class="comment">// 创建了一个数组['10'],数组长度为1</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">'10'</span>,<span class="string">'11'</span>) <span class="comment">// 创建了一个数组['10,11'],长度为2</span></span><br></pre></td></tr></table></figure><p>我们可以看到通过构造函数创建数组时，如果向构造函数传递了一个Number类型的参数，那么会生成一个length为传进来的参数的大小，否则则生成一个包含参数的数组。</p><p>第二种：</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [] <span class="comment">// 创建一个空数组，数组长度为0</span></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="string">'10'</span>] <span class="comment">// 创建了一个数组['10'],数组长度为1</span></span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="string">'10,11'</span>] <span class="comment">// 创建了一个数组['10,11'],长度为2</span></span><br></pre></td></tr></table></figure><p>第二种方法是字面量方法，直接通过‘[]’创建数组。</p><p>第三种是新增的方法</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.of() <span class="comment">// 创建一个空数组，数组长度为0</span></span><br><span class="line"><span class="keyword">let</span> arr1 = <span class="built_in">Array</span>.of(<span class="string">'10'</span>) <span class="comment">// 创建了一个数组['10'],数组长度为1</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.of(<span class="string">'10'</span>,<span class="string">'11'</span>) <span class="comment">// 创建了一个数组['10,11'],长度为2</span></span><br></pre></td></tr></table></figure><h5 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h5><p>我们通过元素下标访问元素数组。数组第一个元素的下标为0，最后一个为length-1。</p><h5 id="添加和删除数组元素"><a href="#添加和删除数组元素" class="headerlink" title="添加和删除数组元素"></a>添加和删除数组元素</h5><h6 id="添加元素到数组首位–unshift"><a href="#添加元素到数组首位–unshift" class="headerlink" title="添加元素到数组首位–unshift()"></a>添加元素到数组首位–unshift()</h6><p>语法： arrayObject.unshift(item)</p><p>参数： item： 要插入到首位的元素</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr.unshift(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr)<span class="comment">// [0, 1, 2, 3]</span></span><br></pre></td></tr></table></figure><h6 id="删除数组首位元素–shift"><a href="#删除数组首位元素–shift" class="headerlink" title="删除数组首位元素–shift()"></a>删除数组首位元素–shift()</h6><p>语法： arrayObject.shift()</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr.shift()</span><br><span class="line"><span class="built_in">console</span>.log(arr)<span class="comment">// [2, 3]</span></span><br></pre></td></tr></table></figure><h6 id="添加元素到数组末尾–push"><a href="#添加元素到数组末尾–push" class="headerlink" title="添加元素到数组末尾–push()"></a>添加元素到数组末尾–push()</h6><p>语法： arrayObject.push(item)</p><p>参数： item： 要插入到末位的元素</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr.push(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr)<span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>####### 删除数组末尾元素–pop()</p><p>语法： arrayObject.pop()</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr.pop()</span><br><span class="line"><span class="built_in">console</span>.log(arr)<span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure><h6 id="添加-删除元素到数组任意位置–splice"><a href="#添加-删除元素到数组任意位置–splice" class="headerlink" title="添加/删除元素到数组任意位置–splice()"></a>添加/删除元素到数组任意位置–splice()</h6><p>语法： arrayObject.splice(index,howmany,item1,…..,itemX)</p><p>参数： </p><ol><li>index：必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。</li><li>howmany：必需。要删除的项目数量。如果设置为 0，则不会删除项目。</li><li>item1,…..,itemX：可选。向数组添加的新项目。</li></ol><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr)<span class="comment">// [1, 5, 5, 2, 3]</span></span><br></pre></td></tr></table></figure><h5 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h5><p>上面我们已经接触了5个方法了。下面将介绍一下数组的其他的方法。</p><h6 id="concat-连接数组"><a href="#concat-连接数组" class="headerlink" title="concat 连接数组"></a>concat 连接数组</h6><p>连接两个及以上的数组，并返回一个新数组，不会影响旧数组</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.concat(arr2);</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// [1, 2, 3, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><h6 id="every-返回值是boolean"><a href="#every-返回值是boolean" class="headerlink" title="every 返回值是boolean"></a>every 返回值是boolean</h6><p>对数组中的每个元素运行一个函数，如果每个元素运行该函数返回为true，则为true。</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.every(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, arrObj</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> item &gt; <span class="number">0</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>该函数接收三个参数，item是当前元素，index是该元素的下标，arrObj是执行every方法的数组。</p><h6 id="some-返回值是boolean"><a href="#some-返回值是boolean" class="headerlink" title="some 返回值是boolean"></a>some 返回值是boolean</h6><p>对数组中的每个元素运行一个函数，如果每个元素运行该函数有一个返回为true，则为true。</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.some(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, arrObj</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> item &gt; <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// true</span></span><br></pre></td></tr></table></figure><h6 id="map-返回新数组"><a href="#map-返回新数组" class="headerlink" title="map 返回新数组"></a>map 返回新数组</h6><p>对数组中的每个元素运行一个函数，每次调用该函数的结果组成新数组返回</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, arrObj</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> item * <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure><h6 id="filter-过滤元素，返回新数组"><a href="#filter-过滤元素，返回新数组" class="headerlink" title="filter 过滤元素，返回新数组"></a>filter 过滤元素，返回新数组</h6><p>对数组中的每个元素运行一个函数，每次调用该函数的返回值为true的元素组成新数组返回</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, arrObj</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> item &gt; <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// [3]</span></span><br></pre></td></tr></table></figure><h6 id="forEach-无返回值"><a href="#forEach-无返回值" class="headerlink" title="forEach 无返回值"></a>forEach 无返回值</h6><p>对数组中的每个元素运行一个函。</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">// 某些操作</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h6 id="slice-截取数组，返回新数组"><a href="#slice-截取数组，返回新数组" class="headerlink" title="slice 截取数组，返回新数组"></a>slice 截取数组，返回新数组</h6><p>传入索引值(start, end)，将数组里对应索引范围内(包含start，不包含end)的元素组成新数组返回</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.slice(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// [1]</span></span><br></pre></td></tr></table></figure><h6 id="sort-排序数组，影响arr数组"><a href="#sort-排序数组，影响arr数组" class="headerlink" title="sort 排序数组，影响arr数组"></a>sort 排序数组，影响arr数组</h6><p>按照字母顺序对数组排序，支持指定的排序函数当作参数</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.sort();</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// [1, 2, 2, 3, 3, 4]</span></span><br></pre></td></tr></table></figure><h6 id="reverse-颠倒数组，影响arr数组"><a href="#reverse-颠倒数组，影响arr数组" class="headerlink" title="reverse 颠倒数组，影响arr数组"></a>reverse 颠倒数组，影响arr数组</h6><p>颠倒数组，原先第一位元素变成最后一位，第二位变成倒数第二位，以此类推。</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.reverse();</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// [3, 2, 1]</span></span><br></pre></td></tr></table></figure><h6 id="indexOf-返回第一个与给定参数相等的元素的下标，没有返回-1"><a href="#indexOf-返回第一个与给定参数相等的元素的下标，没有返回-1" class="headerlink" title="indexOf 返回第一个与给定参数相等的元素的下标，没有返回-1"></a>indexOf 返回第一个与给定参数相等的元素的下标，没有返回-1</h6><p>从数组的第一个元素开始匹配，匹配成功则返回下标</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.indexOf(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h6 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf"></a>lastIndexOf</h6><p>从数组的最后一个元素开始匹配，匹配成功则返回下标，没有匹配成功返回-1</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.lastIndexOf(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h6 id="join-将所有元素拼接成字符串"><a href="#join-将所有元素拼接成字符串" class="headerlink" title="join 将所有元素拼接成字符串"></a>join 将所有元素拼接成字符串</h6><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.join();</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// "1,2,3"</span></span><br></pre></td></tr></table></figure><h6 id="toString-将所有元素拼接成字符串"><a href="#toString-将所有元素拼接成字符串" class="headerlink" title="toString 将所有元素拼接成字符串"></a>toString 将所有元素拼接成字符串</h6><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.toString();</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// "1,2,3"</span></span><br></pre></td></tr></table></figure><h6 id="reduce-累加"><a href="#reduce-累加" class="headerlink" title="reduce 累加"></a>reduce 累加</h6><p>reduce对元素的每一项运行一个函数，这个函数接收四个参数，preV前一个元素的值，curV当前元素值，index当前元素的下标，arrObj，执行reduce函数的数组。</p><p>reduce会返回数组每一项的累加值。</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">preV, curV, index, arrObj</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> preV + curV</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">//6  1+2+3=6</span></span><br></pre></td></tr></table></figure><h6 id="copyWithin-复制数组的某个范围的元素到同一个数组指定的起始位置"><a href="#copyWithin-复制数组的某个范围的元素到同一个数组指定的起始位置" class="headerlink" title="copyWithin 复制数组的某个范围的元素到同一个数组指定的起始位置"></a>copyWithin 复制数组的某个范围的元素到同一个数组指定的起始位置</h6><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.copyWithin(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// [1, 1, 3]</span></span><br></pre></td></tr></table></figure><p>copyWithin接收三个参数，第一个参数值指定元素放的起始位置，第二个，第三个参数分别是复制元素的起始位置和结束位置。</p><p>复制的元素包括开始位置的元素，不包括结束位置的元素。</p><h6 id="entries-返回包含数组所有键值对的-iterator"><a href="#entries-返回包含数组所有键值对的-iterator" class="headerlink" title="entries 返回包含数组所有键值对的 @@iterator"></a>entries 返回包含数组所有键值对的 @@iterator</h6><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.entries();</span><br><span class="line"><span class="built_in">console</span>.log(res.next().value)<span class="comment">// [0, 1] 0是下标，1时该下标对应的元素</span></span><br></pre></td></tr></table></figure><h6 id="includes-检测数组是否包含某个值"><a href="#includes-检测数组是否包含某个值" class="headerlink" title="includes 检测数组是否包含某个值"></a>includes 检测数组是否包含某个值</h6><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.include(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// true</span></span><br></pre></td></tr></table></figure><h6 id="find-数组每一项运行一个给定的函数，如果运行返回true，则返回这个元素"><a href="#find-数组每一项运行一个给定的函数，如果运行返回true，则返回这个元素" class="headerlink" title="find 数组每一项运行一个给定的函数，如果运行返回true，则返回这个元素"></a>find 数组每一项运行一个给定的函数，如果运行返回true，则返回这个元素</h6><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.find(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> item &gt; <span class="number">1</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h6 id="findIndex-数组每一项运行一个给定的函数，如果运行返回true，则返回这个元素的下标"><a href="#findIndex-数组每一项运行一个给定的函数，如果运行返回true，则返回这个元素的下标" class="headerlink" title="findIndex 数组每一项运行一个给定的函数，如果运行返回true，则返回这个元素的下标"></a>findIndex 数组每一项运行一个给定的函数，如果运行返回true，则返回这个元素的下标</h6><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.findIndex(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> item &gt; <span class="number">1</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h6 id="fill-用静态值填充数组"><a href="#fill-用静态值填充数组" class="headerlink" title="fill 用静态值填充数组"></a>fill 用静态值填充数组</h6><p>fill函数接收三个参数，填充值（必须），开始位置，结束位置</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.fill(<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// [2, 3, 3]</span></span><br></pre></td></tr></table></figure><h6 id="from-从一个类似数组或可迭代对象中创建一个新的，浅拷贝的数组实例"><a href="#from-从一个类似数组或可迭代对象中创建一个新的，浅拷贝的数组实例" class="headerlink" title="from 从一个类似数组或可迭代对象中创建一个新的，浅拷贝的数组实例"></a>from 从一个类似数组或可迭代对象中创建一个新的，浅拷贝的数组实例</h6><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(<span class="string">"foo"</span>);<span class="comment">//['f', 'o', 'o']</span></span><br></pre></td></tr></table></figure><p>Array.from这个方法接收三个参数，第一个是要转换成数组的类数组对象，第二个是新数组的每一项都会运行的函数，第三个参数this</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = <span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], x =&gt; x*<span class="number">2</span>);<span class="comment">//[2, 4, 6]</span></span><br></pre></td></tr></table></figure><h6 id="values-包含数组所有值的-iterator"><a href="#values-包含数组所有值的-iterator" class="headerlink" title="values 包含数组所有值的@@iterator"></a>values 包含数组所有值的@@iterator</h6><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> res = arr.values().next().value <span class="comment">// 1</span></span><br><span class="line">arr.values().next().value <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h6 id="key-包含数组所有下标的-iterator"><a href="#key-包含数组所有下标的-iterator" class="headerlink" title="key 包含数组所有下标的@@iterator"></a>key 包含数组所有下标的@@iterator</h6><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> res = arr.keys().next().value <span class="comment">// 0</span></span><br><span class="line">arr.values().next().value <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h6 id="flat-降维数组"><a href="#flat-降维数组" class="headerlink" title="flat 降维数组"></a>flat 降维数组</h6><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]], <span class="number">3</span>];</span><br><span class="line">arr.flat(<span class="number">1</span>) <span class="comment">// [1, 2, [3, [4, 5]], 3]</span></span><br><span class="line">arr.flat(<span class="number">2</span>) <span class="comment">// [1, 2, 3, [4, 5], 3]</span></span><br><span class="line">arr.flat(<span class="number">3</span>) <span class="comment">// [1, 2, 3, 4, 5, 3]</span></span><br></pre></td></tr></table></figure><p>flat函数接收一个参数，要提取嵌套数组的结构深度，默认值为 1。</p><h6 id="flatMap-包含数组所有下标的-iterator"><a href="#flatMap-包含数组所有下标的-iterator" class="headerlink" title="flatMap 包含数组所有下标的@@iterator"></a>flatMap 包含数组所有下标的@@iterator</h6><p>它与 map 和 深度值1的 flat 几乎相同</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">arr1.map(<span class="function"><span class="params">x</span> =&gt;</span> [x * <span class="number">2</span>]); </span><br><span class="line"><span class="comment">// [[2], [4], [6], [8]]</span></span><br><span class="line">arr1.flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [x * <span class="number">2</span>]);</span><br><span class="line"><span class="comment">// [2, 4, 6, 8]</span></span><br><span class="line"><span class="comment">// 只会将 flatMap 中的函数返回的数组 “压平” 一层</span></span><br><span class="line">arr1.flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [[x * <span class="number">2</span>]]);</span><br><span class="line"><span class="comment">// [[2], [4], [6], [8]]</span></span><br></pre></td></tr></table></figure><h3 id="链式储存结构"><a href="#链式储存结构" class="headerlink" title="链式储存结构"></a>链式储存结构</h3><p>数组的大小是固定，我们向数组的首部或者中间插入或者删除元素的成本很高，因为要移动元素。链式存储结构就很好的解决了这个问题，因为链式存储结构的元素不是连续存放在内存中。</p><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>链表就是一种很常见的链式存储结构，链表中的每个元素由一个存储数据的节点和指向下一个元素的指针。因此向链表中添加和删除元素是速度很快的，只要改变一下元素的指向，而不需要移动元素。</p><p>下面我们用js去实现一个链表结构</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkList</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> node = <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.el = el;</span><br><span class="line"><span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> head = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 链表的常用操作</span></span><br><span class="line"><span class="keyword">this</span>.append = <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;&#125;; <span class="comment">// 向链表尾部添加新的元素</span></span><br><span class="line"><span class="keyword">this</span>.insert = <span class="function"><span class="keyword">function</span> (<span class="params">position, el</span>) </span>&#123;&#125;; <span class="comment">// 向链表的特定的位置添加一个元素</span></span><br><span class="line"><span class="keyword">this</span>.removeAt = <span class="function"><span class="keyword">function</span> (<span class="params">position</span>) </span>&#123;&#125;; <span class="comment">// 删掉指定位置的元素</span></span><br><span class="line"><span class="keyword">this</span>.remove = <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;&#125;; <span class="comment">// 删除元素</span></span><br><span class="line"><span class="keyword">this</span>.indexOf = <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;&#125;; <span class="comment">//返回指定元素的索引，没有这返回-1</span></span><br><span class="line"><span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 判断是否是空链表</span></span><br><span class="line"><span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;; <span class="comment">//  返回链表长度</span></span><br><span class="line"><span class="keyword">this</span>.getHead = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 返回链表头部</span></span><br><span class="line"><span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 输出元素值</span></span><br><span class="line"><span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 输出链表元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><h3 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h3><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>栈是一个有序集合，并且遵循着先进后出，后进先出的原则。元素出去或者是进来的地方叫做栈顶，另一端是栈底。</p><p>下面上代码</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> items = [];</span><br><span class="line"><span class="keyword">this</span>.push = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123; <span class="comment">// 添加一个元素</span></span><br><span class="line">items.push(element);</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">this</span>.pop = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 移除栈顶的元素，同时返回被移除的元素</span></span><br><span class="line">items.pop();</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 判断栈是否空，为空返回true，否则返回false</span></span><br><span class="line"><span class="keyword">if</span>(items.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 移除栈里的元素</span></span><br><span class="line">items = []</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 返回栈的元素个数。</span></span><br><span class="line"><span class="keyword">return</span> items.length;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 输出栈</span></span><br><span class="line"><span class="keyword">return</span> items</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>队列是一组有序的项，遵守先进先出，后进后出的原则。比较常见的例子是打印机的打印队列，先发起的打印请求肯定先打印，后发起的请求后打印。</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> items = [];</span><br><span class="line"><span class="keyword">this</span>.enqueue = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123; <span class="comment">// 添加一个元素</span></span><br><span class="line">items.push(element);</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">this</span>.dequeue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 移除队列头部的元素，同时返回被移除的元素</span></span><br><span class="line">items.shift();</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 判断队列是否空，为空返回true，否则返回false</span></span><br><span class="line"><span class="keyword">if</span>(items.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 移除队列里的元素</span></span><br><span class="line">items = []</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 返回队列的元素个数。</span></span><br><span class="line"><span class="keyword">return</span> items.length;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 输出队列</span></span><br><span class="line"><span class="keyword">return</span> items</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非线性结构"><a href="#非线性结构" class="headerlink" title="非线性结构"></a>非线性结构</h3><h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><h4 id="图"><a href="#图" class="headerlink" title="图"></a>图</h4>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;想要做一个技术人，数据结构和算法都是必须的，在大学中，最让我头疼的也是这两门课，总觉得脑豁疼，毕业工作后一直想要找时间学习，但是奈何在前公司总是搬砖，做一些简单的工作，现离职后开始找工作，终于抽出时间开始学习数据结构和算法。数据结构和算法对我来说是难以翻越两座大山，但是做人要不断挑战自己，这一篇博客主要是记录一下学习数据结构的成果。&lt;/p&gt;
&lt;p&gt;数据结构按可以分为逻辑结构和物理结构。把数据结构比作人的话，物理结构就是看得见，摸得着的人体，逻辑结构就是人的精神和思想。&lt;/p&gt;
&lt;p&gt;物理结构分为顺序存储结构和链式存储结构。顺序存储结构有数组，链式存储结构有链表。&lt;/p&gt;
&lt;p&gt;逻辑结构分为线性结构和非线性结构。线性结构主要有顺序表，栈，队列。非线性结构主要有树，图。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="javaScript" scheme="http://yoursite.com/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript的三种编程范式比较</title>
    <link href="http://yoursite.com/2019/07/23/JavaScript%E7%9A%84%E4%B8%89%E7%A7%8D%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E6%AF%94%E8%BE%83/"/>
    <id>http://yoursite.com/2019/07/23/JavaScript的三种编程范式比较/</id>
    <published>2019-07-23T13:17:58.000Z</published>
    <updated>2020-07-30T14:29:54.449Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>JavaScript（通常简写为JS）是一种轻量的、解释性的、面向对象的头等函数语言，其最广为人知的应用是作为网页的脚本语言，但同时它也在很多非浏览器环境下使用。JS是一种动态的基于原型和多范式的脚本语言，支持面向对象、命令式和函数式的编程风格。 —MND</p></blockquote><a id="more"></a><h2 id="什么是编程范式"><a href="#什么是编程范式" class="headerlink" title="什么是编程范式"></a>什么是编程范式</h2><p>编程范式的英文为Programming paradigm，范的意思是模范，典范，范式也就是模式，方法，所以编程范式也就是编程的模式，方法。</p><h2 id="过程式编程（指令式编程）"><a href="#过程式编程（指令式编程）" class="headerlink" title="过程式编程（指令式编程）"></a>过程式编程（指令式编程）</h2><p>也就是从上至下，流水般的实现功能。</p><h2 id="函数式编程（声明式编程）"><a href="#函数式编程（声明式编程）" class="headerlink" title="函数式编程（声明式编程）"></a>函数式编程（声明式编程）</h2><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>更接近人类思维模式的一种编程范式</p><p>基于原型的编程也是面向对象编程的一种。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;JavaScript（通常简写为JS）是一种轻量的、解释性的、面向对象的头等函数语言，其最广为人知的应用是作为网页的脚本语言，但同时它也在很多非浏览器环境下使用。JS是一种动态的基于原型和多范式的脚本语言，支持面向对象、命令式和函数式的编程风格。 —MND&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="编程范式" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>js实现树的深度优先遍历和广度优先遍历</title>
    <link href="http://yoursite.com/2019/07/19/js%E5%AE%9E%E7%8E%B0%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
    <id>http://yoursite.com/2019/07/19/js实现树的深度优先遍历和广度优先遍历/</id>
    <published>2019-07-19T06:57:15.000Z</published>
    <updated>2020-07-30T14:29:54.587Z</updated>
    
    <content type="html"><![CDATA[<h2 id="树数据结构的介绍"><a href="#树数据结构的介绍" class="headerlink" title="树数据结构的介绍"></a>树数据结构的介绍</h2><p>数据结构可以分为顺序数据结构和非顺序结构。顺序数据结构是指把数据元素放在地址连续的存储单元里。非顺序结构可以把数据元素任意放在连续或者不连续的存储单元里。</p><p>树是一种非顺序数据结构。族谱，公司里的组织结构都可以看成是树模型。</p><p>树结构是包含一个根节点，还有内部节点，叶子节点。根节点是位于树的顶部。叶子节点是没有后代的节点。内部节点是除了根节点和叶子节点外的所有节点。一个节点可以有祖先和后代。根节点没有祖先。</p><p>节点的深度是节点的祖先节点数。</p><p>树的高度是所有节点深度中的最大的深度。</p><p>树可以分层级，根节点在第零层，它的子节点是第一层，依次类推。</p><p><img src="js%E5%AE%9E%E7%8E%B0%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/tree.jpg" alt=""></p><h2 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h2><h2 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h2><h2 id="js实现两种方式的遍历"><a href="#js实现两种方式的遍历" class="headerlink" title="js实现两种方式的遍历"></a>js实现两种方式的遍历</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;树数据结构的介绍&quot;&gt;&lt;a href=&quot;#树数据结构的介绍&quot; class=&quot;headerlink&quot; title=&quot;树数据结构的介绍&quot;&gt;&lt;/a&gt;树数据结构的介绍&lt;/h2&gt;&lt;p&gt;数据结构可以分为顺序数据结构和非顺序结构。顺序数据结构是指把数据元素放在地址连续的存储单元里
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="树的遍历" scheme="http://yoursite.com/tags/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>Vue Router学习（一）</title>
    <link href="http://yoursite.com/2019/07/02/Vue-Router%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2019/07/02/Vue-Router学习（一）/</id>
    <published>2019-07-02T01:41:48.000Z</published>
    <updated>2020-07-30T14:29:54.559Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="单页应用-vs-多页应用"><a href="#单页应用-vs-多页应用" class="headerlink" title="单页应用 vs 多页应用"></a>单页应用 vs 多页应用</h3><p><img src="Vue-Router%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/blog.png" alt=""></p><p>以我的博客为例，很多网站会有这样的布局，头部会有一个导航栏，每次点击页面会切换。</p><p>如果是多页应用MPA（Mutiple Page Application）的话，就是每一个导航是一个html，比如我的博客，导航里有5项，那么就有5个html，每次点击，都进行了html切换，每次都要加载新的html。</p><p>如果是单页应用，就只有一个html，没有导航切换的时候只是切换html页面内容，不会切换html。</p><a id="more"></a><h4 id="多页应用"><a href="#多页应用" class="headerlink" title="多页应用"></a>多页应用</h4><p>多页应用的优点是首次页面加载时间快，SEO效果好，缺点是页面切换慢。</p><p>因为多页应用是把系统分成很多个html，所以每次加载只加载了一个html，所以首次页面加载快。</p><p>SEO指搜索引擎优化，它是一种通过分析搜索引擎的排名规律，了解各种搜索引擎怎样进行搜索、怎样抓取互联网页面、怎样确定特定关键词的搜索结果排名的技术。</p><p>多页应用的内容基本都是直接写在html页面，这样搜索引擎就比较好好识别，所以seo排名效果好。</p><p>页面切换慢的原因是因为没有切换页面，都要重新请求html，相当于重新渲染页面，渲染整颗DOM树。</p><h4 id="单页应用"><a href="#单页应用" class="headerlink" title="单页应用"></a>单页应用</h4><blockquote><p>单页Web应用（single page web application，SPA）无疑是目前网站开发技术的弄潮儿，很多传统网站都在或者已经转型为单页Web应用       —《单页Web应用：JavaScript从前端到后端》</p></blockquote><p>单页应用相对于多页应用，比较明显的优点就是切换页面时间比较快，因为单页应用切换不需要重新请求html，它只是重新渲染dom树的其中一部分。但是因为单页应用把所有的内容都放到一个html里，所以他的首次加载页面时间会相对来说比较慢，要加载的内容比较多，而且一般单页应用的内容主要通过js去切换渲染，所以内容都是动态生成，不是直接写在html里，所以seo效果比较差。</p><p>搭建一个项目的时候到底是用多页面还是单页，这需要根据具体情况去分析。</p><h2 id="Vue-Router是什么？"><a href="#Vue-Router是什么？" class="headerlink" title="Vue Router是什么？"></a>Vue Router是什么？</h2><p>官方解释什么是Vue Router</p><p>Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。包含的功能有：</p><ol><li>嵌套的路由/视图表</li><li>模块化的、基于组件的路由配置</li><li>路由参数、查询、通配符</li><li>基于 Vue.js 过渡系统的视图过渡效果</li><li>细粒度的导航控制</li><li>带有自动激活的 CSS class 的链接</li><li>HTML5 历史模式或 hash 模式，在 IE9 中自动降级</li><li>自定义的滚动条行为</li></ol><h2 id="为什么要用Vue-Router？"><a href="#为什么要用Vue-Router？" class="headerlink" title="为什么要用Vue Router？"></a>为什么要用Vue Router？</h2><p>在单页应用中所有的东西都在一个html页面中，我们进行页面切换需要用到路由。</p><h2 id="怎么用Vue-Router？"><a href="#怎么用Vue-Router？" class="headerlink" title="怎么用Vue Router？"></a>怎么用Vue Router？</h2><h3 id="一个简单的单页面应用"><a href="#一个简单的单页面应用" class="headerlink" title="一个简单的单页面应用"></a>一个简单的单页面应用</h3><p>下面介绍的是vue-cli2.0下怎么用Vue Router</p><p> 首先我们先安装一下vue-cli2.0</p><p> <img src="Vue-Router%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/vue-init.jpg" alt=""></p><p> 可以看到，我们安装vue-cli 模版的时候可以选择安不安装Vue-Router，在这边我们选择yes。</p><p> 项目创建完成后我们看下<code>src\main.js</code></p> <figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// The Vue build version to load with the `import` command</span></span><br><span class="line"><span class="comment">// (runtime-only or standalone) has been set in webpack.base.conf with an alias.</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span> <span class="comment">// 引入了路由</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router, <span class="comment">// 使用路由</span></span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: <span class="string">'&lt;App/&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>首先我们把<code>src\App.vue</code>这个文件加上一个导航nav</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> &lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;.&#x2F;assets&#x2F;logo.png&quot;&gt;</span><br><span class="line">    &lt;nav&gt;</span><br><span class="line">      &lt;router-link class&#x3D;&quot;fd-header-item&quot; to&#x3D;&quot;&#x2F;&quot;&gt;Home&lt;&#x2F;router-link&gt;</span><br><span class="line">      &lt;router-link class&#x3D;&quot;fd-header-item&quot; to&#x3D;&quot;&#x2F;achives&quot;&gt;Achives&lt;&#x2F;router-link&gt;</span><br><span class="line">      &lt;router-link class&#x3D;&quot;fd-header-item&quot; to&#x3D;&quot;&#x2F;categories&quot;&gt;Categories&lt;&#x2F;router-link&gt;</span><br><span class="line">      &lt;router-link class&#x3D;&quot;fd-header-item&quot; to&#x3D;&quot;&#x2F;tags&quot;&gt;Tags&lt;&#x2F;router-link&gt;</span><br><span class="line">      &lt;router-link class&#x3D;&quot;fd-header-item&quot; to&#x3D;&quot;&#x2F;about&quot;&gt;About&lt;&#x2F;router-link&gt;</span><br><span class="line">    &lt;&#x2F;nav&gt;</span><br><span class="line">    &lt;router-view&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;App&#39;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">#app &#123;</span><br><span class="line">  font-family: &#39;Avenir&#39;, Helvetica, Arial, sans-serif;</span><br><span class="line">  -webkit-font-smoothing: antialiased;</span><br><span class="line">  -moz-osx-font-smoothing: grayscale;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: #2c3e50;</span><br><span class="line">  margin-top: 60px;</span><br><span class="line">&#125;</span><br><span class="line">.fd-header-item &#123;</span><br><span class="line">  cursor: pointer;</span><br><span class="line">&#125;</span><br><span class="line">.fd-header-item:hover, .router-link-exact-active&#123;</span><br><span class="line">  color: aqua;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>我们可以看到两个比较特殊的标签<code>&lt;router-link&gt;&lt;/router-link&gt;</code>，<code>&lt;router-view/&gt;</code></p><p><code>&lt;router-link&gt;</code>主要是用来做页面跳转的，一般写导航，<code>&lt;router-link&gt;</code>里的组件会渲染到<code>&lt;router-view/&gt;</code></p><p>我们一个导航项创建一个组件，所以我们在<code>src\components\</code>下创建五个组件，分别是home.vue, achives.vue, categories.vue, tags.vue, about.vue</p><p>Vue Router 给我们设置了高亮的样式<code>router-link-exact-active</code>，所以我们可以设置一个选中颜色。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.fd-header-item:hover, .router-link-exact-active&#123;</span><br><span class="line">  color: aqua;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>router-link里的to参数代表着你要跳转的路径，我们可以看下<code>src\Router\index.js</code></p><p>在这个js中我们引入了这五个组件，然后写了它们相应的路由</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> home <span class="keyword">from</span> <span class="string">'@/components/home'</span></span><br><span class="line"><span class="keyword">import</span> achives <span class="keyword">from</span> <span class="string">'@/components/achives'</span></span><br><span class="line"><span class="keyword">import</span> categories <span class="keyword">from</span> <span class="string">'@/components/categories'</span></span><br><span class="line"><span class="keyword">import</span> tags <span class="keyword">from</span> <span class="string">'@/components/tags'</span></span><br><span class="line"><span class="keyword">import</span> about <span class="keyword">from</span> <span class="string">'@/components/about'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      name: <span class="string">'home'</span>,</span><br><span class="line">      component: home</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/achives'</span>,</span><br><span class="line">      name: <span class="string">'achives'</span>,</span><br><span class="line">      component: achives</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/categories'</span>,</span><br><span class="line">      name: <span class="string">'categories'</span>,</span><br><span class="line">      component: categories</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/tags'</span>,</span><br><span class="line">      name: <span class="string">'tags'</span>,</span><br><span class="line">      component: tags</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/about'</span>,</span><br><span class="line">      name: <span class="string">'about'</span>,</span><br><span class="line">      component: about</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们看下这个home.vue,在点击home时我们显示I am Home ，其他几个页面相应的会输出。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;hello&quot;&gt;</span><br><span class="line">    &#123;&#123;msg&#125;&#125;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;home&#39;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &#39;I am Home&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p><img src="Vue-Router%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/vueRouter1.jpg" alt=""></p><p>到此一个简单单页面应用的基本框架就算搭好了。在此之中我们接触到了三个很类似的单词：route，routes，router。</p><p>route他是一条路由，比如home这个a标签链接指向home页面的内容。</p><p>routes是一组路由，也就是由route组成的一组数组</p><p>router是一个机制，路由机制。</p><h3 id="多级导航（嵌套路由）"><a href="#多级导航（嵌套路由）" class="headerlink" title="多级导航（嵌套路由）"></a>多级导航（嵌套路由）</h3><h4 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h4><p>现在在Achives导航下有两个二级导航achives1和achives2，点击Achives1和Achives2分别跳转到相应的页面。</p><h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><ol><li>在src/component下创建两个子页面achives1.vu和achives2.vue</li><li>在src/router/index.js里配置子路由</li><li>在archives.vue写上<code>&lt;router-view/&gt;</code></li><li>在App.vue里写Achives点击事件，点击后出现二级导航</li></ol><h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><p>创建了两个子页面</p><p><img src="Vue-Router%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/%E5%AD%90%E9%A1%B5%E9%9D%A2.jpg" alt=""></p><p>achives1.vue页面如下</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;hello&quot;&gt;</span><br><span class="line">    &#123;&#123;msg&#125;&#125;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;achives1&#39;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &#39;I am Achives1&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>src/router/index.js</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: <span class="string">'/achives'</span>,</span><br><span class="line">  component: achives,</span><br><span class="line">  children: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'achives1'</span>,</span><br><span class="line">      component: achives1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'achives2'</span>,</span><br><span class="line">      component: achives2</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们在achives的路由中加了一个children属性,这个属性是一个数组，然后有两项，也就是我们的两个子页面的路由，相应的path是路径，component是组件，所以我们要在src/router/index.js里引入这两个组件</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> achives1 <span class="keyword">from</span> <span class="string">'@/components/achives1'</span></span><br><span class="line"><span class="keyword">import</span> achives2 <span class="keyword">from</span> <span class="string">'@/components/achives2'</span></span><br></pre></td></tr></table></figure><p>在父页面achives.vue</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;hello&quot;&gt;</span><br><span class="line">    &#123;&#123;msg&#125;&#125;</span><br><span class="line">   &lt;router-view&#x2F;&gt; &#x2F;&#x2F; 新增的</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;achives&#39;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &#39;I am Achives&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>最后我们只要在App.vue添加相应的点击事件和router-link</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>《单页Web应用：JavaScript从前端到后端》</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h3 id=&quot;单页应用-vs-多页应用&quot;&gt;&lt;a href=&quot;#单页应用-vs-多页应用&quot; class=&quot;headerlink&quot; title=&quot;单页应用 vs 多页应用&quot;&gt;&lt;/a&gt;单页应用 vs 多页应用&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;Vue-Router%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/blog.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;以我的博客为例，很多网站会有这样的布局，头部会有一个导航栏，每次点击页面会切换。&lt;/p&gt;
&lt;p&gt;如果是多页应用MPA（Mutiple Page Application）的话，就是每一个导航是一个html，比如我的博客，导航里有5项，那么就有5个html，每次点击，都进行了html切换，每次都要加载新的html。&lt;/p&gt;
&lt;p&gt;如果是单页应用，就只有一个html，没有导航切换的时候只是切换html页面内容，不会切换html。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="vue vue-Router" scheme="http://yoursite.com/tags/vue-vue-Router/"/>
    
  </entry>
  
  <entry>
    <title>浏览器缓存详解</title>
    <link href="http://yoursite.com/2019/06/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/06/16/浏览器缓存详解/</id>
    <published>2019-06-16T14:00:23.000Z</published>
    <updated>2020-07-30T14:29:54.627Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>可能有人会和以前的我一样，觉得缓存不是后台设置的吗，感觉和前端人员没有太大联系，平时关于缓存最常做的就是在浏览器<code>Ctrl+Shit+Delete</code>清空缓存。</p><p>web缓存可以大致分为三类：</p><pre><code>1. 浏览器缓存2. 代理缓存3. 网关缓存</code></pre><p>我们这篇文章主要讲的是浏览器缓存，浏览器主要是通过http/https和服务器进行通信，所以浏览器缓存我们也可以说是HTTP缓存。</p><a id="more"></a><h2 id="二、什么是浏览器缓存"><a href="#二、什么是浏览器缓存" class="headerlink" title="二、什么是浏览器缓存"></a>二、什么是浏览器缓存</h2><blockquote><p>浏览器缓存（Browser Caching）是为了节约网络的资源加速浏览，浏览器在用户磁盘上对最近请求过的文档进行存储，当访问者再次请求这个页面时，浏览器就可以从本地磁盘显示文档，这样就可以加速页面的阅览。-百度百科</p></blockquote><p>缓存了的文档应该怎么命中，应该什么时候删除，应该什么时候更新，所以有一套缓存机制去进行处理这些问题，下面会详细说明。</p><h2 id="三、为什么用浏览器缓存"><a href="#三、为什么用浏览器缓存" class="headerlink" title="三、为什么用浏览器缓存"></a>三、为什么用浏览器缓存</h2><p>我们判断一个网站的用户体验的好坏的一个标准就是这个网站加载的速度，而影响速度的因素有很多，比如浏览器和服务器通信的时间，服务器处理时间等等，而缓存如果命中的话是从客户端取数据，所以不需要请求服务器，所以提高了加载速度。缓存存在以下优点：</p><ol><li>减少了等待时间</li><li>减少了网络通信量</li></ol><h2 id="四、怎么设置浏览器缓存"><a href="#四、怎么设置浏览器缓存" class="headerlink" title="四、怎么设置浏览器缓存"></a>四、怎么设置浏览器缓存</h2><h3 id="HTTP响应头"><a href="#HTTP响应头" class="headerlink" title="HTTP响应头"></a>HTTP响应头</h3><h4 id="a-HTTP报文"><a href="#a-HTTP报文" class="headerlink" title="a. HTTP报文"></a>a. HTTP报文</h4><p>客户端和服务端通过HTTP报文进行通信，请求端（客户端）的HTTP报文叫做请求报文，响应端（服务器端）的叫做响应报文。</p><p>HTTP报文大致可以分为报文首部和报文主体。</p><p>如图：</p><h5 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h5><p><img src="%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E8%AF%A6%E8%A7%A3/HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.png" alt="请求报文"></p><p>这个是我本地的一个ajax请求的报文。</p><p><img src="%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E8%AF%A6%E8%A7%A3/http%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E7%9C%9F%E5%AE%9E.png" alt="http请求报文"></p><p>代码如下</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">oneClick () &#123;</span><br><span class="line">  <span class="keyword">this</span>.$axioss.get(<span class="string">'/users'</span>).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到请求方法为GET，请求url为‘/users’，请求协议HTTP1.1，下面是一串头部字段名和值。</p><p>下面列出了常用的几种请求方法</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. GET: 主要用于获取数据.</span><br><span class="line">2. HEAD: 请求一个与GET请求的响应相同的响应，但没有响应体.</span><br><span class="line">3. POST: 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。</span><br><span class="line">4. PUT: 从客户端向服务器传送的数据取代指定的文档的内容。</span><br><span class="line">5. DELETE: 删除指定的资源。</span><br></pre></td></tr></table></figure><h5 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h5><p><img src="%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E8%AF%A6%E8%A7%A3/HTTP%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87.png" alt="响应报文"></p><p>响应代码如下</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">router.get(&#39;&#x2F;&#39;, function(req, res, next) &#123;</span><br><span class="line">  res.json(&#123;</span><br><span class="line">    code: 200,</span><br><span class="line">    success: true,</span><br><span class="line">    message: &#39;请求成功&#39;,</span><br><span class="line">    data: []</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们看真实的请求报文：</p><p><img src="%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E8%AF%A6%E8%A7%A3/http%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E7%9C%9F%E5%AE%9E.png" alt="http请求报文"></p><p>一开始是http协议，然后是状态码，现在是200，然后是原因短语‘OK’，下面是一串响应头部字段。</p><p>状态码描述了饭回的结果状态，用户可以根据状态码知道服务器是正常处理了请求，还是出现问题。<br>状态码主要类别有‘1xx’，‘2xx’，‘3xx’，‘4xx’，‘5xx’。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1. 1xx：信息性状态码</span><br><span class="line">2. 2xx： 成功状态码</span><br><span class="line">* 200 Ok 表示请求在服务端被正常的处理了</span><br><span class="line">* 204 no content 服务器接受的请求已成功处理，但响应报文不包含实体的主体部分</span><br><span class="line">* 206 partial content 表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求</span><br><span class="line">3. 3xx： 重定向状态码</span><br><span class="line">* 301 moveed permanently 永久性重定向</span><br><span class="line">* 302 found 临时性重定向</span><br><span class="line">* 303 see other</span><br><span class="line">* 304 not modified</span><br><span class="line">* 307 temporary redirect 临时重定向</span><br><span class="line">4. 4xx：客户端错误状态码</span><br><span class="line">* 400 bad request 请求报文存在语法错误</span><br><span class="line">* 401 unauthorized 发送的请求需要有通过http认证的认证信息</span><br><span class="line">* 403 forbidden 请求资源的访问被服务器拒绝</span><br><span class="line">* 404 not found 服务器上无法找到请求的资源</span><br><span class="line">5. 5xx：服务器错误状态码</span><br><span class="line">* 500 internal server error 服务器在执行请求时发生了错误</span><br><span class="line">* 503 service unavailable 服务器暂时处于超负载或正在进行停机维护</span><br></pre></td></tr></table></figure><h5 id="报文首部字段"><a href="#报文首部字段" class="headerlink" title="报文首部字段"></a>报文首部字段</h5><p>HTTP首部字段可以分为4种类型</p><ol><li>通用首部字段</li><li>请求首部字段</li><li>响应首部字段</li><li>实体首部字段</li></ol><table>    <caption>通用首部字段</caption>    <tr>        <th>首部字段名</th>        <th>说明</th>    </tr>    <tr>        <td>Cache-Control</td>        <td>控制缓存的行为</td>    </tr>    <tr>        <td>Connection</td>        <td>逐跳首部、连接的管理</td>    </tr>    <tr>        <td>Date</td>        <td>创建报文的日期时间</td>    </tr>    <tr>        <td>Pragma</td>        <td>报文指令</td>    </tr>    <tr>        <td>Trailer</td>        <td>报文末端的首部一览</td>    </tr>    <tr>        <td>Transfer-Encoding</td>        <td>指定报文主体的传输编码方式</td>    </tr>    <tr>        <td>Upgrade</td>        <td>升级为其他协议</td>    </tr>    <tr>        <td>Via</td>        <td>代理服务器的相关信息</td>    </tr>    <tr>        <td>Warning</td>        <td>错误通知</td>    </tr></table><table>    <caption>请求首部字段</caption>    <tr>        <th>首部字段名</th>        <th>说明</th>    </tr>    <tr>        <td>Accept</td>        <td>用户代理可以处理的媒体类型</td>    </tr>    <tr>        <td>Accept-Charset</td>        <td>优先的字符集</td>    </tr>    <tr>        <td>Accept-Encoding</td>        <td>优先的内容编码</td>    </tr>    <tr>        <td>Accept-Language</td>        <td>优优先的语言（自然语言）</td>    </tr>    <tr>        <td>Authorization</td>        <td>web认证信息</td>    </tr>    <tr>        <td>Expect</td>        <td>期待服务器的特定行为</td>    </tr>    <tr>        <td>From</td>        <td>用户的电子邮箱</td>    </tr>    <tr>        <td>Host</td>        <td>请求资源所在服务器</td>    </tr>    <tr>        <td>if-Match</td>        <td>比较实体标记（ETag）</td>    </tr>    <tr>        <td>if-modified-Since</td>        <td>比较资源的更新时间</td>    </tr>    <tr>        <td>if-none-Match</td>        <td>比较实体标记（ETag）</td>    </tr>    <tr>        <td>if-Range</td>        <td>资源未更新时发生实体Byte的范围请求</td>    </tr>    <tr>        <td>if-Unmodified-Since</td>        <td>比较资源的更新时间（与if-Modified-Since）</td>    </tr><pre><code>&lt;tr&gt;    &lt;td&gt;Max-Forwards&lt;/td&gt;    &lt;td&gt;最大传输逐跳数&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;td&gt;Proxy-Authorization&lt;/td&gt;    &lt;td&gt;代理服务器邀请客户端的认证信息&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;td&gt;Range&lt;/td&gt;    &lt;td&gt;实体的字节范围请求&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;td&gt;Referer&lt;/td&gt;    &lt;td&gt;对请求中URI的原始获取方&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;td&gt;TE&lt;/td&gt;    &lt;td&gt;传输编码的优先级&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;td&gt;User-Agent&lt;/td&gt;    &lt;td&gt;HTTP客户端程序的信息&lt;/td&gt;&lt;/tr&gt;</code></pre></table><table>    <caption>响应首部字段</caption>    <tr>        <th>首部字段名</th>        <th>说明</th>    </tr>    <tr>        <td>Accept-Ranges</td>        <td>是否接受字节范围请求</td>    </tr>    <tr>        <td>ETag</td>        <td>资源的匹配信息</td>    </tr>    <tr>        <td>Location</td>        <td>令客户端重定向至指定URI</td>    </tr>    <tr>        <td>Proxy-Authenticate</td>        <td>代理服务器对客户端的认证信息</td>    </tr>    <tr>        <td>Retry-After</td>        <td>对再次发起请求的时机要求</td>    </tr>    <tr>        <td>Server</td>        <td>HTTP服务器的安装信息</td>    </tr>    <tr>        <td>Vary</td>        <td>代理服务器的缓存管理信息</td>    </tr>    <tr>        <td>WWW-Authenticate</td>        <td>服务器对客户端的认证信息</td>    </tr></table><table>    <caption>实体首部字段</caption>    <tr>        <th>首部字段名</th>        <th>说明</th>    </tr>    <tr>        <td>Allow</td>        <td>资源可支持的HTTP方法</td>    </tr>    <tr>        <td>Content-Encoding</td>        <td>实体主体适用的编码方法</td>    </tr>    <tr>        <td>Content-Language</td>        <td>实体主体的自然语言</td>    </tr>    <tr>        <td>Content-Length</td>        <td>实体主体的大小（单位：字节）</td>    </tr>    <tr>        <td>Content-Location</td>        <td>代替对应资源的URI</td>    </tr>    <tr>        <td>Content-MD5</td>        <td>实体主体的报文摘要</td>    </tr>    <tr>        <td>Content-Range</td>        <td>实体主体的位置范围</td>    </tr>    <tr>        <td>Content-Type</td>        <td>实体主体的媒体类型</td>    </tr>    <tr>        <td>Expires</td>        <td>实体主体过期的日期时间</td>    </tr>    <tr>        <td>Last-Modified</td>        <td>资源最后修改日期时间</td>    </tr></table><h4 id="b-强缓存-Expires-vs-Cache-Control"><a href="#b-强缓存-Expires-vs-Cache-Control" class="headerlink" title="b. 强缓存(Expires vs Cache-Control)"></a>b. 强缓存(Expires vs Cache-Control)</h4><h5 id="Expires-http1-0"><a href="#Expires-http1-0" class="headerlink" title="Expires http1.0"></a>Expires http1.0</h5><p><img src="%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E8%AF%A6%E8%A7%A3/Exprires_we.jpeg" alt=""></p><p>Expires 设置缓存过期时间</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(<span class="string">'Expires'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.now() + <span class="number">600000</span>));<span class="comment">// 当前时间过十分钟后过期</span></span><br></pre></td></tr></table></figure><p><img src="%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E8%AF%A6%E8%A7%A3/Expires.jpg" alt="Expires"></p><p>图中表示该文件在Tue Jun 25 2019 16:17:08 GMT+0800 日期过期，所以第一次请求的时候我们可以看到状态是200，然后下次请求时从缓存中获取的资源而没有请求服务器</p><p>第一次请求</p><p><img src="%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E8%AF%A6%E8%A7%A3/Expires1.png" alt=""></p><p>第二次请求</p><p><img src="%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E8%AF%A6%E8%A7%A3/Expires2.png" alt=""></p><p>但是如果服务器时间和客户端时间不同步，如果服务器时间快于客户端时间的话，我们设置的缓存时间小于服务器大于客户端时间的话，那么我们设置的缓存时间就不起作用了；如果服务器时落后于客户端时间，有可能导致缓存时间已经过了，但是还是用的缓存。</p><p>为了避免这个问题，http1.1推出了Cache-Control</p><h5 id="Cache-Control-http1-1"><a href="#Cache-Control-http1-1" class="headerlink" title="Cache-Control http1.1"></a>Cache-Control http1.1</h5><p>Cache-Control的常见属性</p><ol><li>private: 客户端可以缓存</li><li>public: 客户端和代理服务器都可缓存</li><li>max-age=xxx: 缓存的内容将在 xxx 秒后失效</li><li>no-cache: 需要使用对比缓存来验证缓存数据</li><li>no-store: 所有内容都不会缓存，强制缓存，对比缓存都不会触发</li></ol><p><img src="%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E8%AF%A6%E8%A7%A3/Cache-Control.jpeg" alt=""></p><p>Cache-Control设置的是相对时间</p><pre><code>res.setHeader(&apos;Cache-Control&apos;, &apos;public, max-age=10&apos;);</code></pre><p>这个代码设置的是缓存相对于当前时间10s后过期，这样就算服务器和客户端时间不同步也不会影响。</p><p>如果同时存在Expires和Cache-Control，Cache-Control的优先级更高。</p><p>但是不管是Expires还是Cache-Control，都是设置缓存过期时间，但是缓存时间过期后其实资源并没有改变，但是还是去请求资源了，为了解决这样的问题，所以有了协商缓存。</p><h4 id="c-协商缓存"><a href="#c-协商缓存" class="headerlink" title="c. 协商缓存"></a>c. 协商缓存</h4><p>强缓存都是浏览器通过响应报文的某个字段去设置缓存，协商缓存是通过一组字段结合起来进行缓存。</p><h4 id="Last-Modified和If-Modified-Since"><a href="#Last-Modified和If-Modified-Since" class="headerlink" title="Last-Modified和If-Modified-Since"></a>Last-Modified和If-Modified-Since</h4><p><img src="%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E8%AF%A6%E8%A7%A3/Last.jpeg" alt=""></p><p>Last-Modified 顾名思义是最后一次修改时间，这个是服务端获取到的，在响应报文里会返回，If-Modified-Since（等于上一次请求的Last-Modified）是浏览器根据服务端返回的Last—Modified设置的，可以理解成浏览器端存储的资源的最后修改时间。</p><p>协商，也就是浏览器和服务器之间进行协商，如果资源有改动，那么服务器每次返回时会带上一个字段Last-Modified，该资源的最后修改时间，还有一个资源过期时间，可以是Cache-Control或者Expires，然后浏览器获取到这两个字段，并且保存下来，在缓存时间没有过期时，浏览器会从缓存中获取资源，不会请求服务器，等到缓存过期时，浏览器请求服务器，请求报文会带上一个字段If-Modified-Since，这个字段是上一次的Last-Modified，然后服务器会判断最新的Last-Modified和If-Modified-Since是否相等，如果相等，意味着该资源在这段时间并没有改动，那么浏览器会返回304，如果不想等的话，服务器会将最新的Last-Modified返回，并且返回改动后的资源，并且状态码为200</p><p>下面的图是一个我们修改demo.js后浏览器和服务器的通信。</p><p><img src="%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E8%AF%A6%E8%A7%A3/Last-modified.png" alt=""></p><p>这个缓存方法有两个问题：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 因为Last-Modified的时间是GMT时间，只能精确到秒，如果文件在1秒内有多次改动，服务器并不知道文件有改动，那么浏览器获取不到最新的文件。</span><br><span class="line">2. 如果服务器上某资源被多次改动，但是内容并没有变化，服务器会更新改动时间，所以每次都会返回给客户端</span><br></pre></td></tr></table></figure><p>为了解决这些问题，我们引入了ETag和If-None—Match</p><h4 id="ETag和If-None-Match"><a href="#ETag和If-None-Match" class="headerlink" title="ETag和If-None-Match"></a>ETag和If-None-Match</h4><p>上面的Last-Modified是通过资源改动时间去判断是否该给客户端返回新的资源，现在是通过ETag：资源的唯一标识来判断，只有资源的内容改变时，ETag才会改变。</p><p>If-None-Match是上一次的ETag。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>那么到这关于http缓存的几个首部字段且含义已经介绍完了，那么问题来了，浏览器无法主动得知资源的变化，只有没有Expires或者是Cache-Control设置的缓存时间过期后，浏览器主动请求服务端以此得知资源的变化。</p><p>那么我们应该怎么解决这个问题？</p><p><img src="%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E8%AF%A6%E8%A7%A3/%E9%BB%91%E4%BA%BA%E9%97%AE%E5%8F%B7.jpeg" alt=""></p><img src="浏览器缓存详解/answer.jpeg" onclick="document.getElementsByClassName('fd-img')[0].style.display='block'"><style>.fd-img {    display: none;}</style><img src="浏览器缓存详解/version.png" class="fd-img"><p>在公司呆的时间比较长的话看到第一段代码可能比较熟悉，以前用require.js的时候我们会在文件名后面加上版本号和时间戳，最近的项目用webpack的话，打包文件的时候也会在文件名后加上哈希数。</p><p>这样做的思路就是因为每次文件有改动后，比如js，那么会导致html页面也会跟着改动，因为html里引用了该js文件，所以浏览器去访问html页面时发现页面已经改动了，就会去请求服务器。这样我们就能做到浏览器主动得知资源的变动。</p><h2 id="五、浏览器本地缓存"><a href="#五、浏览器本地缓存" class="headerlink" title="五、浏览器本地缓存"></a>五、浏览器本地缓存</h2><h3 id="一-manifest（H5的应用缓存）"><a href="#一-manifest（H5的应用缓存）" class="headerlink" title="(一) manifest（H5的应用缓存）"></a>(一) manifest（H5的应用缓存）</h3><p>浏览器缓存中划分出了一块缓存区，如果想要在这个缓存中保存数据，可以用一个描述文件，列出要下载和缓存的资源，然后将该描述文件于页面关联起来，可以在<html>中的manifest属性中指定这个文件的路径，比如：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;html manifest&#x3D;&#39;&#x2F;offline.manifest&#39;&gt;</span><br></pre></td></tr></table></figure><h3 id="（二）storage-Web-存储机制"><a href="#（二）storage-Web-存储机制" class="headerlink" title="（二）storage(Web 存储机制)"></a>（二）storage(Web 存储机制)</h3><p>Web Storage 包含如下两种机制：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. sessionStorage 为每一个给定的源（given origin）维持一个独立的存储区域，该存储区域在页面会话期间可用（即只要浏览器处于打开状态，包括页面重新加载和恢复）。</span><br><span class="line">2. localStorage 同样的功能，但是在浏览器关闭，然后重新打开后数据仍然存在。</span><br></pre></td></tr></table></figure><h3 id="（三）indexDB"><a href="#（三）indexDB" class="headerlink" title="（三）indexDB"></a>（三）indexDB</h3><blockquote><p>ndexedDB是一种低级API，用于客户端存储大量结构化数据(包括, 文件/ blobs)。该API使用索引来实现对该数据的高性能搜索。虽然 Web Storage 对于存储较少量的数据很有用，但对于存储更大量的结构化数据来说，这种方法不太有用。IndexedDB提供了一个解决方案。</p></blockquote><h3 id="（四）cookie"><a href="#（四）cookie" class="headerlink" title="（四）cookie"></a>（四）cookie</h3><blockquote><p>HTTP Cookie（也叫Web Cookie或浏览器Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie使基于无状态的HTTP协议记录稳定的状态信息成为了可能。</p></blockquote><h2 id="六、后记"><a href="#六、后记" class="headerlink" title="六、后记"></a>六、后记</h2><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ol><li><p><a href="https://juejin.im/post/5b70edd4f265da27df0938bc" target="_blank" rel="noopener">前端也要懂Http缓存机制</a></p></li><li><p><a href="https://juejin.im/post/5b3c87386fb9a04f9a5cb037" target="_blank" rel="noopener">面试精选之http缓存</a></p></li><li><p>《图解HTTP》</p></li><li><p>《JavaScript高级程序设计》</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;可能有人会和以前的我一样，觉得缓存不是后台设置的吗，感觉和前端人员没有太大联系，平时关于缓存最常做的就是在浏览器&lt;code&gt;Ctrl+Shit+Delete&lt;/code&gt;清空缓存。&lt;/p&gt;
&lt;p&gt;web缓存可以大致分为三类：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 浏览器缓存
2. 代理缓存
3. 网关缓存&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们这篇文章主要讲的是浏览器缓存，浏览器主要是通过http/https和服务器进行通信，所以浏览器缓存我们也可以说是HTTP缓存。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
</feed>
