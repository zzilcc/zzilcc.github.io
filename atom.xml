<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>黄紫茜的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-23T15:24:38.366Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>黄紫茜</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>揭秘输入地址到显示页面背后发生的故事</title>
    <link href="http://yoursite.com/2019/08/12/%E6%8F%AD%E7%A7%98%E8%BE%93%E5%85%A5%E5%9C%B0%E5%9D%80%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E8%83%8C%E5%90%8E%E5%8F%91%E7%94%9F%E7%9A%84%E6%95%85%E4%BA%8B/"/>
    <id>http://yoursite.com/2019/08/12/揭秘输入地址到显示页面背后发生的故事/</id>
    <published>2019-08-12T06:48:43.000Z</published>
    <updated>2019-08-23T15:24:38.366Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>工作了一年多，发现自己其实学习路线是存在问题的，刚开始学习前端就是直接学习着三个基础HTML，CSS,JavaScript，然后就学习框架vue，然后vue脚手架，vuex，路由，webpack这些。</p><p>从来没有考虑过本质，比如浏览器的运行，渲染机制，浏览器怎么和服务器通行等等。所有的认知都只是停留在表面。</p><p>所以意识到自己的短板后，开始深入学习。</p><a id="more"></a><h2 id="浏览器组成"><a href="#浏览器组成" class="headerlink" title="浏览器组成"></a>浏览器组成</h2><p>首先我们要知道浏览器的组成。我们知道不同浏览器具体实现是有不同的，但是它们设计思想是一样的，所以可以将浏览器抽象成下面的图。</p><p><img src="/2019/08/12/揭秘输入地址到显示页面背后发生的故事/浏览器组成.jpg" alt=""></p><p><img src="/2019/08/12/揭秘输入地址到显示页面背后发生的故事/架构table.png" alt=""></p><h2 id="浏览器历史"><a href="#浏览器历史" class="headerlink" title="浏览器历史"></a>浏览器历史</h2><p>在2007年前大多数浏览器都是单进程的，也就是所有功能都运行在一个进程中。那时候浏览器需要借助插件去实现web视频，web游戏，但是插件是很不稳定的，常常会崩溃，由于是单进程，所以其中一个模块崩溃会导致整个浏览器崩溃。所以后面出现了多进程浏览器，不同功能模块运行在不同的进程，相互之间独立。</p><h3 id="单进程浏览器"><a href="#单进程浏览器" class="headerlink" title="单进程浏览器"></a>单进程浏览器</h3><p>单进程浏览器有如下的缺点：</p><ol><li>不稳定</li><li>不流畅</li><li>不安全</li></ol><p>插件和渲染引擎模块在当时具有不稳定性，因而导致浏览器不稳定。不流畅是因为所有模块都要在一个进程运行，也就是每个模块是等待上一个模块运行结束后才能运行，所以页面肯定是不流畅的，加载时间慢。不安全是如果在插件中有病毒，那么就会导致整个浏览器崩溃掉。</p><h3 id="多进程浏览器"><a href="#多进程浏览器" class="headerlink" title="多进程浏览器"></a>多进程浏览器</h3><p>现在市面上大多数的浏览器都是多进程的。以谷歌为例，我们开始打开一个页签，这里我打开了谷歌搜索。我们可以看到一开始就有5个进程。</p><p><img src="/2019/08/12/揭秘输入地址到显示页面背后发生的故事/进程.png" alt=""></p><p>进程我们可以分为：浏览器主进程，GPU进程，网络进程，渲染进程，插件进程。</p><p>图中第一个显示‘浏览器’指的就是浏览器主进程。主要负责掌控全场，包括浏览器的界面的显示，用户交互（前进，后退等等）、负责各个页面的管理，子进程的创建与销毁等、存储功能等。</p><p>GPU进程一开始是为了3D绘制，但是后面谷歌浏览的ui界面都用GPU渲染，所以GPU单独成为了一个进程。</p><p>网络进程（Network Service）是最近才单独成为一个进程，之前是运行在主进程，主要负责网络资源的加载。</p><p>渲染进程：主要任务是将html，css，js转换成用户可以交互的页面，默认情况下一个页签会生成一个进程。</p><p>插件进程：之前说过，插件是不稳定的，所以要把插件单独作为一个进程。</p><h3 id="面向服务架构"><a href="#面向服务架构" class="headerlink" title="面向服务架构"></a>面向服务架构</h3><p>多进程模型虽然解决了单进程的许多问题，但是也带来了一些问题，比如内存占用变高了，因为每一个进程都有公共基础模块的副本，还有体系结构变复杂了，模块之间耦合性高，扩展性差。现在谷歌团队根据‘面向服务的架构（SOA）’思想设计了一个新的架构。原来的模块都独立成一个个服务，服务可以在进程中运行。但是这个架构过渡是需要一定的时间。</p><h2 id="再也不怕别人问我输入url后发生了什么"><a href="#再也不怕别人问我输入url后发生了什么" class="headerlink" title="再也不怕别人问我输入url后发生了什么"></a>再也不怕别人问我输入url后发生了什么</h2><p>首先上个总体图</p><p><img src="/2019/08/12/揭秘输入地址到显示页面背后发生的故事/页面加载过程.jpg" alt=""></p><p>我们之前说过现代浏览器主要是多进程浏览器，然后实现一个页面的展示依靠多个进程之间相互协作。主要有浏览器主进程，网络进程，渲染进程。</p><p>输入url后到页面展示主要可以分为两个流程：导航流程和渲染流程。</p><p>导航流程页分为用户输入过程、url请求过程、提交文档过程。</p><h3 id="导航流程"><a href="#导航流程" class="headerlink" title="导航流程"></a>导航流程</h3><h4 id="用户输入过程"><a href="#用户输入过程" class="headerlink" title="用户输入过程"></a>用户输入过程</h4><p>我们在地址栏输入一个地址url，然后回车，这时候浏览器主进程会判断是输入的是地址还是搜索关键字，如果是地址的话，那么进入url请求过程，如果是关键字搜索的话，那么就会根据浏览器默认的搜索引擎生成新的url，然后将生成的url通过进程间通信IPC传递给网络进程。</p><h4 id="url请求过程"><a href="#url请求过程" class="headerlink" title="url请求过程"></a>url请求过程</h4><h5 id="查看缓存"><a href="#查看缓存" class="headerlink" title="查看缓存"></a>查看缓存</h5><p>拿到URL后第一个会检查有没有缓存，如果有缓存那么就读取缓存，如果没有缓存，则进行下一步。</p><h5 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h5><p>识别url，抽取出域名，然后进行DNS解析。</p><p>DNS为Domain Name System的简写。意为域名系统。为什么要解析域名？这是因为在互联网中我们要访问其他服务器是通过ip地址进行通信，但是ip地址不利于人们记忆，所以人们通过域名去记忆，比如cn.bing.com、<a href="http://www.google.com。所以我们需要将域名解析成ip地址，然后发起请求。" target="_blank" rel="noopener">www.google.com。所以我们需要将域名解析成ip地址，然后发起请求。</a></p><p>找了许多文章来看，各有说各的，我也不懂怎么去验证谁是对的，所以在这里就不细说DNS解析过程了。</p><p>假装拿到了ip地址。</p><h5 id="发起http请求"><a href="#发起http请求" class="headerlink" title="发起http请求"></a>发起http请求</h5><h5 id="生成http请求报文"><a href="#生成http请求报文" class="headerlink" title="生成http请求报文"></a>生成http请求报文</h5><p>详情可以移步<a href="https://zzilcc.github.io/2019/06/16/浏览器缓存详解/" target="_blank" rel="noopener">浏览器缓存详解</a> 里面有关于http请求报文的详细介绍。</p><h6 id="建立TCP连接（三次握手）"><a href="#建立TCP连接（三次握手）" class="headerlink" title="建立TCP连接（三次握手）"></a>建立TCP连接（三次握手）</h6><p>我们首先来看下TCP/IP协议栈</p><p><img src="/2019/08/12/揭秘输入地址到显示页面背后发生的故事/TCP.jpg" alt=""></p><blockquote><p>TCP （传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，然后TCP把数据流分区成适当长度的报文段（通常受该计算机连接的网络的数据链路层的最大传输单元（MTU）的限制）。之后TCP把结果包传给IP层，由它来通过网络将包传送给接收端实体的TCP层。TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。 –百度百科</p></blockquote><p>我们知道TCP可以给我们提供可靠的数据传递，在协议栈途中我们可以看到TCP报文的首部，与建立TCP连接相关的几个字段为序号（seq），确认号（ack），六个标志中的ACK，SYN这共四个字段。</p><pre><code>1. 序号（seq）：报文的序号，建立连接的话序号是随机生成的。2. 确认序号（ack）：只有六个标志位中的ACK为1的时候，确认序号才有效，ack=seq+13. ACK：决定确认序号ack是否有效4. SYN：发起一个新连接</code></pre><p>TCP的可靠性就是靠序号和确认序号去实现。</p><p><img src="/2019/08/12/揭秘输入地址到显示页面背后发生的故事/建立TCP连接.jpg" alt=""></p><p>建立TCP连接的过程如下：</p><ol><li>客户端发送SYN=1，seq=x的报文给服务端，表示要创建一个新连接，报文的序号为x</li><li>服务端接收到后会返回SYN=1，ACK=1，表示已经接收到发起连接到请求，seq=k，ack=x+1，而且期待下次接收到是x+1序号到报文，然后服务器的报文的序号是k</li><li>看上去现在一来一回，感觉上就应该可以建立连接了，但是为什么还有第三次握手，这是为了很久以前的客户端的报文莫名的到了服务端，而且此时客户端已经不需要建立连接了，但是如果只有两次握手就建立的连接的话，那么此时服务器就会确定建立连接，并且等待客户端传输数据，那么就造成了服务端资源的浪费。所以需要进行第三次握手，也就是客户端返回一个ACK=1，ack=k+1表示已经知道服务端收到刚刚发送的连接发起请求报文</li></ol><h6 id="传递数据"><a href="#传递数据" class="headerlink" title="传递数据"></a>传递数据</h6><p>建立好TCP连接后可以开始向服务器传递数据了。</p><h6 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h6><p>数据传递结束后，我们要关闭连接，也就是要进行四次挥手。</p><p>除了之前接触到的字段外，四次挥手相关的一个字段为FIN，意为要关闭连接。</p><p><img src="/2019/08/12/揭秘输入地址到显示页面背后发生的故事/四次挥手.jpg" alt=""></p><ol><li>首先客户端数据传递完成发起关闭连接请求,FIN=1,seq=x,x等于上一个客户端接收的报文的序号+1</li><li>然后服务端接收到后返回报文ACK=1，seq=k，ack=x+1，告诉客户端序号为x的包我已经接收到了，期待下次接收到x+1序号的包，然后服务端本次的序号是k</li><li>然后服务端可能这时候还有传递一些数据给客户端，客户端虽然发起了关闭连接请求，但是还是可以接收报文，然后服务端此时的序号假设是w，此时服务端数据发送完毕后，发起关闭连接请求，所以FIN=1，然后期待接收到x+1序号到报文（ACK=1，ack=x+1）。</li><li>客户端接收到服务端的关闭连接请求，则告诉服务端我接收到了你的请求ACK=1，然后序号为x+1。</li></ol><p>此时客户端和服务端都关闭了连接。</p><h5 id="服务器响应"><a href="#服务器响应" class="headerlink" title="服务器响应"></a>服务器响应</h5><p>http响应报文详情可以移步<a href="https://zzilcc.github.io/2019/06/16/浏览器缓存详解/" target="_blank" rel="noopener">浏览器缓存详解</a> 里面有关于http响应报文的详细介绍。</p><p>服务器响应和请求差不多，也是进行三次握手，传递数据，然后四次挥手。</p><h4 id="提交文档过程"><a href="#提交文档过程" class="headerlink" title="提交文档过程"></a>提交文档过程</h4><p>网络进程获取到响应数据后会告诉浏览器主进程，主进程会发起提起文档请求给渲染进程，告诉渲染进程可以准备了，渲染进程接收到主进程传递过来的文档信息后，会和网络进程建立一个数据传输通道，网络进程会将响应数据传递给渲染进程，数据传递结束后，渲染进程会告诉浏览器主进程，主进程则开始更新页面。</p><p>所以我们在一个旧页面的地址栏输入一个新地址回车后，旧页面会保持一段时间才会更新为新页面，就是因为在执行这个导航过程。</p><p>到此导航过程结束，下面开始详细介绍渲染过程。</p><h3 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h3><p>渲染流程主要是在渲染进程中去执行，渲染进程中又分了几个线程去实现不同的功能。主要有以下几个线程。</p><h4 id="GUI渲染线程"><a href="#GUI渲染线程" class="headerlink" title="GUI渲染线程"></a>GUI渲染线程</h4><ol><li>负责渲染浏览器界面，包括解析HTML、CSS、构建DOM树、Render树、布局与绘制等</li><li>当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行</li></ol><h4 id="JavaScript引擎线程"><a href="#JavaScript引擎线程" class="headerlink" title="JavaScript引擎线程"></a>JavaScript引擎线程</h4><ol><li>主要负责处理Javascript脚本程序</li><li>等待任务队列的任务的到来，然后加以处理，</li></ol><h4 id="定时触发线程"><a href="#定时触发线程" class="headerlink" title="定时触发线程"></a>定时触发线程</h4><p>setTimeout和setInteval，主要负责浏览器定时和计数。</p><h4 id="事件触发线程"><a href="#事件触发线程" class="headerlink" title="事件触发线程"></a>事件触发线程</h4><p>当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理</p><h4 id="异步请求线程"><a href="#异步请求线程" class="headerlink" title="异步请求线程"></a>异步请求线程</h4><p>使用XMLHttpRequest (XHR)对象可以与服务器交互，XHR发起连接后，浏览器主线程会新开一个异步请求线程，检测到状态变更时，如果设置有回调函数，那么将产生状态变更事件放到任务队列里等待js引擎去处理</p><h4 id="渲染过程详解"><a href="#渲染过程详解" class="headerlink" title="渲染过程详解"></a>渲染过程详解</h4><ol><li>构建 DOM 树。</li><li>构建 CSSOM 树。</li><li>将 DOM 与 CSSOM 合并成一个渲染树。</li><li>根据渲染树来布局，以计算每个节点的几何信息。</li><li>将各个节点绘制到屏幕上。</li></ol><h5 id="构建DOM树"><a href="#构建DOM树" class="headerlink" title="构建DOM树"></a>构建DOM树</h5><p>服务器返回给浏览器的html数据不是我们看到<code>&lt;html&gt;</code>,<code>&lt;body&gt;</code>等，而是一些字节数据，我们需要将这个些字节数据一步步转换成DOM树，转换过程如下：</p><p>Bytes–&gt;Characters–&gt;Tokens–&gt;Nodes–&gt;DOM</p><ol><li>获取到响应数据到字节</li><li>开始解析这些字节，根据文件的指定编码（例如 UTF-8）将它们转换成字符串</li><li>字符串转换成Token，也就是<code>&lt;html&gt;</code>,<code>&lt;body&gt;</code>等，Token中会标识出当前Token是“开始标签”或是“结束标签”亦或是“文本”等信息</li><li>解析token生成节点对象，不是等到所有token都生成后才去生成节点对象，而是生成一个token，就马上生成一个节点对象，带有结束标签标识的Token不会创建节点对象</li><li>遍历节点，构建DOM树</li></ol><p>解析HTML的时候读到引入外部css或js文件，渲染进程会将请求发送到网络进程，由网络进程去下载对应的css文件或js文件。不同的是，如果是js文件，这会阻断HTML的解析，js下载完成后会在js引擎线程立即执行，此时GUI渲染线程会被挂起。如果是css文件的话，不会阻断HTML的解析。</p><p>一个简单的例子</p><p><img src="/2019/08/12/揭秘输入地址到显示页面背后发生的故事/DOM树.jpg" alt=""></p><h5 id="构建CSSOM树"><a href="#构建CSSOM树" class="headerlink" title="构建CSSOM树"></a>构建CSSOM树</h5><p>构建CSSOM树其实和构建DOM很类似。css文件被下载后会开始进行CSSOM构建。</p><p>Bytes–&gt;Characters–&gt;Tokens–&gt;Nodes–&gt;CSSOM</p><p>上面说过构建CSSOM不会阻塞HTML解析，但是如果在js中操作了CSSOM，那么需要等到响应css文件下载并构建CSSOM后，js才会继续执行，在这期间HTML解析会一直被挂起，所以我们在HTML文件引入css，js文件的顺序很重要，css优先，放在头部引入，js滞后，放在页面底部。</p><p>解析HTML的时候，遍历节点时将节点插入到DOM树上，同时去查找css，然后把对应的样式规则应用到元素及节点上，查找样式表是按照从右到左的顺序去匹配的。</p><p>比如： div p {color: #333;}，会先寻找所有p标签并判断它的父标签是否为div之后才会决定要不要采用这个样式进行渲染。</p><p>所以，我们平时写CSS时，尽量用id和class，千万不要过渡层叠。</p><p>一个简单的例子</p><p><img src="/2019/08/12/揭秘输入地址到显示页面背后发生的故事/CSSOM树.jpg" alt=""></p><h5 id="将DOM树和CSSOM树合成渲染树"><a href="#将DOM树和CSSOM树合成渲染树" class="headerlink" title="将DOM树和CSSOM树合成渲染树"></a>将DOM树和CSSOM树合成渲染树</h5><p>浏览器会先从DOM树的根节点开始遍历每个可见节点。可见节点就是display不为none的元素，对每个可见节点，找到其CSS样式规则并应用。</p><p>渲染树和DOM树最大的区别是DOM包括了所有节点，渲染树只包括了可视节点。</p><p>一个简单的例子</p><p><img src="/2019/08/12/揭秘输入地址到显示页面背后发生的故事/渲染树.jpg" alt=""></p><h5 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h5><p>渲染树合成后并不包含元素的位置和大小信息，将其放在浏览器窗口的正确位置。计算这些值的过程称为布局或重排或则回流。比如我们在布局完成后对DOM进行了修改，那么需要重新计算这些值，这个过程就叫做回流或者重排。</p><h5 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h5><p>在绘制阶段，系统会遍历渲染树，将内容显示在屏幕上。同样绘制成功后再对dom进行操作的话，需要重新绘制，也叫做重绘。</p><p>重绘：屏幕的一部分重画，不影响整体布局，比如某个CSS的背景色变了，但元素的几何尺寸和位置不变。</p><p>回流： 意味着元件的几何尺寸变了，我们需要重新验证并计算渲染树。是渲染树的一部分或全部发生了变化。</p><p>一般情况下回流消耗比重绘大，但是不管是回流还是重绘，我们都应该尽量避免。</p><p>下面这些情况会引起回流</p><ol><li>DOM操作，增删查改</li><li>变更内容</li><li>激活伪类</li><li>访问或改变某些CSS属性（包括修改样式表或元素类名或使用JavaScript操作等方式）</li><li>浏览器窗口变化（滚动或尺寸变化）</li></ol><h6 id="如何减少重绘和回流"><a href="#如何减少重绘和回流" class="headerlink" title="如何减少重绘和回流"></a>如何减少重绘和回流</h6><ol><li>减少回流的影响范围，也就是我们元素的样式尽量不要通过父级元素去影响子元素，而是直接加在子元素上</li><li>少用style，多用class</li><li>减少DOM的层级</li><li>避免复杂的css选择器，这样可以减少匹配事件。</li><li>使用 transform 替代 top</li><li>使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局）</li><li>不要把节点的属性值放在一个循环里当成循环里的变量。</li></ol><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="html"><a href="#html" class="headerlink" title="html"></a>html</h3><pre><code>1. 降低dom复杂程度2. meta定义文档编码</code></pre><h3 id="css"><a href="#css" class="headerlink" title="css"></a>css</h3><pre><code>1. 压缩css文件2. 减少元素标签作为对后一个选择对象</code></pre><h3 id="js"><a href="#js" class="headerlink" title="js"></a>js</h3><pre><code>1. 减少用js去操作样式2. 减少定时器的实用，并且不用时要销毁3. 对高频的回调要进行节流和防抖4. 耗时长的代码放到Web Worker中运行</code></pre><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><pre><code>1. 懒加载图片2. 图片压缩处理</code></pre><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><pre><code>1. 减少请求资源大小或者次数　</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/" target="_blank" rel="noopener">https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/</a></li><li><a href="http://www.dailichun.com/2018/03/12/whenyouenteraurl.html" target="_blank" rel="noopener">http://www.dailichun.com/2018/03/12/whenyouenteraurl.html</a></li><li><a href="https://www.cnblogs.com/lanxiansen/p/10972802.html" target="_blank" rel="noopener">https://www.cnblogs.com/lanxiansen/p/10972802.html</a></li><li><a href="https://www.cnblogs.com/lhb25/p/how-browsers-work.html#Painting" target="_blank" rel="noopener">https://www.cnblogs.com/lhb25/p/how-browsers-work.html#Painting</a></li></ol><h2 id="赏"><a href="#赏" class="headerlink" title="赏"></a>赏</h2><p><img src="/2019/08/12/揭秘输入地址到显示页面背后发生的故事/wxZf.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;工作了一年多，发现自己其实学习路线是存在问题的，刚开始学习前端就是直接学习着三个基础HTML，CSS,JavaScript，然后就学习框架vue，然后vue脚手架，vuex，路由，webpack这些。&lt;/p&gt;
&lt;p&gt;从来没有考虑过本质，比如浏览器的运行，渲染机制，浏览器怎么和服务器通行等等。所有的认知都只是停留在表面。&lt;/p&gt;
&lt;p&gt;所以意识到自己的短板后，开始深入学习。&lt;/p&gt;
    
    </summary>
    
      <category term="前端工程化" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
      <category term="http 浏览器" scheme="http://yoursite.com/tags/http-%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>算法题-有效的括号</title>
    <link href="http://yoursite.com/2019/08/06/%E7%AE%97%E6%B3%95%E9%A2%98-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <id>http://yoursite.com/2019/08/06/算法题-有效的括号/</id>
    <published>2019-08-06T12:49:28.000Z</published>
    <updated>2019-08-06T13:26:41.129Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>注意空字符串可被认为是有效字符串。</li></ol><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: &quot;()&quot;</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: &quot;(]&quot;</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">示例 4:</span><br><span class="line">输入: &quot;([)]&quot;</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">示例 5:</span><br><span class="line">输入: &quot;&#123;[]&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>第一种错误思路，开括号(‘{‘,’(‘,’[‘)和闭括号(‘}’,’)’,’]’)分别用两个堆栈去存储，然后再每个弹出来对比是不是一对。但是这样只是对((([[{}])))，()[]{},左右括号刚好分离的，如果是[{}()]这样的就识别不了,所以我们不能先把开括号和闭括号分别分离后再对比，而且两个堆栈空间消耗大，那么能不能用一个堆栈就解决。</p><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>然后就想到遍历字符串的时候，如果是开括号的话就推入栈，然后如果是闭括号的话，就把开括号栈的栈顶的字符推出来，看和闭括号是不是一对，怎么判断是不是一对，我们可以定一个map对象:</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = &#123;</span><br><span class="line"><span class="string">'&#123;'</span>: <span class="string">'&#125;'</span>,</span><br><span class="line"><span class="string">'['</span>: <span class="string">']'</span>,</span><br><span class="line"><span class="string">'('</span>: <span class="string">')'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后如果不是一对的话就返回false，如果是的话就继续遍历，直到遍历完了，如果开括号栈的长大于0，那么就返回false（因为开括号的数量大于闭括号的数量），否则返回true.</p><p>那么我们还要考虑到一个问题就是一开始就是闭括号，那么我们肯定返回false</p><p>还有如果是空串的话，我是直接返回的true。</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; s</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValid = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map = &#123;</span><br><span class="line">        <span class="string">'&#123;'</span>: <span class="string">'&#125;'</span>,</span><br><span class="line">        <span class="string">'['</span>: <span class="string">']'</span>,</span><br><span class="line">        <span class="string">'('</span>: <span class="string">')'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s === <span class="string">''</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> stack1 = [];</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] === <span class="string">'&#125;'</span> || s[<span class="number">0</span>] === <span class="string">']'</span> || s[<span class="number">0</span>] === <span class="string">')'</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> (s.length % <span class="number">2</span> !== <span class="number">0</span> ) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] !== <span class="string">'&#125;'</span> &amp;&amp; s[i] !== <span class="string">']'</span> &amp;&amp; s[i] !== <span class="string">')'</span> ) &#123;</span><br><span class="line">                stack1.push(s[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(map[stack1.pop()] !== s[i] ) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> !stack1.length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是一看感觉代码太多了，能不能再优化一下，把特殊情况不要单独放出来。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>第一个优化，空字符串的情况</p><p>我们其实不用判断是不是空串，因为他不会走for遍历，然后stack1.length就是0，所以会返回true.</p><p>第二个优化就是第一个字符是闭括号或则是闭括号和开括号数量不等情况其实都能在for循环里解决，因为遍历到闭括号时会去比对开括号栈，如果第一个就是闭括号的话，那么开括号栈推出的应该是undefined，肯定不等于闭括号，所以会返回false。</p><p>第三个优化，我判断一个字符是不是开括号是通过<code>if(s[i] !== &#39;}&#39; &amp;&amp; s[i] !== &#39;]&#39; &amp;&amp; s[i] !== &#39;)&#39;)</code>去实现，其实可以写为<code>if (s[i] in map)</code></p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; s</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValid = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map = &#123;</span><br><span class="line">        <span class="string">'&#123;'</span>: <span class="string">'&#125;'</span>,</span><br><span class="line">        <span class="string">'['</span>: <span class="string">']'</span>,</span><br><span class="line">        <span class="string">'('</span>: <span class="string">')'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> stack1 = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] <span class="keyword">in</span> map) &#123;</span><br><span class="line">            stack1.push(s[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(map[stack1.pop()] !== s[i] ) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !stack1.length</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。&lt;/p&gt;
&lt;p&gt;有效字符串需满
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="JavaScript 算法" scheme="http://yoursite.com/tags/JavaScript-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JS实现常用排序算法</title>
    <link href="http://yoursite.com/2019/08/04/JS%E5%AE%9E%E7%8E%B0%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/08/04/JS实现常用排序算法/</id>
    <published>2019-08-04T06:34:15.000Z</published>
    <updated>2019-08-06T03:03:36.653Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们生活中排序无处不在，比如考试结束后，老师需要对学生成绩由高到低进行排序，还有我们排名单时有时候也按照字典序排序等等，下面就介绍几种常用的排序算法及js实现。</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序，顾名思义，就是一个个向上冒泡。具体思想是比较两个相邻的项，如果第一个比第二个大，那么就交换它们。用两层for循环去实现，所以第一次循环后，最大的那个数到达了最右边，下一次循环第二大的数就紧挨着最大的数，以此类推。</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span> (<span class="params">arr, index1, index2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> temp = arr[index1];</span><br><span class="line">arr[index1] = arr[index2];</span><br><span class="line">arr[index2] =temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> len = arr.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">change(arr, j, j+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到冒泡排序的时间复杂度是O(n^2)。所以冒泡排序运行时间相对来说是比较久的。</p><p>比如数组是[2,4,1,6,9,7,5],第一轮循环后数组为[2,1,4,6,7,5,9],第二轮循环后数组为[1,2,4,6,5,7,9],我们知道第一轮循环后，最后一个数肯定是最大的。所以第二轮最后不应该去比较7和9。第三轮也是如此，不应该比较6，7，9。</p><p>所以我们可以改进一下冒泡排序，我们内循环的次数减去外循环中已跑过的轮数。</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> len = arr.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len<span class="number">-1</span>-i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">change(arr, j, j+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们生活中排序无处不在，比如考试结束后，老师需要对学生成绩由高到低进行排序，还有我们排名单时有时候也按照字典序排序等等，下面就介绍几种常用的
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法题-找出所有父节点</title>
    <link href="http://yoursite.com/2019/07/28/%E7%AE%97%E6%B3%95%E9%A2%98-%E6%89%BE%E5%87%BA%E6%89%80%E6%9C%89%E7%88%B6%E8%8A%82%E7%82%B9/"/>
    <id>http://yoursite.com/2019/07/28/算法题-找出所有父节点/</id>
    <published>2019-07-28T07:54:18.000Z</published>
    <updated>2019-08-06T12:50:10.794Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2><p>已知数据格式，实现一个函数 fn 找出链条中所有的父级id</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json = [</span><br><span class="line">&#123;</span><br><span class="line">id: <span class="string">'1'</span>,</span><br><span class="line">name: <span class="string">'广东省'</span>,</span><br><span class="line">children: [</span><br><span class="line">&#123;</span><br><span class="line">id: <span class="string">'11'</span>,</span><br><span class="line">name: <span class="string">'深圳市'</span>,</span><br><span class="line">children: [</span><br><span class="line">&#123;</span><br><span class="line">id: <span class="string">'111'</span>,</span><br><span class="line">name: <span class="string">'福田区'</span>,</span><br><span class="line">children: []</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">id: <span class="string">'112'</span>,</span><br><span class="line">name: <span class="string">'龙华区'</span>,</span><br><span class="line">children: []</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = <span class="string">'112'</span></span><br><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">fn(value) <span class="comment">// 输出 ['1'， '11'， '112']</span></span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="方法一-递归实现深度遍历，并添加path数组，记录父路径"><a href="#方法一-递归实现深度遍历，并添加path数组，记录父路径" class="headerlink" title="方法一 递归实现深度遍历，并添加path数组，记录父路径"></a>方法一 递归实现深度遍历，并添加path数组，记录父路径</h3><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="string">'112'</span>;</span><br><span class="line"><span class="keyword">var</span> fn = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">var</span> stack = json;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">var</span> node = stack.pop();<span class="keyword">debugger</span></span><br><span class="line"><span class="keyword">if</span>(node.children.length) &#123;</span><br><span class="line">stack.push(...node.children.map(<span class="function"><span class="params">x</span>=&gt;</span>(&#123;...x, <span class="attr">path</span>: (node.path || node.id) + <span class="string">'-'</span> + x.id&#125;)))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(node.id === value) &#123;</span><br><span class="line"><span class="keyword">return</span> node.path.split(<span class="string">'-'</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">while</span>(stack.length) </span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line">fn(value) <span class="comment">// 输出 [1， 11， 112]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;算法题&quot;&gt;&lt;a href=&quot;#算法题&quot; class=&quot;headerlink&quot; title=&quot;算法题&quot;&gt;&lt;/a&gt;算法题&lt;/h2&gt;&lt;p&gt;已知数据格式，实现一个函数 fn 找出链条中所有的父级id&lt;/p&gt;
&lt;figure class=&quot;hljs highlight js
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>20190727算法题-两数之和</title>
    <link href="http://yoursite.com/2019/07/27/20190727%E7%AE%97%E6%B3%95%E9%A2%98-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://yoursite.com/2019/07/27/20190727算法题-两数之和/</id>
    <published>2019-07-27T15:02:13.000Z</published>
    <updated>2019-07-28T10:22:50.968Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2><p>给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。</p><p>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。</p><p>示例：</p><p>给定 nums = [2, 7, 11, 15], target = 9</p><p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一-双层for循环"><a href="#方法一-双层for循环" class="headerlink" title="方法一 双层for循环"></a>方法一 双层for循环</h3><p>我们用双层for循环，遍历每个元素el，找到是否有target-el的元素存在数组里，找到则输出索引。</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(nums[i] === target - nums[j] &amp;&amp; i!==j) &#123;</span><br><span class="line"><span class="keyword">return</span> [i, j]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的时间复杂度是 O(n^2)，空间复杂度为O(1)</p><p>很明显，这样的方法耗时太久，不好。</p><h3 id="方法二-利用对象查找"><a href="#方法二-利用对象查找" class="headerlink" title="方法二 利用对象查找"></a>方法二 利用对象查找</h3><p>因为在一个对象里找到是否有某个属性值，时间复杂度为O(1),所以我们可以第一次遍历数组，生成一个对象，然后第二次遍历，去找对象中是否有target-nums[i]的值，有的话返回。这样总的时间复杂度为O(n)，比第一种方法要好一些，只是需要一些内存去存储对象，空间复杂度为O(n),相当于拿空间换时间。</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">obj[nums[i]] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(obj[target - nums[i]] &amp;&amp; i == obj[target - nums[i]]) &#123;</span><br><span class="line"><span class="keyword">return</span> [i, obj[target - nums[i]]]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法三-优化第二种方法"><a href="#方法三-优化第二种方法" class="headerlink" title="方法三 优化第二种方法"></a>方法三 优化第二种方法</h3><p>上面我们执行了两次for循环，我们进行一下优化，在一次循环里解决。第一次循环将数组生成对象时就返回去检查对象里是否有符合target - nums[i]的属性值，有则返回。</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(obj[target - nums[i]] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> [obj[target - nums[i]], i]</span><br><span class="line">&#125;</span><br><span class="line">obj[nums[i]] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;算法题&quot;&gt;&lt;a href=&quot;#算法题&quot; class=&quot;headerlink&quot; title=&quot;算法题&quot;&gt;&lt;/a&gt;算法题&lt;/h2&gt;&lt;p&gt;给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。&lt;/p&gt;
&lt;p&gt;你可以假设每个输入只对应一种答案，且同样的元素不能被重复
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>20190727算法题-降维数组</title>
    <link href="http://yoursite.com/2019/07/27/20190727%E7%AE%97%E6%B3%95%E9%A2%98-%E9%99%8D%E7%BB%B4%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2019/07/27/20190727算法题-降维数组/</id>
    <published>2019-07-27T14:34:40.000Z</published>
    <updated>2019-07-28T10:31:09.624Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法题目："><a href="#算法题目：" class="headerlink" title="算法题目："></a>算法题目：</h2><p>已知如下数组：</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, [<span class="number">11</span>, <span class="number">12</span>, [<span class="number">12</span>, <span class="number">13</span>, [<span class="number">14</span>] ] ] ], <span class="number">10</span>];</span><br></pre></td></tr></table></figure><h3 id="要求1：-将多维数组降成一维数组"><a href="#要求1：-将多维数组降成一维数组" class="headerlink" title="要求1： 将多维数组降成一维数组"></a>要求1： 将多维数组降成一维数组</h3><h4 id="方法一：-es6的flat"><a href="#方法一：-es6的flat" class="headerlink" title="方法一： es6的flat()"></a>方法一： es6的flat()</h4><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.flat(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h4 id="方法二：-投机取巧"><a href="#方法二：-投机取巧" class="headerlink" title="方法二： 投机取巧"></a>方法二： 投机取巧</h4><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.toString().split(<span class="string">','</span>);</span><br></pre></td></tr></table></figure><p>或者</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.join().split(<span class="string">','</span>);</span><br></pre></td></tr></table></figure><h4 id="方法三：-递归"><a href="#方法三：-递归" class="headerlink" title="方法三： 递归"></a>方法三： 递归</h4><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flat</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> result = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_flat</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">value, index</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">_flat(value)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">result.push(value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">_flat(arr)</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">flat(arr)</span><br></pre></td></tr></table></figure><p>简写：</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> flat = <span class="function"><span class="params">arr</span> =&gt;</span> [].concat(...arr.map(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">Array</span>.isArray(v) ? flat(v) : v))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;算法题目：&quot;&gt;&lt;a href=&quot;#算法题目：&quot; class=&quot;headerlink&quot; title=&quot;算法题目：&quot;&gt;&lt;/a&gt;算法题目：&lt;/h2&gt;&lt;p&gt;已知如下数组：&lt;/p&gt;
&lt;figure class=&quot;hljs highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript数据结构</title>
    <link href="http://yoursite.com/2019/07/27/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2019/07/27/JavaScript数据结构/</id>
    <published>2019-07-27T06:26:30.000Z</published>
    <updated>2019-07-27T14:33:09.024Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>想要做一个技术人，数据结构和算法都是必须的，在大学中，最让我头疼的也是这两门课，总觉得脑豁疼，毕业工作后一直想要找时间学习，但是奈何在前公司总是搬砖，做一些简单的工作，现离职后开始找工作，终于抽出时间开始学习数据结构和算法。数据结构和算法对我来说是难以翻越两座大山，但是做人要不断挑战自己，这一篇博客主要是记录一下学习数据结构的成果。</p><p>数据结构按可以分为逻辑结构和物理结构。把数据结构比作人的话，物理结构就是看得见，摸得着的人体，逻辑结构就是人的精神和思想。</p><p>物理结构分为顺序存储结构和链式存储结构。顺序存储结构有数组，链式存储结构有链表。</p><p>逻辑结构分为线性结构和非线性结构。线性结构主要有顺序表，栈，队列。非线性结构主要有树，图。</p><a id="more"></a><h2 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h2><h3 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h3><p>顺序存储结构顾名思义就是数据在内存中是顺序存储。</p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组是最简单的数据结构，它一般来说存储着有限个相同类型的变量，在js中，数组可以保存着不同类型的值，但是不推荐这么用。</p><p>我们知道，内存是由一个个连续的内存单元组成，数组中的每个元素都连续存储在内存中，而且是顺序存储。</p><h5 id="创建和初始化数组"><a href="#创建和初始化数组" class="headerlink" title="创建和初始化数组"></a>创建和初始化数组</h5><p>创建和初始化数组有三种方式，一种是通过构造函数，一种是字面量，最后一种是Array.of()。</p><p>第一种： </p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>) <span class="comment">// 创建一个空数组，数组长度为10</span></span><br><span class="line"><span class="keyword">let</span> arr1 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">'10'</span>) <span class="comment">// 创建了一个数组['10'],数组长度为1</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">'10'</span>,<span class="string">'11'</span>) <span class="comment">// 创建了一个数组['10,11'],长度为2</span></span><br></pre></td></tr></table></figure><p>我们可以看到通过构造函数创建数组时，如果向构造函数传递了一个Number类型的参数，那么会生成一个length为传进来的参数的大小，否则则生成一个包含参数的数组。</p><p>第二种：</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [] <span class="comment">// 创建一个空数组，数组长度为0</span></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="string">'10'</span>] <span class="comment">// 创建了一个数组['10'],数组长度为1</span></span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="string">'10,11'</span>] <span class="comment">// 创建了一个数组['10,11'],长度为2</span></span><br></pre></td></tr></table></figure><p>第二种方法是字面量方法，直接通过‘[]’创建数组。</p><p>第三种是新增的方法</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.of() <span class="comment">// 创建一个空数组，数组长度为0</span></span><br><span class="line"><span class="keyword">let</span> arr1 = <span class="built_in">Array</span>.of(<span class="string">'10'</span>) <span class="comment">// 创建了一个数组['10'],数组长度为1</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.of(<span class="string">'10'</span>,<span class="string">'11'</span>) <span class="comment">// 创建了一个数组['10,11'],长度为2</span></span><br></pre></td></tr></table></figure><h5 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h5><p>我们通过元素下标访问元素数组。数组第一个元素的下标为0，最后一个为length-1。</p><h5 id="添加和删除数组元素"><a href="#添加和删除数组元素" class="headerlink" title="添加和删除数组元素"></a>添加和删除数组元素</h5><h6 id="添加元素到数组首位–unshift"><a href="#添加元素到数组首位–unshift" class="headerlink" title="添加元素到数组首位–unshift()"></a>添加元素到数组首位–unshift()</h6><p>语法： arrayObject.unshift(item)</p><p>参数： item： 要插入到首位的元素</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr.unshift(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr)<span class="comment">// [0, 1, 2, 3]</span></span><br></pre></td></tr></table></figure><h6 id="删除数组首位元素–shift"><a href="#删除数组首位元素–shift" class="headerlink" title="删除数组首位元素–shift()"></a>删除数组首位元素–shift()</h6><p>语法： arrayObject.shift()</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr.shift()</span><br><span class="line"><span class="built_in">console</span>.log(arr)<span class="comment">// [2, 3]</span></span><br></pre></td></tr></table></figure><h6 id="添加元素到数组末尾–push"><a href="#添加元素到数组末尾–push" class="headerlink" title="添加元素到数组末尾–push()"></a>添加元素到数组末尾–push()</h6><p>语法： arrayObject.push(item)</p><p>参数： item： 要插入到末位的元素</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr.push(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr)<span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>####### 删除数组末尾元素–pop()</p><p>语法： arrayObject.pop()</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr.pop()</span><br><span class="line"><span class="built_in">console</span>.log(arr)<span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure><h6 id="添加-删除元素到数组任意位置–splice"><a href="#添加-删除元素到数组任意位置–splice" class="headerlink" title="添加/删除元素到数组任意位置–splice()"></a>添加/删除元素到数组任意位置–splice()</h6><p>语法： arrayObject.splice(index,howmany,item1,…..,itemX)</p><p>参数： </p><ol><li>index：必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。</li><li>howmany：必需。要删除的项目数量。如果设置为 0，则不会删除项目。</li><li>item1,…..,itemX：可选。向数组添加的新项目。</li></ol><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr)<span class="comment">// [1, 5, 5, 2, 3]</span></span><br></pre></td></tr></table></figure><h5 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h5><p>上面我们已经接触了5个方法了。下面将介绍一下数组的其他的方法。</p><h6 id="concat-连接数组"><a href="#concat-连接数组" class="headerlink" title="concat 连接数组"></a>concat 连接数组</h6><p>连接两个及以上的数组，并返回一个新数组，不会影响旧数组</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.concat(arr2);</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// [1, 2, 3, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><h6 id="every-返回值是boolean"><a href="#every-返回值是boolean" class="headerlink" title="every 返回值是boolean"></a>every 返回值是boolean</h6><p>对数组中的每个元素运行一个函数，如果每个元素运行该函数返回为true，则为true。</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.every(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, arrObj</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> item &gt; <span class="number">0</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>该函数接收三个参数，item是当前元素，index是该元素的下标，arrObj是执行every方法的数组。</p><h6 id="some-返回值是boolean"><a href="#some-返回值是boolean" class="headerlink" title="some 返回值是boolean"></a>some 返回值是boolean</h6><p>对数组中的每个元素运行一个函数，如果每个元素运行该函数有一个返回为true，则为true。</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.some(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, arrObj</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> item &gt; <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// true</span></span><br></pre></td></tr></table></figure><h6 id="map-返回新数组"><a href="#map-返回新数组" class="headerlink" title="map 返回新数组"></a>map 返回新数组</h6><p>对数组中的每个元素运行一个函数，每次调用该函数的结果组成新数组返回</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, arrObj</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> item * <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure><h6 id="filter-过滤元素，返回新数组"><a href="#filter-过滤元素，返回新数组" class="headerlink" title="filter 过滤元素，返回新数组"></a>filter 过滤元素，返回新数组</h6><p>对数组中的每个元素运行一个函数，每次调用该函数的返回值为true的元素组成新数组返回</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, arrObj</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> item &gt; <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// [3]</span></span><br></pre></td></tr></table></figure><h6 id="forEach-无返回值"><a href="#forEach-无返回值" class="headerlink" title="forEach 无返回值"></a>forEach 无返回值</h6><p>对数组中的每个元素运行一个函。</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">// 某些操作</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h6 id="slice-截取数组，返回新数组"><a href="#slice-截取数组，返回新数组" class="headerlink" title="slice 截取数组，返回新数组"></a>slice 截取数组，返回新数组</h6><p>传入索引值(start, end)，将数组里对应索引范围内(包含start，不包含end)的元素组成新数组返回</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.slice(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// [1]</span></span><br></pre></td></tr></table></figure><h6 id="sort-排序数组，影响arr数组"><a href="#sort-排序数组，影响arr数组" class="headerlink" title="sort 排序数组，影响arr数组"></a>sort 排序数组，影响arr数组</h6><p>按照字母顺序对数组排序，支持指定的排序函数当作参数</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.sort();</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// [1, 2, 2, 3, 3, 4]</span></span><br></pre></td></tr></table></figure><h6 id="reverse-颠倒数组，影响arr数组"><a href="#reverse-颠倒数组，影响arr数组" class="headerlink" title="reverse 颠倒数组，影响arr数组"></a>reverse 颠倒数组，影响arr数组</h6><p>颠倒数组，原先第一位元素变成最后一位，第二位变成倒数第二位，以此类推。</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.reverse();</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// [3, 2, 1]</span></span><br></pre></td></tr></table></figure><h6 id="indexOf-返回第一个与给定参数相等的元素的下标，没有返回-1"><a href="#indexOf-返回第一个与给定参数相等的元素的下标，没有返回-1" class="headerlink" title="indexOf 返回第一个与给定参数相等的元素的下标，没有返回-1"></a>indexOf 返回第一个与给定参数相等的元素的下标，没有返回-1</h6><p>从数组的第一个元素开始匹配，匹配成功则返回下标</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.indexOf(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h6 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf"></a>lastIndexOf</h6><p>从数组的最后一个元素开始匹配，匹配成功则返回下标，没有匹配成功返回-1</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.lastIndexOf(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h6 id="join-将所有元素拼接成字符串"><a href="#join-将所有元素拼接成字符串" class="headerlink" title="join 将所有元素拼接成字符串"></a>join 将所有元素拼接成字符串</h6><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.join();</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// "1,2,3"</span></span><br></pre></td></tr></table></figure><h6 id="toString-将所有元素拼接成字符串"><a href="#toString-将所有元素拼接成字符串" class="headerlink" title="toString 将所有元素拼接成字符串"></a>toString 将所有元素拼接成字符串</h6><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.toString();</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// "1,2,3"</span></span><br></pre></td></tr></table></figure><h6 id="reduce-累加"><a href="#reduce-累加" class="headerlink" title="reduce 累加"></a>reduce 累加</h6><p>reduce对元素的每一项运行一个函数，这个函数接收四个参数，preV前一个元素的值，curV当前元素值，index当前元素的下标，arrObj，执行reduce函数的数组。</p><p>reduce会返回数组每一项的累加值。</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">preV, curV, index, arrObj</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> preV + curV</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">//6  1+2+3=6</span></span><br></pre></td></tr></table></figure><h6 id="copyWithin-复制数组的某个范围的元素到同一个数组指定的起始位置"><a href="#copyWithin-复制数组的某个范围的元素到同一个数组指定的起始位置" class="headerlink" title="copyWithin 复制数组的某个范围的元素到同一个数组指定的起始位置"></a>copyWithin 复制数组的某个范围的元素到同一个数组指定的起始位置</h6><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.copyWithin(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// [1, 1, 3]</span></span><br></pre></td></tr></table></figure><p>copyWithin接收三个参数，第一个参数值指定元素放的起始位置，第二个，第三个参数分别是复制元素的起始位置和结束位置。</p><p>复制的元素包括开始位置的元素，不包括结束位置的元素。</p><h6 id="entries-返回包含数组所有键值对的-iterator"><a href="#entries-返回包含数组所有键值对的-iterator" class="headerlink" title="entries 返回包含数组所有键值对的 @@iterator"></a>entries 返回包含数组所有键值对的 @@iterator</h6><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.entries();</span><br><span class="line"><span class="built_in">console</span>.log(res.next().value)<span class="comment">// [0, 1] 0是下标，1时该下标对应的元素</span></span><br></pre></td></tr></table></figure><h6 id="includes-检测数组是否包含某个值"><a href="#includes-检测数组是否包含某个值" class="headerlink" title="includes 检测数组是否包含某个值"></a>includes 检测数组是否包含某个值</h6><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.include(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// true</span></span><br></pre></td></tr></table></figure><h6 id="find-数组每一项运行一个给定的函数，如果运行返回true，则返回这个元素"><a href="#find-数组每一项运行一个给定的函数，如果运行返回true，则返回这个元素" class="headerlink" title="find 数组每一项运行一个给定的函数，如果运行返回true，则返回这个元素"></a>find 数组每一项运行一个给定的函数，如果运行返回true，则返回这个元素</h6><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.find(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> item &gt; <span class="number">1</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h6 id="findIndex-数组每一项运行一个给定的函数，如果运行返回true，则返回这个元素的下标"><a href="#findIndex-数组每一项运行一个给定的函数，如果运行返回true，则返回这个元素的下标" class="headerlink" title="findIndex 数组每一项运行一个给定的函数，如果运行返回true，则返回这个元素的下标"></a>findIndex 数组每一项运行一个给定的函数，如果运行返回true，则返回这个元素的下标</h6><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.findIndex(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> item &gt; <span class="number">1</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h6 id="fill-用静态值填充数组"><a href="#fill-用静态值填充数组" class="headerlink" title="fill 用静态值填充数组"></a>fill 用静态值填充数组</h6><p>fill函数接收三个参数，填充值（必须），开始位置，结束位置</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.fill(<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// [2, 3, 3]</span></span><br></pre></td></tr></table></figure><h6 id="from-从一个类似数组或可迭代对象中创建一个新的，浅拷贝的数组实例"><a href="#from-从一个类似数组或可迭代对象中创建一个新的，浅拷贝的数组实例" class="headerlink" title="from 从一个类似数组或可迭代对象中创建一个新的，浅拷贝的数组实例"></a>from 从一个类似数组或可迭代对象中创建一个新的，浅拷贝的数组实例</h6><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(<span class="string">"foo"</span>);<span class="comment">//['f', 'o', 'o']</span></span><br></pre></td></tr></table></figure><p>Array.from这个方法接收三个参数，第一个是要转换成数组的类数组对象，第二个是新数组的每一项都会运行的函数，第三个参数this</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = <span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], x =&gt; x*<span class="number">2</span>);<span class="comment">//[2, 4, 6]</span></span><br></pre></td></tr></table></figure><h6 id="values-包含数组所有值的-iterator"><a href="#values-包含数组所有值的-iterator" class="headerlink" title="values 包含数组所有值的@@iterator"></a>values 包含数组所有值的@@iterator</h6><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> res = arr.values().next().value <span class="comment">// 1</span></span><br><span class="line">arr.values().next().value <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h6 id="key-包含数组所有下标的-iterator"><a href="#key-包含数组所有下标的-iterator" class="headerlink" title="key 包含数组所有下标的@@iterator"></a>key 包含数组所有下标的@@iterator</h6><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> res = arr.keys().next().value <span class="comment">// 0</span></span><br><span class="line">arr.values().next().value <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h6 id="flat-降维数组"><a href="#flat-降维数组" class="headerlink" title="flat 降维数组"></a>flat 降维数组</h6><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]], <span class="number">3</span>];</span><br><span class="line">arr.flat(<span class="number">1</span>) <span class="comment">// [1, 2, [3, [4, 5]], 3]</span></span><br><span class="line">arr.flat(<span class="number">2</span>) <span class="comment">// [1, 2, 3, [4, 5], 3]</span></span><br><span class="line">arr.flat(<span class="number">3</span>) <span class="comment">// [1, 2, 3, 4, 5, 3]</span></span><br></pre></td></tr></table></figure><p>flat函数接收一个参数，要提取嵌套数组的结构深度，默认值为 1。</p><h6 id="flatMap-包含数组所有下标的-iterator"><a href="#flatMap-包含数组所有下标的-iterator" class="headerlink" title="flatMap 包含数组所有下标的@@iterator"></a>flatMap 包含数组所有下标的@@iterator</h6><p>它与 map 和 深度值1的 flat 几乎相同</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">arr1.map(<span class="function"><span class="params">x</span> =&gt;</span> [x * <span class="number">2</span>]); </span><br><span class="line"><span class="comment">// [[2], [4], [6], [8]]</span></span><br><span class="line">arr1.flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [x * <span class="number">2</span>]);</span><br><span class="line"><span class="comment">// [2, 4, 6, 8]</span></span><br><span class="line"><span class="comment">// 只会将 flatMap 中的函数返回的数组 “压平” 一层</span></span><br><span class="line">arr1.flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [[x * <span class="number">2</span>]]);</span><br><span class="line"><span class="comment">// [[2], [4], [6], [8]]</span></span><br></pre></td></tr></table></figure><h3 id="链式储存结构"><a href="#链式储存结构" class="headerlink" title="链式储存结构"></a>链式储存结构</h3><p>数组的大小是固定，我们向数组的首部或者中间插入或者删除元素的成本很高，因为要移动元素。链式存储结构就很好的解决了这个问题，因为链式存储结构的元素不是连续存放在内存中。</p><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>链表就是一种很常见的链式存储结构，链表中的每个元素由一个存储数据的节点和指向下一个元素的指针。因此向链表中添加和删除元素是速度很快的，只要改变一下元素的指向，而不需要移动元素。</p><p>下面我们用js去实现一个链表结构</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkList</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> node = <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.el = el;</span><br><span class="line"><span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> head = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 链表的常用操作</span></span><br><span class="line"><span class="keyword">this</span>.append = <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;&#125;; <span class="comment">// 向链表尾部添加新的元素</span></span><br><span class="line"><span class="keyword">this</span>.insert = <span class="function"><span class="keyword">function</span> (<span class="params">position, el</span>) </span>&#123;&#125;; <span class="comment">// 向链表的特定的位置添加一个元素</span></span><br><span class="line"><span class="keyword">this</span>.removeAt = <span class="function"><span class="keyword">function</span> (<span class="params">position</span>) </span>&#123;&#125;; <span class="comment">// 删掉指定位置的元素</span></span><br><span class="line"><span class="keyword">this</span>.remove = <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;&#125;; <span class="comment">// 删除元素</span></span><br><span class="line"><span class="keyword">this</span>.indexOf = <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;&#125;; <span class="comment">//返回指定元素的索引，没有这返回-1</span></span><br><span class="line"><span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 判断是否是空链表</span></span><br><span class="line"><span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;; <span class="comment">//  返回链表长度</span></span><br><span class="line"><span class="keyword">this</span>.getHead = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 返回链表头部</span></span><br><span class="line"><span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 输出元素值</span></span><br><span class="line"><span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 输出链表元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><h3 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h3><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>栈是一个有序集合，并且遵循着先进后出，后进先出的原则。元素出去或者是进来的地方叫做栈顶，另一端是栈底。</p><p>下面上代码</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> items = [];</span><br><span class="line"><span class="keyword">this</span>.push = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123; <span class="comment">// 添加一个元素</span></span><br><span class="line">items.push(element);</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">this</span>.pop = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 移除栈顶的元素，同时返回被移除的元素</span></span><br><span class="line">items.pop();</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 判断栈是否空，为空返回true，否则返回false</span></span><br><span class="line"><span class="keyword">if</span>(items.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 移除栈里的元素</span></span><br><span class="line">items = []</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 返回栈的元素个数。</span></span><br><span class="line"><span class="keyword">return</span> items.length;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 输出栈</span></span><br><span class="line"><span class="keyword">return</span> items</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>队列是一组有序的项，遵守先进先出，后进后出的原则。比较常见的例子是打印机的打印队列，先发起的打印请求肯定先打印，后发起的请求后打印。</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> items = [];</span><br><span class="line"><span class="keyword">this</span>.enqueue = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123; <span class="comment">// 添加一个元素</span></span><br><span class="line">items.push(element);</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">this</span>.dequeue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 移除队列头部的元素，同时返回被移除的元素</span></span><br><span class="line">items.shift();</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 判断队列是否空，为空返回true，否则返回false</span></span><br><span class="line"><span class="keyword">if</span>(items.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 移除队列里的元素</span></span><br><span class="line">items = []</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 返回队列的元素个数。</span></span><br><span class="line"><span class="keyword">return</span> items.length;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 输出队列</span></span><br><span class="line"><span class="keyword">return</span> items</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非线性结构"><a href="#非线性结构" class="headerlink" title="非线性结构"></a>非线性结构</h3><h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><h4 id="图"><a href="#图" class="headerlink" title="图"></a>图</h4>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;想要做一个技术人，数据结构和算法都是必须的，在大学中，最让我头疼的也是这两门课，总觉得脑豁疼，毕业工作后一直想要找时间学习，但是奈何在前公司总是搬砖，做一些简单的工作，现离职后开始找工作，终于抽出时间开始学习数据结构和算法。数据结构和算法对我来说是难以翻越两座大山，但是做人要不断挑战自己，这一篇博客主要是记录一下学习数据结构的成果。&lt;/p&gt;
&lt;p&gt;数据结构按可以分为逻辑结构和物理结构。把数据结构比作人的话，物理结构就是看得见，摸得着的人体，逻辑结构就是人的精神和思想。&lt;/p&gt;
&lt;p&gt;物理结构分为顺序存储结构和链式存储结构。顺序存储结构有数组，链式存储结构有链表。&lt;/p&gt;
&lt;p&gt;逻辑结构分为线性结构和非线性结构。线性结构主要有顺序表，栈，队列。非线性结构主要有树，图。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="javaScript" scheme="http://yoursite.com/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript的三种编程范式比较</title>
    <link href="http://yoursite.com/2019/07/23/JavaScript%E7%9A%84%E4%B8%89%E7%A7%8D%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E6%AF%94%E8%BE%83/"/>
    <id>http://yoursite.com/2019/07/23/JavaScript的三种编程范式比较/</id>
    <published>2019-07-23T13:17:58.000Z</published>
    <updated>2019-07-23T15:26:59.215Z</updated>
    
    <content type="html"><![CDATA[<h2 id="过程式编程"><a href="#过程式编程" class="headerlink" title="过程式编程"></a>过程式编程</h2><p>也就是从上至下，流水般的实现功能。</p><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;过程式编程&quot;&gt;&lt;a href=&quot;#过程式编程&quot; class=&quot;headerlink&quot; title=&quot;过程式编程&quot;&gt;&lt;/a&gt;过程式编程&lt;/h2&gt;&lt;p&gt;也就是从上至下，流水般的实现功能。&lt;/p&gt;
&lt;h2 id=&quot;函数式编程&quot;&gt;&lt;a href=&quot;#函数式编程&quot; clas
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="编程范式" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>js实现树的深度优先遍历和广度优先遍历</title>
    <link href="http://yoursite.com/2019/07/19/js%E5%AE%9E%E7%8E%B0%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
    <id>http://yoursite.com/2019/07/19/js实现树的深度优先遍历和广度优先遍历/</id>
    <published>2019-07-19T06:57:15.000Z</published>
    <updated>2019-07-19T07:54:21.202Z</updated>
    
    <content type="html"><![CDATA[<h2 id="树数据结构的介绍"><a href="#树数据结构的介绍" class="headerlink" title="树数据结构的介绍"></a>树数据结构的介绍</h2><p>数据结构可以分为顺序数据结构和非顺序结构。顺序数据结构是指把数据元素放在地址连续的存储单元里。非顺序结构可以把数据元素任意放在连续或者不连续的存储单元里。</p><p>树是一种非顺序数据结构。族谱，公司里的组织结构都可以看成是树模型。</p><p>树结构是包含一个根节点，还有内部节点，叶子节点。根节点是位于树的顶部。叶子节点是没有后代的节点。内部节点是除了根节点和叶子节点外的所有节点。一个节点可以有祖先和后代。根节点没有祖先。</p><p>节点的深度是节点的祖先节点数。</p><p>树的高度是所有节点深度中的最大的深度。</p><p>树可以分层级，根节点在第零层，它的子节点是第一层，依次类推。</p><p><img src="/2019/07/19/js实现树的深度优先遍历和广度优先遍历/tree.jpg" alt=""></p><h2 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h2><h2 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h2><h2 id="js实现两种方式的遍历"><a href="#js实现两种方式的遍历" class="headerlink" title="js实现两种方式的遍历"></a>js实现两种方式的遍历</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;树数据结构的介绍&quot;&gt;&lt;a href=&quot;#树数据结构的介绍&quot; class=&quot;headerlink&quot; title=&quot;树数据结构的介绍&quot;&gt;&lt;/a&gt;树数据结构的介绍&lt;/h2&gt;&lt;p&gt;数据结构可以分为顺序数据结构和非顺序结构。顺序数据结构是指把数据元素放在地址连续的存储单元里
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="树的遍历" scheme="http://yoursite.com/tags/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>Vue Router学习（一）</title>
    <link href="http://yoursite.com/2019/07/02/Vue-Router%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2019/07/02/Vue-Router学习（一）/</id>
    <published>2019-07-02T01:41:48.000Z</published>
    <updated>2019-07-27T09:08:49.890Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="单页应用-vs-多页应用"><a href="#单页应用-vs-多页应用" class="headerlink" title="单页应用 vs 多页应用"></a>单页应用 vs 多页应用</h3><p><img src="/2019/07/02/Vue-Router学习（一）/blog.png" alt=""></p><p>以我的博客为例，很多网站会有这样的布局，头部会有一个导航栏，每次点击页面会切换。</p><p>如果是多页应用MPA（Mutiple Page Application）的话，就是每一个导航是一个html，比如我的博客，导航里有5项，那么就有5个html，每次点击，都进行了html切换，每次都要加载新的html。</p><p>如果是单页应用，就只有一个html，没有导航切换的时候只是切换html页面内容，不会切换html。</p><a id="more"></a><h4 id="多页应用"><a href="#多页应用" class="headerlink" title="多页应用"></a>多页应用</h4><p>多页应用的优点是首次页面加载时间快，SEO效果好，缺点是页面切换慢。</p><p>因为多页应用是把系统分成很多个html，所以每次加载只加载了一个html，所以首次页面加载快。</p><p>SEO指搜索引擎优化，它是一种通过分析搜索引擎的排名规律，了解各种搜索引擎怎样进行搜索、怎样抓取互联网页面、怎样确定特定关键词的搜索结果排名的技术。</p><p>多页应用的内容基本都是直接写在html页面，这样搜索引擎就比较好好识别，所以seo排名效果好。</p><p>页面切换慢的原因是因为没有切换页面，都要重新请求html，相当于重新渲染页面，渲染整颗DOM树。</p><h4 id="单页应用"><a href="#单页应用" class="headerlink" title="单页应用"></a>单页应用</h4><blockquote><p>单页Web应用（single page web application，SPA）无疑是目前网站开发技术的弄潮儿，很多传统网站都在或者已经转型为单页Web应用       —《单页Web应用：JavaScript从前端到后端》</p></blockquote><p>单页应用相对于多页应用，比较明显的优点就是切换页面时间比较快，因为单页应用切换不需要重新请求html，它只是重新渲染dom树的其中一部分。但是因为单页应用把所有的内容都放到一个html里，所以他的首次加载页面时间会相对来说比较慢，要加载的内容比较多，而且一般单页应用的内容主要通过js去切换渲染，所以内容都是动态生成，不是直接写在html里，所以seo效果比较差。</p><p>搭建一个项目的时候到底是用多页面还是单页，这需要根据具体情况去分析。</p><h2 id="Vue-Router是什么？"><a href="#Vue-Router是什么？" class="headerlink" title="Vue Router是什么？"></a>Vue Router是什么？</h2><p>官方解释什么是Vue Router</p><p>Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。包含的功能有：</p><ol><li>嵌套的路由/视图表</li><li>模块化的、基于组件的路由配置</li><li>路由参数、查询、通配符</li><li>基于 Vue.js 过渡系统的视图过渡效果</li><li>细粒度的导航控制</li><li>带有自动激活的 CSS class 的链接</li><li>HTML5 历史模式或 hash 模式，在 IE9 中自动降级</li><li>自定义的滚动条行为</li></ol><h2 id="为什么要用Vue-Router？"><a href="#为什么要用Vue-Router？" class="headerlink" title="为什么要用Vue Router？"></a>为什么要用Vue Router？</h2><p>在单页应用中所有的东西都在一个html页面中，我们进行页面切换需要用到路由。</p><h2 id="怎么用Vue-Router？"><a href="#怎么用Vue-Router？" class="headerlink" title="怎么用Vue Router？"></a>怎么用Vue Router？</h2><h3 id="一个简单的单页面应用"><a href="#一个简单的单页面应用" class="headerlink" title="一个简单的单页面应用"></a>一个简单的单页面应用</h3><p>下面介绍的是vue-cli2.0下怎么用Vue Router</p><p> 首先我们先安装一下vue-cli2.0</p><p> <img src="/2019/07/02/Vue-Router学习（一）/vue-init.jpg" alt=""></p><p> 可以看到，我们安装vue-cli 模版的时候可以选择安不安装Vue-Router，在这边我们选择yes。</p><p> 项目创建完成后我们看下<code>src\main.js</code></p> <figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// The Vue build version to load with the `import` command</span></span><br><span class="line"><span class="comment">// (runtime-only or standalone) has been set in webpack.base.conf with an alias.</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span> <span class="comment">// 引入了路由</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router, <span class="comment">// 使用路由</span></span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: <span class="string">'&lt;App/&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>首先我们把<code>src\App.vue</code>这个文件加上一个导航nav</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> &lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;./assets/logo.png&quot;&gt;</span><br><span class="line">    &lt;nav&gt;</span><br><span class="line">      &lt;router-link class=&quot;fd-header-item&quot; to=&quot;/&quot;&gt;Home&lt;/router-link&gt;</span><br><span class="line">      &lt;router-link class=&quot;fd-header-item&quot; to=&quot;/achives&quot;&gt;Achives&lt;/router-link&gt;</span><br><span class="line">      &lt;router-link class=&quot;fd-header-item&quot; to=&quot;/categories&quot;&gt;Categories&lt;/router-link&gt;</span><br><span class="line">      &lt;router-link class=&quot;fd-header-item&quot; to=&quot;/tags&quot;&gt;Tags&lt;/router-link&gt;</span><br><span class="line">      &lt;router-link class=&quot;fd-header-item&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;</span><br><span class="line">    &lt;/nav&gt;</span><br><span class="line">    &lt;router-view/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;App&apos;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">#app &#123;</span><br><span class="line">  font-family: &apos;Avenir&apos;, Helvetica, Arial, sans-serif;</span><br><span class="line">  -webkit-font-smoothing: antialiased;</span><br><span class="line">  -moz-osx-font-smoothing: grayscale;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: #2c3e50;</span><br><span class="line">  margin-top: 60px;</span><br><span class="line">&#125;</span><br><span class="line">.fd-header-item &#123;</span><br><span class="line">  cursor: pointer;</span><br><span class="line">&#125;</span><br><span class="line">.fd-header-item:hover, .router-link-exact-active&#123;</span><br><span class="line">  color: aqua;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>我们可以看到两个比较特殊的标签<code>&lt;router-link&gt;&lt;/router-link&gt;</code>，<code>&lt;router-view/&gt;</code></p><p><code>&lt;router-link&gt;</code>主要是用来做页面跳转的，一般写导航，<code>&lt;router-link&gt;</code>里的组件会渲染到<code>&lt;router-view/&gt;</code></p><p>我们一个导航项创建一个组件，所以我们在<code>src\components\</code>下创建五个组件，分别是home.vue, achives.vue, categories.vue, tags.vue, about.vue</p><p>Vue Router 给我们设置了高亮的样式<code>router-link-exact-active</code>，所以我们可以设置一个选中颜色。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.fd-header-item:hover, .router-link-exact-active&#123;</span><br><span class="line">  color: aqua;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>router-link里的to参数代表着你要跳转的路径，我们可以看下<code>src\Router\index.js</code></p><p>在这个js中我们引入了这五个组件，然后写了它们相应的路由</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> home <span class="keyword">from</span> <span class="string">'@/components/home'</span></span><br><span class="line"><span class="keyword">import</span> achives <span class="keyword">from</span> <span class="string">'@/components/achives'</span></span><br><span class="line"><span class="keyword">import</span> categories <span class="keyword">from</span> <span class="string">'@/components/categories'</span></span><br><span class="line"><span class="keyword">import</span> tags <span class="keyword">from</span> <span class="string">'@/components/tags'</span></span><br><span class="line"><span class="keyword">import</span> about <span class="keyword">from</span> <span class="string">'@/components/about'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      name: <span class="string">'home'</span>,</span><br><span class="line">      component: home</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/achives'</span>,</span><br><span class="line">      name: <span class="string">'achives'</span>,</span><br><span class="line">      component: achives</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/categories'</span>,</span><br><span class="line">      name: <span class="string">'categories'</span>,</span><br><span class="line">      component: categories</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/tags'</span>,</span><br><span class="line">      name: <span class="string">'tags'</span>,</span><br><span class="line">      component: tags</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/about'</span>,</span><br><span class="line">      name: <span class="string">'about'</span>,</span><br><span class="line">      component: about</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们看下这个home.vue,在点击home时我们显示I am Home ，其他几个页面相应的会输出。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;hello&quot;&gt;</span><br><span class="line">    &#123;&#123;msg&#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;home&apos;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &apos;I am Home&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p><img src="/2019/07/02/Vue-Router学习（一）/vueRouter1.jpg" alt=""></p><p>到此一个简单单页面应用的基本框架就算搭好了。在此之中我们接触到了三个很类似的单词：route，routes，router。</p><p>route他是一条路由，比如home这个a标签链接指向home页面的内容。</p><p>routes是一组路由，也就是由route组成的一组数组</p><p>router是一个机制，路由机制。</p><h3 id="多级导航（嵌套路由）"><a href="#多级导航（嵌套路由）" class="headerlink" title="多级导航（嵌套路由）"></a>多级导航（嵌套路由）</h3><h4 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h4><p>现在在Achives导航下有两个二级导航achives1和achives2，点击Achives1和Achives2分别跳转到相应的页面。</p><h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><ol><li>在src/component下创建两个子页面achives1.vu和achives2.vue</li><li>在src/router/index.js里配置子路由</li><li>在archives.vue写上<code>&lt;router-view/&gt;</code></li><li>在App.vue里写Achives点击事件，点击后出现二级导航</li></ol><h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><p>创建了两个子页面</p><p><img src="/2019/07/02/Vue-Router学习（一）/子页面.jpg" alt=""></p><p>achives1.vue页面如下</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;hello&quot;&gt;</span><br><span class="line">    &#123;&#123;msg&#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;achives1&apos;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &apos;I am Achives1&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>src/router/index.js</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: <span class="string">'/achives'</span>,</span><br><span class="line">  component: achives,</span><br><span class="line">  children: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'achives1'</span>,</span><br><span class="line">      component: achives1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'achives2'</span>,</span><br><span class="line">      component: achives2</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们在achives的路由中加了一个children属性,这个属性是一个数组，然后有两项，也就是我们的两个子页面的路由，相应的path是路径，component是组件，所以我们要在src/router/index.js里引入这两个组件</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> achives1 <span class="keyword">from</span> <span class="string">'@/components/achives1'</span></span><br><span class="line"><span class="keyword">import</span> achives2 <span class="keyword">from</span> <span class="string">'@/components/achives2'</span></span><br></pre></td></tr></table></figure><p>在父页面achives.vue</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;hello&quot;&gt;</span><br><span class="line">    &#123;&#123;msg&#125;&#125;</span><br><span class="line">   &lt;router-view/&gt; // 新增的</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;achives&apos;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &apos;I am Achives&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>最后我们只要在App.vue添加相应的点击事件和router-link</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>《单页Web应用：JavaScript从前端到后端》</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h3 id=&quot;单页应用-vs-多页应用&quot;&gt;&lt;a href=&quot;#单页应用-vs-多页应用&quot; class=&quot;headerlink&quot; title=&quot;单页应用 vs 多页应用&quot;&gt;&lt;/a&gt;单页应用 vs 多页应用&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/2019/07/02/Vue-Router学习（一）/blog.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;以我的博客为例，很多网站会有这样的布局，头部会有一个导航栏，每次点击页面会切换。&lt;/p&gt;
&lt;p&gt;如果是多页应用MPA（Mutiple Page Application）的话，就是每一个导航是一个html，比如我的博客，导航里有5项，那么就有5个html，每次点击，都进行了html切换，每次都要加载新的html。&lt;/p&gt;
&lt;p&gt;如果是单页应用，就只有一个html，没有导航切换的时候只是切换html页面内容，不会切换html。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue vue-Router" scheme="http://yoursite.com/tags/vue-vue-Router/"/>
    
  </entry>
  
  <entry>
    <title>浏览器缓存详解</title>
    <link href="http://yoursite.com/2019/06/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/06/16/浏览器缓存详解/</id>
    <published>2019-06-16T14:00:23.000Z</published>
    <updated>2019-07-28T10:40:39.864Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>可能有人会和以前的我一样，觉得缓存不是后台设置的吗，感觉和前端人员没有太大联系，平时关于缓存最常做的就是在浏览器<code>Ctrl+Shit+Delete</code>清空缓存。</p><p>web缓存可以大致分为三类：</p><pre><code>1. 浏览器缓存2. 代理缓存3. 网关缓存</code></pre><p>我们这篇文章主要讲的是浏览器缓存，浏览器主要是通过http/https和服务器进行通信，所以浏览器缓存我们也可以说是HTTP缓存。<br><a id="more"></a></p><h2 id="二、什么是浏览器缓存"><a href="#二、什么是浏览器缓存" class="headerlink" title="二、什么是浏览器缓存"></a>二、什么是浏览器缓存</h2><blockquote><p>浏览器缓存（Browser Caching）是为了节约网络的资源加速浏览，浏览器在用户磁盘上对最近请求过的文档进行存储，当访问者再次请求这个页面时，浏览器就可以从本地磁盘显示文档，这样就可以加速页面的阅览。-百度百科</p></blockquote><p>缓存了的文档应该怎么命中，应该什么时候删除，应该什么时候更新，所以有一套缓存机制去进行处理这些问题，下面会详细说明。</p><h2 id="三、为什么用浏览器缓存"><a href="#三、为什么用浏览器缓存" class="headerlink" title="三、为什么用浏览器缓存"></a>三、为什么用浏览器缓存</h2><p>我们判断一个网站的用户体验的好坏的一个标准就是这个网站加载的速度，而影响速度的因素有很多，比如浏览器和服务器通信的时间，服务器处理时间等等，而缓存如果命中的话是从客户端取数据，所以不需要请求服务器，所以提高了加载速度。缓存存在以下优点：</p><ol><li>减少了等待时间</li><li>减少了网络通信量</li></ol><h2 id="四、怎么设置浏览器缓存"><a href="#四、怎么设置浏览器缓存" class="headerlink" title="四、怎么设置浏览器缓存"></a>四、怎么设置浏览器缓存</h2><h3 id="HTTP响应头"><a href="#HTTP响应头" class="headerlink" title="HTTP响应头"></a>HTTP响应头</h3><h4 id="a-HTTP报文"><a href="#a-HTTP报文" class="headerlink" title="a. HTTP报文"></a>a. HTTP报文</h4><p>客户端和服务端通过HTTP报文进行通信，请求端（客户端）的HTTP报文叫做请求报文，响应端（服务器端）的叫做响应报文。</p><p>HTTP报文大致可以分为报文首部和报文主体。</p><p>如图：</p><h5 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h5><p><img src="/2019/06/16/浏览器缓存详解/HTTP请求报文.png" alt="请求报文"></p><p>这个是我本地的一个ajax请求的报文。</p><p><img src="浏览器缓存详解/http请求报文真实.png" alt="http请求报文"></p><p>代码如下</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">oneClick () &#123;</span><br><span class="line">  <span class="keyword">this</span>.$axioss.get(<span class="string">'/users'</span>).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到请求方法为GET，请求url为‘/users’，请求协议HTTP1.1，下面是一串头部字段名和值。</p><p>下面列出了常用的几种请求方法</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. GET: 主要用于获取数据.</span><br><span class="line">2. HEAD: 请求一个与GET请求的响应相同的响应，但没有响应体.</span><br><span class="line">3. POST: 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。</span><br><span class="line">4. PUT: 从客户端向服务器传送的数据取代指定的文档的内容。</span><br><span class="line">5. DELETE: 删除指定的资源。</span><br></pre></td></tr></table></figure><h5 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h5><p><img src="/2019/06/16/浏览器缓存详解/HTTP响应报文.png" alt="响应报文"></p><p>响应代码如下</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">router.get(&apos;/&apos;, function(req, res, next) &#123;</span><br><span class="line">  res.json(&#123;</span><br><span class="line">    code: 200,</span><br><span class="line">    success: true,</span><br><span class="line">    message: &apos;请求成功&apos;,</span><br><span class="line">    data: []</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们看真实的请求报文：</p><p><img src="浏览器缓存详解/http响应报文真实.png" alt="http请求报文"></p><p>一开始是http协议，然后是状态码，现在是200，然后是原因短语‘OK’，下面是一串响应头部字段。</p><p>状态码描述了饭回的结果状态，用户可以根据状态码知道服务器是正常处理了请求，还是出现问题。<br>状态码主要类别有‘1xx’，‘2xx’，‘3xx’，‘4xx’，‘5xx’。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1. 1xx：信息性状态码</span><br><span class="line">2. 2xx： 成功状态码</span><br><span class="line">* 200 Ok 表示请求在服务端被正常的处理了</span><br><span class="line">* 204 no content 服务器接受的请求已成功处理，但响应报文不包含实体的主体部分</span><br><span class="line">* 206 partial content 表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求</span><br><span class="line">3. 3xx： 重定向状态码</span><br><span class="line">* 301 moveed permanently 永久性重定向</span><br><span class="line">* 302 found 临时性重定向</span><br><span class="line">* 303 see other</span><br><span class="line">* 304 not modified</span><br><span class="line">* 307 temporary redirect 临时重定向</span><br><span class="line">4. 4xx：客户端错误状态码</span><br><span class="line">* 400 bad request 请求报文存在语法错误</span><br><span class="line">* 401 unauthorized 发送的请求需要有通过http认证的认证信息</span><br><span class="line">* 403 forbidden 请求资源的访问被服务器拒绝</span><br><span class="line">* 404 not found 服务器上无法找到请求的资源</span><br><span class="line">5. 5xx：服务器错误状态码</span><br><span class="line">* 500 internal server error 服务器在执行请求时发生了错误</span><br><span class="line">* 503 service unavailable 服务器暂时处于超负载或正在进行停机维护</span><br></pre></td></tr></table></figure><h5 id="报文首部字段"><a href="#报文首部字段" class="headerlink" title="报文首部字段"></a>报文首部字段</h5><p>HTTP首部字段可以分为4种类型</p><ol><li>通用首部字段</li><li>请求首部字段</li><li>响应首部字段</li><li>实体首部字段</li></ol><table><br>    <caption>通用首部字段</caption><br>    <tr><br>        <th>首部字段名</th><br>        <th>说明</th><br>    </tr><br>    <tr><br>        <td>Cache-Control</td><br>        <td>控制缓存的行为</td><br>    </tr><br>    <tr><br>        <td>Connection</td><br>        <td>逐跳首部、连接的管理</td><br>    </tr><br>    <tr><br>        <td>Date</td><br>        <td>创建报文的日期时间</td><br>    </tr><br>    <tr><br>        <td>Pragma</td><br>        <td>报文指令</td><br>    </tr><br>    <tr><br>        <td>Trailer</td><br>        <td>报文末端的首部一览</td><br>    </tr><br>    <tr><br>        <td>Transfer-Encoding</td><br>        <td>指定报文主体的传输编码方式</td><br>    </tr><br>    <tr><br>        <td>Upgrade</td><br>        <td>升级为其他协议</td><br>    </tr><br>    <tr><br>        <td>Via</td><br>        <td>代理服务器的相关信息</td><br>    </tr><br>    <tr><br>        <td>Warning</td><br>        <td>错误通知</td><br>    </tr><br></table><table><br>    <caption>请求首部字段</caption><br>    <tr><br>        <th>首部字段名</th><br>        <th>说明</th><br>    </tr><br>    <tr><br>        <td>Accept</td><br>        <td>用户代理可以处理的媒体类型</td><br>    </tr><br>    <tr><br>        <td>Accept-Charset</td><br>        <td>优先的字符集</td><br>    </tr><br>    <tr><br>        <td>Accept-Encoding</td><br>        <td>优先的内容编码</td><br>    </tr><br>    <tr><br>        <td>Accept-Language</td><br>        <td>优优先的语言（自然语言）</td><br>    </tr><br>    <tr><br>        <td>Authorization</td><br>        <td>web认证信息</td><br>    </tr><br>    <tr><br>        <td>Expect</td><br>        <td>期待服务器的特定行为</td><br>    </tr><br>    <tr><br>        <td>From</td><br>        <td>用户的电子邮箱</td><br>    </tr><br>    <tr><br>        <td>Host</td><br>        <td>请求资源所在服务器</td><br>    </tr><br>    <tr><br>        <td>if-Match</td><br>        <td>比较实体标记（ETag）</td><br>    </tr><br>    <tr><br>        <td>if-modified-Since</td><br>        <td>比较资源的更新时间</td><br>    </tr><br>    <tr><br>        <td>if-none-Match</td><br>        <td>比较实体标记（ETag）</td><br>    </tr><br>    <tr><br>        <td>if-Range</td><br>        <td>资源未更新时发生实体Byte的范围请求</td><br>    </tr><br>    <tr><br>        <td>if-Unmodified-Since</td><br>        <td>比较资源的更新时间（与if-Modified-Since）</td><br>    </tr><br><br>    <tr><br>        <td>Max-Forwards</td><br>        <td>最大传输逐跳数</td><br>    </tr><br>    <tr><br>        <td>Proxy-Authorization</td><br>        <td>代理服务器邀请客户端的认证信息</td><br>    </tr><br><br>    <tr><br>        <td>Range</td><br>        <td>实体的字节范围请求</td><br>    </tr><br>    <tr><br>        <td>Referer</td><br>        <td>对请求中URI的原始获取方</td><br>    </tr><br><br>    <tr><br>        <td>TE</td><br>        <td>传输编码的优先级</td><br>    </tr><br><br>    <tr><br>        <td>User-Agent</td><br>        <td>HTTP客户端程序的信息</td><br>    </tr><br></table><table><br>    <caption>响应首部字段</caption><br>    <tr><br>        <th>首部字段名</th><br>        <th>说明</th><br>    </tr><br>    <tr><br>        <td>Accept-Ranges</td><br>        <td>是否接受字节范围请求</td><br>    </tr><br>    <tr><br>        <td>ETag</td><br>        <td>资源的匹配信息</td><br>    </tr><br>    <tr><br>        <td>Location</td><br>        <td>令客户端重定向至指定URI</td><br>    </tr><br>    <tr><br>        <td>Proxy-Authenticate</td><br>        <td>代理服务器对客户端的认证信息</td><br>    </tr><br>    <tr><br>        <td>Retry-After</td><br>        <td>对再次发起请求的时机要求</td><br>    </tr><br>    <tr><br>        <td>Server</td><br>        <td>HTTP服务器的安装信息</td><br>    </tr><br>    <tr><br>        <td>Vary</td><br>        <td>代理服务器的缓存管理信息</td><br>    </tr><br>    <tr><br>        <td>WWW-Authenticate</td><br>        <td>服务器对客户端的认证信息</td><br>    </tr><br></table><br><table><br>    <caption>实体首部字段</caption><br>    <tr><br>        <th>首部字段名</th><br>        <th>说明</th><br>    </tr><br>    <tr><br>        <td>Allow</td><br>        <td>资源可支持的HTTP方法</td><br>    </tr><br>    <tr><br>        <td>Content-Encoding</td><br>        <td>实体主体适用的编码方法</td><br>    </tr><br>    <tr><br>        <td>Content-Language</td><br>        <td>实体主体的自然语言</td><br>    </tr><br>    <tr><br>        <td>Content-Length</td><br>        <td>实体主体的大小（单位：字节）</td><br>    </tr><br>    <tr><br>        <td>Content-Location</td><br>        <td>代替对应资源的URI</td><br>    </tr><br>    <tr><br>        <td>Content-MD5</td><br>        <td>实体主体的报文摘要</td><br>    </tr><br>    <tr><br>        <td>Content-Range</td><br>        <td>实体主体的位置范围</td><br>    </tr><br>    <tr><br>        <td>Content-Type</td><br>        <td>实体主体的媒体类型</td><br>    </tr><br>    <tr><br>        <td>Expires</td><br>        <td>实体主体过期的日期时间</td><br>    </tr><br>    <tr><br>        <td>Last-Modified</td><br>        <td>资源最后修改日期时间</td><br>    </tr><br><br></table><h4 id="b-强缓存-Expires-vs-Cache-Control"><a href="#b-强缓存-Expires-vs-Cache-Control" class="headerlink" title="b. 强缓存(Expires vs Cache-Control)"></a>b. 强缓存(Expires vs Cache-Control)</h4><h5 id="Expires-http1-0"><a href="#Expires-http1-0" class="headerlink" title="Expires http1.0"></a>Expires http1.0</h5><p><img src="/2019/06/16/浏览器缓存详解/Exprires_we.jpeg" alt=""></p><p>Expires 设置缓存过期时间</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(<span class="string">'Expires'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.now() + <span class="number">600000</span>));<span class="comment">// 当前时间过十分钟后过期</span></span><br></pre></td></tr></table></figure><p><img src="/2019/06/16/浏览器缓存详解/Expires.jpg" alt="Expires"></p><p>图中表示该文件在Tue Jun 25 2019 16:17:08 GMT+0800 日期过期，所以第一次请求的时候我们可以看到状态是200，然后下次请求时从缓存中获取的资源而没有请求服务器</p><p>第一次请求</p><p><img src="/2019/06/16/浏览器缓存详解/Expires1.png" alt=""></p><p>第二次请求</p><p><img src="/2019/06/16/浏览器缓存详解/Expires2.png" alt=""></p><p>但是如果服务器时间和客户端时间不同步，如果服务器时间快于客户端时间的话，我们设置的缓存时间小于服务器大于客户端时间的话，那么我们设置的缓存时间就不起作用了；如果服务器时落后于客户端时间，有可能导致缓存时间已经过了，但是还是用的缓存。</p><p>为了避免这个问题，http1.1推出了Cache-Control</p><h5 id="Cache-Control-http1-1"><a href="#Cache-Control-http1-1" class="headerlink" title="Cache-Control http1.1"></a>Cache-Control http1.1</h5><p>Cache-Control的常见属性</p><ol><li>private: 客户端可以缓存</li><li>public: 客户端和代理服务器都可缓存</li><li>max-age=xxx: 缓存的内容将在 xxx 秒后失效</li><li>no-cache: 需要使用对比缓存来验证缓存数据</li><li>no-store: 所有内容都不会缓存，强制缓存，对比缓存都不会触发</li></ol><p><img src="/2019/06/16/浏览器缓存详解/Cache-Control.jpeg" alt=""></p><p>Cache-Control设置的是相对时间</p><pre><code>res.setHeader(&apos;Cache-Control&apos;, &apos;public, max-age=10&apos;);</code></pre><p>这个代码设置的是缓存相对于当前时间10s后过期，这样就算服务器和客户端时间不同步也不会影响。</p><p>如果同时存在Expires和Cache-Control，Cache-Control的优先级更高。</p><p>但是不管是Expires还是Cache-Control，都是设置缓存过期时间，但是缓存时间过期后其实资源并没有改变，但是还是去请求资源了，为了解决这样的问题，所以有了协商缓存。</p><h4 id="c-协商缓存"><a href="#c-协商缓存" class="headerlink" title="c. 协商缓存"></a>c. 协商缓存</h4><p>强缓存都是浏览器通过响应报文的某个字段去设置缓存，协商缓存是通过一组字段结合起来进行缓存。</p><h4 id="Last-Modified和If-Modified-Since"><a href="#Last-Modified和If-Modified-Since" class="headerlink" title="Last-Modified和If-Modified-Since"></a>Last-Modified和If-Modified-Since</h4><p><img src="/2019/06/16/浏览器缓存详解/Last.jpeg" alt=""></p><p>Last-Modified 顾名思义是最后一次修改时间，这个是服务端获取到的，在响应报文里会返回，If-Modified-Since（等于上一次请求的Last-Modified）是浏览器根据服务端返回的Last—Modified设置的，可以理解成浏览器端存储的资源的最后修改时间。</p><p>协商，也就是浏览器和服务器之间进行协商，如果资源有改动，那么服务器每次返回时会带上一个字段Last-Modified，该资源的最后修改时间，还有一个资源过期时间，可以是Cache-Control或者Expires，然后浏览器获取到这两个字段，并且保存下来，在缓存时间没有过期时，浏览器会从缓存中获取资源，不会请求服务器，等到缓存过期时，浏览器请求服务器，请求报文会带上一个字段If-Modified-Since，这个字段是上一次的Last-Modified，然后服务器会判断最新的Last-Modified和If-Modified-Since是否相等，如果相等，意味着该资源在这段时间并没有改动，那么浏览器会返回304，如果不想等的话，服务器会将最新的Last-Modified返回，并且返回改动后的资源，并且状态码为200</p><p>下面的图是一个我们修改demo.js后浏览器和服务器的通信。</p><p><img src="/2019/06/16/浏览器缓存详解/Last-modified.png" alt=""></p><p>这个缓存方法有两个问题：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 因为Last-Modified的时间是GMT时间，只能精确到秒，如果文件在1秒内有多次改动，服务器并不知道文件有改动，那么浏览器获取不到最新的文件。</span><br><span class="line">2. 如果服务器上某资源被多次改动，但是内容并没有变化，服务器会更新改动时间，所以每次都会返回给客户端</span><br></pre></td></tr></table></figure><p>为了解决这些问题，我们引入了ETag和If-None—Match</p><h4 id="ETag和If-None-Match"><a href="#ETag和If-None-Match" class="headerlink" title="ETag和If-None-Match"></a>ETag和If-None-Match</h4><p>上面的Last-Modified是通过资源改动时间去判断是否该给客户端返回新的资源，现在是通过ETag：资源的唯一标识来判断，只有资源的内容改变时，ETag才会改变。</p><p>If-None-Match是上一次的ETag。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>那么到这关于http缓存的几个首部字段且含义已经介绍完了，那么问题来了，浏览器无法主动得知资源的变化，只有没有Expires或者是Cache-Control设置的缓存时间过期后，浏览器主动请求服务端以此得知资源的变化。</p><p>那么我们应该怎么解决这个问题？</p><p><img src="/2019/06/16/浏览器缓存详解/黑人问号.jpeg" alt=""></p><p><img src="/2019/06/16/浏览器缓存详解/answer.jpeg" onclick="document.getElementsByClassName('fd-img')[0].style.display='block'"></p><p><style><br>.fd-img {<br>    display: none;<br>}<br></style><br><img src="/2019/06/16/浏览器缓存详解/version.png" class="fd-img"></p><p>在公司呆的时间比较长的话看到第一段代码可能比较熟悉，以前用require.js的时候我们会在文件名后面加上版本号和时间戳，最近的项目用webpack的话，打包文件的时候也会在文件名后加上哈希数。</p><p>这样做的思路就是因为每次文件有改动后，比如js，那么会导致html页面也会跟着改动，因为html里引用了该js文件，所以浏览器去访问html页面时发现页面已经改动了，就会去请求服务器。这样我们就能做到浏览器主动得知资源的变动。</p><h2 id="五、浏览器本地缓存"><a href="#五、浏览器本地缓存" class="headerlink" title="五、浏览器本地缓存"></a>五、浏览器本地缓存</h2><h3 id="一-manifest（H5的应用缓存）"><a href="#一-manifest（H5的应用缓存）" class="headerlink" title="(一) manifest（H5的应用缓存）"></a>(一) manifest（H5的应用缓存）</h3><p>浏览器缓存中划分出了一块缓存区，如果想要在这个缓存中保存数据，可以用一个描述文件，列出要下载和缓存的资源，然后将该描述文件于页面关联起来，可以在<html>中的manifest属性中指定这个文件的路径，比如：</html></p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;html manifest=&apos;/offline.manifest&apos;&gt;</span><br></pre></td></tr></table></figure><h3 id="（二）storage-Web-存储机制"><a href="#（二）storage-Web-存储机制" class="headerlink" title="（二）storage(Web 存储机制)"></a>（二）storage(Web 存储机制)</h3><p>Web Storage 包含如下两种机制：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. sessionStorage 为每一个给定的源（given origin）维持一个独立的存储区域，该存储区域在页面会话期间可用（即只要浏览器处于打开状态，包括页面重新加载和恢复）。</span><br><span class="line">2. localStorage 同样的功能，但是在浏览器关闭，然后重新打开后数据仍然存在。</span><br></pre></td></tr></table></figure><h3 id="（三）indexDB"><a href="#（三）indexDB" class="headerlink" title="（三）indexDB"></a>（三）indexDB</h3><blockquote><p>ndexedDB是一种低级API，用于客户端存储大量结构化数据(包括, 文件/ blobs)。该API使用索引来实现对该数据的高性能搜索。虽然 Web Storage 对于存储较少量的数据很有用，但对于存储更大量的结构化数据来说，这种方法不太有用。IndexedDB提供了一个解决方案。</p></blockquote><h3 id="（四）cookie"><a href="#（四）cookie" class="headerlink" title="（四）cookie"></a>（四）cookie</h3><blockquote><p>HTTP Cookie（也叫Web Cookie或浏览器Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie使基于无状态的HTTP协议记录稳定的状态信息成为了可能。</p></blockquote><h2 id="六、后记"><a href="#六、后记" class="headerlink" title="六、后记"></a>六、后记</h2><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ol><li><p><a href="https://juejin.im/post/5b70edd4f265da27df0938bc" target="_blank" rel="noopener">前端也要懂Http缓存机制</a></p></li><li><p><a href="https://juejin.im/post/5b3c87386fb9a04f9a5cb037" target="_blank" rel="noopener">面试精选之http缓存</a></p></li><li><p>《图解HTTP》</p></li><li>《JavaScript高级程序设计》</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;可能有人会和以前的我一样，觉得缓存不是后台设置的吗，感觉和前端人员没有太大联系，平时关于缓存最常做的就是在浏览器&lt;code&gt;Ctrl+Shit+Delete&lt;/code&gt;清空缓存。&lt;/p&gt;
&lt;p&gt;web缓存可以大致分为三类：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 浏览器缓存
2. 代理缓存
3. 网关缓存
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们这篇文章主要讲的是浏览器缓存，浏览器主要是通过http/https和服务器进行通信，所以浏览器缓存我们也可以说是HTTP缓存。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>javaScript 数组方法总结</title>
    <link href="http://yoursite.com/2019/06/15/javaScript-%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/06/15/javaScript-数组方法总结/</id>
    <published>2019-06-15T03:14:08.000Z</published>
    <updated>2019-06-15T13:31:54.351Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组方法总结"><a href="#数组方法总结" class="headerlink" title="数组方法总结"></a>数组方法总结</h2><h3 id="1-concat"><a href="#1-concat" class="headerlink" title="1. concat()"></a>1. concat()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： arr1.concat(arrayX,arrayX,......,arrayX)</span><br><span class="line">返回值：一个连接新数组，包含了arr1和所有arrayX</span><br><span class="line">参数：arrayX：可以是具体元素值，也可以是数组，数量是任意</span><br><span class="line">作用：连接两个或多个数组</span><br><span class="line">缺点：效率低</span><br></pre></td></tr></table></figure><p>示例1：</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> resArr = arr1.concat(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(resArr);<span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>示例2:</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> resArr = arr1.concat([<span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="built_in">console</span>.log(resArr);<span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>示例3:</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> resArr = arr1.concat([<span class="number">4</span>, <span class="number">5</span>],[<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line"><span class="built_in">console</span>.log(resArr);<span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure><h3 id="2-Array"><a href="#2-Array" class="headerlink" title="2. Array()"></a>2. Array()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法： new Array(xArrayElement)</span><br><span class="line">返回值： 一个Array实例</span><br><span class="line">参数：xArrayElement数组里的内容</span><br><span class="line">作用：创建一个数组</span><br></pre></td></tr></table></figure><p>示例1：</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> resArr = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line"><span class="built_in">console</span>.log(resArr);<span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>示例2:</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> resArr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(resArr);<span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure><p>示例3:</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> resArr = <span class="keyword">new</span> <span class="built_in">Array</span>([<span class="number">1</span>, <span class="number">2</span>], <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(resArr);<span class="comment">//[[1, 2], 2]</span></span><br></pre></td></tr></table></figure><h3 id="3-copyWithin"><a href="#3-copyWithin" class="headerlink" title="3. copyWithin()"></a>3. copyWithin()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">语法： arr.copyWithin(target[, start[, end]])</span><br><span class="line">返回值：改变后的arr</span><br><span class="line">参数：</span><br><span class="line">1. target 复制的数组的某一部分到target下标的位置,如果target大于start，那么复制的序列会从start到end复制从target下标开始，超出数组长度的元素就不会复制成功，如示例1</span><br><span class="line">2. start 复制的起始下标，不设置代表复制从数组第一个元素开始</span><br><span class="line">3. end 复制的结束下标，不设置代表复制到数组结束</span><br><span class="line">作用：复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度。</span><br></pre></td></tr></table></figure><p>示例1：</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> resArr = arr.copyWithin(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(resArr);<span class="comment">// [1, 2, 3, 4, 1]</span></span><br></pre></td></tr></table></figure><p>示例2:</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> resArr = arr.copyWithin(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(resArr);<span class="comment">// [1, 3, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><h3 id="4-entries"><a href="#4-entries" class="headerlink" title="4. entries()"></a>4. entries()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法：arr.entries()</span><br><span class="line">返回值：新的Array Iterator对象</span><br><span class="line">参数：</span><br><span class="line">作用：</span><br></pre></td></tr></table></figure><p>示例1：</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">"hello"</span>, <span class="string">"hi"</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> iteartor = arr.entries()</span><br><span class="line"><span class="built_in">console</span>.log(iteartor); <span class="comment">//Array Iterator &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iteartor.next().value) <span class="comment">// [0, "hello"]</span></span><br><span class="line"><span class="built_in">console</span>.log(iteartor.next().value) <span class="comment">// [1, "hi"]</span></span><br><span class="line"><span class="built_in">console</span>.log(iteartor.next().done) <span class="comment">// true done表示迭代是否完成</span></span><br></pre></td></tr></table></figure><h3 id="5-every"><a href="#5-every" class="headerlink" title="5. every()"></a>5. every()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">语法： arr.every(callback[, thisArg])</span><br><span class="line">返回值：布尔值</span><br><span class="line">参数：</span><br><span class="line">1. callback函数 检测数组元素的函数</span><br><span class="line">callback接受三个参数element（检测数组当前的元素），index（检测数组当前的元素的下标），arr（被检测的数组）</span><br><span class="line">2. thisArg this指向</span><br><span class="line">作用：检测arr数组的所有元素都能经过callback函数的检测，如果所有数组元素都通过才返回true，如果只有一个不通过都会返回false</span><br></pre></td></tr></table></figure><p>示例1：</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBigTen</span> (<span class="params">element, index, array</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"element: "</span>+ element + <span class="string">";index: "</span> + index + <span class="string">";array: "</span>+ array);</span><br><span class="line"><span class="comment">/* element: 1;index: 0;array: 1, 10, 4, 5*/</span></span><br><span class="line"><span class="keyword">if</span> (element &gt; <span class="number">10</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> res = arr.every(isBigTen,<span class="keyword">this</span>)</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = [<span class="number">1</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">5</span>].every(<span class="function"><span class="params">x</span> =&gt;</span> x &gt; <span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>示例2:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let arr = [11, 110, 14, 15];</span><br><span class="line">function isBigTen (element, index, array) &#123;</span><br><span class="line">console.log(&quot;element: &quot;+ element + &quot;;index: &quot; + index + &quot;;array: &quot;+ array);</span><br><span class="line">/* element: 11;index: 0;array: 11,110,14,15</span><br><span class="line">element: 110;index: 1;array: 11,110,14,15</span><br><span class="line">element: 14;index: 2;array: 11,110,14,15</span><br><span class="line"> element: 15;index: 3;array: 11,110,14,15*/</span><br><span class="line">if (element &gt; 10) &#123;</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">let res = arr.every(isBigTen,this)</span><br><span class="line">console.log(res); // true</span><br></pre></td></tr></table></figure><h3 id="6-fill"><a href="#6-fill" class="headerlink" title="6. fill()"></a>6. fill()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">语法： arr.fill(value[, start[, end]])</span><br><span class="line">返回值：填充后的数组</span><br><span class="line">参数：</span><br><span class="line">1. value 用来填充的数值</span><br><span class="line">2. start 填充的起始位置，不填，默认0</span><br><span class="line">3. end 填充的结束位置，不填，默认arr.length-1</span><br><span class="line">作用：填充数组</span><br></pre></td></tr></table></figure><p>示例1：</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr = arr.fill(<span class="string">"hello"</span>,<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// ["hello", "hello", 4, 5]</span></span><br></pre></td></tr></table></figure><h3 id="7-filter"><a href="#7-filter" class="headerlink" title="7. filter()"></a>7. filter()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法： var newArray = arr.filter(callback(element[, index[, array]])[, thisArg])</span><br><span class="line">返回值：一个新数组</span><br><span class="line">参数：和every一样</span><br><span class="line">作用：找到数组中符合经过callback函数筛选出来的元素，返回到新数组里</span><br></pre></td></tr></table></figure><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBigTen</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> element &gt;= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> filtered = [<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>].filter(isBigTen);</span><br><span class="line"><span class="built_in">console</span>.log(filtered); <span class="comment">// [12, 130, 44]</span></span><br></pre></td></tr></table></figure><h3 id="8-find"><a href="#8-find" class="headerlink" title="8. find()"></a>8. find()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法： arr.find(callback[, thisArg])</span><br><span class="line">返回值：符合测试函数callback的第一个数组元素</span><br><span class="line">参数：和every()一样</span><br><span class="line">作用：找到第一个符合测试函数的数组元素</span><br></pre></td></tr></table></figure><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBigTen</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> element &gt;= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> filtered = [<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>].find(isBigTen);</span><br><span class="line"><span class="built_in">console</span>.log(filtered); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><h3 id="9-findIndex"><a href="#9-findIndex" class="headerlink" title="9. findIndex()"></a>9. findIndex()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法： arr.findIndex(callback[, thisArg])</span><br><span class="line">返回值：符合测试函数callback的第一个数组元素下标</span><br><span class="line">参数：和every()一样</span><br><span class="line">作用：找到第一个符合测试函数的数组元素的下标</span><br></pre></td></tr></table></figure><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBigTen</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> element &gt;= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> filtered = [<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>].findIndex(isBigTen);</span><br><span class="line"><span class="built_in">console</span>.log(filtered); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h3 id="10-flat"><a href="#10-flat" class="headerlink" title="10. flat()"></a>10. flat()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法： var newArray = arr.flat(depth)</span><br><span class="line">返回值：一个新数组</span><br><span class="line">参数：depth：遍历的深度</span><br><span class="line">作用：将一个多维数组按照遍历的深度合成一个新的数组，例如把多维数组扁平化成1维数组</span><br></pre></td></tr></table></figure><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> flatRes = [<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>,[<span class="number">11</span>, <span class="number">130</span>, <span class="string">"22"</span>, [<span class="string">"hello"</span>, <span class="number">33</span>]], <span class="number">44</span>].flat(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(flatRes); <span class="comment">//  [12, 5, 8, 11, 130, "22", "hello", 33, 44]</span></span><br></pre></td></tr></table></figure><h3 id="11-flatMap"><a href="#11-flatMap" class="headerlink" title="11. flatMap()"></a>11. flatMap()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">语法： var new_array = arr.flatMap(function callback(currentValue[, index[, array]]) &#123;</span><br><span class="line">    // 返回新数组的元素</span><br><span class="line">&#125;[, thisArg])</span><br><span class="line">返回值：一个新的数组，其中每个元素都是回调函数的结果，并且结构深度 depth 值为1。</span><br><span class="line">参数：</span><br><span class="line">1. callback:可以生成一个新数组中的元素的函数，可以传入三个参数：</span><br><span class="line">* currentValue当前正在数组中处理的元素</span><br><span class="line">* index可选可选的。数组中正在处理的当前元素的索引。</span><br><span class="line">* array可选可选的。被调用的 map 数组</span><br><span class="line">2.thisArg可选.执行 callback 函数时 使用的this值</span><br><span class="line">作用：首先使用映射函数映射每个元素，然后将结果压缩成一个新数组</span><br></pre></td></tr></table></figure><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> flatMapRes = [<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="string">"22"</span>, <span class="string">"hello"</span>, <span class="number">33</span>, <span class="number">44</span>].flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [<span class="built_in">parseInt</span>(x)*<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(flatMapRes); <span class="comment">//   [24, 10, 16, 44, NaN, 66, 88]</span></span><br></pre></td></tr></table></figure><h3 id="12-forEach"><a href="#12-forEach" class="headerlink" title="12. forEach()"></a>12. forEach()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法： arr.forEach(callback[, thisArg]);</span><br><span class="line">返回值：undefined</span><br><span class="line">参数：和flatMap一样</span><br><span class="line">作用：forEach 方法按升序为数组中含有效值的每一项执行一次callback 函数，那些已删除或者未初始化的项将被跳过（例如在稀疏数组上</span><br></pre></td></tr></table></figure><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">var</span> flatMapRes = [<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="string">"22"</span>, <span class="string">"hello"</span>, <span class="number">33</span>, <span class="number">44</span>].forEach(<span class="function"><span class="params">x</span> =&gt;</span> arr.push(x));</span><br><span class="line"><span class="built_in">console</span>.log(flatMapRes); <span class="comment">//  undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [12, 5, 8, "22", "hello", 33, 44]</span></span><br></pre></td></tr></table></figure><h3 id="13-includes"><a href="#13-includes" class="headerlink" title="13. includes()"></a>13. includes()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法： arr.includes(valueToFind[, fromIndex])</span><br><span class="line">返回值：true或false</span><br><span class="line">参数：valueToFind： 被查找到元素。fromIndex：从下标fromIndex开始查找</span><br><span class="line">作用：用来判断一个数组里是否包含某个元素，如果包含，则返回true，否则false</span><br></pre></td></tr></table></figure><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = [<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="string">"22"</span>, <span class="string">"hello"</span>, <span class="number">33</span>, <span class="number">44</span>]. includes(<span class="number">33</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">//  true</span></span><br><span class="line"><span class="keyword">var</span> res1 = [<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="string">"22"</span>, <span class="string">"hello"</span>, <span class="number">33</span>, <span class="number">44</span>]. includes(<span class="string">"hi"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res1); <span class="comment">//  false</span></span><br></pre></td></tr></table></figure><h3 id="14-indexOf"><a href="#14-indexOf" class="headerlink" title="14. indexOf()"></a>14. indexOf()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： </span><br><span class="line">返回值：</span><br><span class="line">参数：</span><br><span class="line">作用：</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure><h3 id="15-join"><a href="#15-join" class="headerlink" title="15. join()"></a>15. join()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： </span><br><span class="line">返回值：</span><br><span class="line">参数：</span><br><span class="line">作用：</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure><h3 id="16-keys"><a href="#16-keys" class="headerlink" title="16. keys()"></a>16. keys()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： </span><br><span class="line">返回值：</span><br><span class="line">参数：</span><br><span class="line">作用：</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure><h3 id="17-lastIndexOf"><a href="#17-lastIndexOf" class="headerlink" title="17. lastIndexOf()"></a>17. lastIndexOf()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： </span><br><span class="line">返回值：</span><br><span class="line">参数：</span><br><span class="line">作用：</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure><h3 id="18-map"><a href="#18-map" class="headerlink" title="18. map()"></a>18. map()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： </span><br><span class="line">返回值：</span><br><span class="line">参数：</span><br><span class="line">作用：</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure><h3 id="19-pop"><a href="#19-pop" class="headerlink" title="19. pop()"></a>19. pop()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： </span><br><span class="line">返回值：</span><br><span class="line">参数：</span><br><span class="line">作用：</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure><h3 id="20-push"><a href="#20-push" class="headerlink" title="20. push()"></a>20. push()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： </span><br><span class="line">返回值：</span><br><span class="line">参数：</span><br><span class="line">作用：</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure><h3 id="21-reduce"><a href="#21-reduce" class="headerlink" title="21. reduce()"></a>21. reduce()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： </span><br><span class="line">返回值：</span><br><span class="line">参数：</span><br><span class="line">作用：</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure><h3 id="22-reduceRight"><a href="#22-reduceRight" class="headerlink" title="22. reduceRight()"></a>22. reduceRight()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： </span><br><span class="line">返回值：</span><br><span class="line">参数：</span><br><span class="line">作用：</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure><h3 id="23-reverse"><a href="#23-reverse" class="headerlink" title="23. reverse()"></a>23. reverse()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： </span><br><span class="line">返回值：</span><br><span class="line">参数：</span><br><span class="line">作用：</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure><h3 id="24-shift"><a href="#24-shift" class="headerlink" title="24. shift()"></a>24. shift()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： </span><br><span class="line">返回值：</span><br><span class="line">参数：</span><br><span class="line">作用：</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure><h3 id="25-slice"><a href="#25-slice" class="headerlink" title="25. slice()"></a>25. slice()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： </span><br><span class="line">返回值：</span><br><span class="line">参数：</span><br><span class="line">作用：</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure><h3 id="26-some"><a href="#26-some" class="headerlink" title="26. some()"></a>26. some()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： </span><br><span class="line">返回值：</span><br><span class="line">参数：</span><br><span class="line">作用：</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure><h3 id="27-sort"><a href="#27-sort" class="headerlink" title="27. sort()"></a>27. sort()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： </span><br><span class="line">返回值：</span><br><span class="line">参数：</span><br><span class="line">作用：</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure><h3 id="28-splice"><a href="#28-splice" class="headerlink" title="28. splice()"></a>28. splice()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： </span><br><span class="line">返回值：</span><br><span class="line">参数：</span><br><span class="line">作用：</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure><h3 id="29-toLocaleString"><a href="#29-toLocaleString" class="headerlink" title="29. toLocaleString()"></a>29. toLocaleString()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： </span><br><span class="line">返回值：</span><br><span class="line">参数：</span><br><span class="line">作用：</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure><h3 id="30-toString"><a href="#30-toString" class="headerlink" title="30. toString()"></a>30. toString()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： </span><br><span class="line">返回值：</span><br><span class="line">参数：</span><br><span class="line">作用：</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure><h3 id="31-unshift"><a href="#31-unshift" class="headerlink" title="31. unshift()"></a>31. unshift()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： </span><br><span class="line">返回值：</span><br><span class="line">参数：</span><br><span class="line">作用：</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure><h3 id="32-values"><a href="#32-values" class="headerlink" title="32. values()"></a>32. values()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： </span><br><span class="line">返回值：</span><br><span class="line">参数：</span><br><span class="line">作用：</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure><h3 id="33-from"><a href="#33-from" class="headerlink" title="33. from()"></a>33. from()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： </span><br><span class="line">返回值：</span><br><span class="line">参数：</span><br><span class="line">作用：</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure><h3 id="34-isArray"><a href="#34-isArray" class="headerlink" title="34. isArray()"></a>34. isArray()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： </span><br><span class="line">返回值：</span><br><span class="line">参数：</span><br><span class="line">作用：</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure><h3 id="32-of"><a href="#32-of" class="headerlink" title="32.of()"></a>32.of()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： </span><br><span class="line">返回值：</span><br><span class="line">参数：</span><br><span class="line">作用：</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数组方法总结&quot;&gt;&lt;a href=&quot;#数组方法总结&quot; class=&quot;headerlink&quot; title=&quot;数组方法总结&quot;&gt;&lt;/a&gt;数组方法总结&lt;/h2&gt;&lt;h3 id=&quot;1-concat&quot;&gt;&lt;a href=&quot;#1-concat&quot; class=&quot;headerlink&quot; title=&quot;1. concat()&quot;&gt;&lt;/a&gt;1. concat()&lt;/h3&gt;&lt;figure class=&quot;hljs highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;语法： arr1.concat(arrayX,arrayX,......,arrayX)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;返回值：一个连接新数组，包含了arr1和所有arrayX&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;参数：arrayX：可以是具体元素值，也可以是数组，数量是任意&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;作用：连接两个或多个数组&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;缺点：效率低&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;示例1：&lt;/p&gt;
&lt;figure class=&quot;hljs highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; arr1 = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; resArr = arr1.concat(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(resArr);&lt;span class=&quot;comment&quot;&gt;// [1, 2, 3, 4, 5]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="JavaScript Array" scheme="http://yoursite.com/tags/JavaScript-Array/"/>
    
  </entry>
  
  <entry>
    <title>基于vue cli3实现自己的组件库且发布到npm（一）环境搭建</title>
    <link href="http://yoursite.com/2019/06/12/%E5%9F%BA%E4%BA%8Evue-cli3%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BB%84%E4%BB%B6%E5%BA%93%E4%B8%94%E5%8F%91%E5%B8%83%E5%88%B0npm%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2019/06/12/基于vue-cli3实现自己的组件库且发布到npm（一）环境搭建/</id>
    <published>2019-06-12T07:13:13.000Z</published>
    <updated>2019-06-12T09:43:33.778Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="安装vue-cli3-0"><a href="#安装vue-cli3-0" class="headerlink" title="安装vue-cli3.0"></a>安装vue-cli3.0</h2><p>因为我电脑之前有装了vue-cli2的，所以要先卸载以前的版本，再安装新的版本。</p><pre><code>npm uninstall vue-cli -g</code></pre><p>然后再安装新版本</p><pre><code>npm install -g @vue/cli </code></pre><p>安装成功后用<code>vue -V</code>查看，发现还是2.9.x版本，我看了一下node版本是符合要求的，然后我真是的一脸懵逼。然后网上搜了下，最后找到了一个解决办法（window系统有遇到这个问题，mac没有）。</p><ol><li>把node完全卸载了，文件也删除干净。</li><li>然后下载nvm，<a href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="noopener">下载传送门</a>，选择相应的版本，然后选择下载nvm-setup.zip这个包，然后安装成功后，命令行输入nvm，会出现nvm版本号和一系列指令。</li><li>命令行输入 <code>nvm install node版本号</code>,就可以安装相应版本的node,最后<code>nvm use node版本号</code>使用指定版本的node</li><li>最后在命令行输入<code>npm install -g @vue/cli</code>，发现输出终于是3.x了，欢呼！！</li></ol><a id="more"></a><h2 id="创建github项目"><a href="#创建github项目" class="headerlink" title="创建github项目"></a>创建github项目</h2><p>为了后期维护，我把代码上传到了github上，<a href="https://github.com/zzilcc/zzilccComponent/tree/develop" target="_blank" rel="noopener">项目地址</a>,具体怎么上传到github请自行搜索。</p><p>代码上传后默认是提交到master分支，我们拉一个develop分支，在该分支上进行开发。</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>vue-cli3.0是通过 <code>create</code>创建，跟2.0是有区别。</p><pre><code>vue create zzilcc-ui</code></pre><p>通过上面的命令，我们创建了一个新的项目。</p><p>运行<code>npm run serve</code>就能把项目起起来。</p><h3 id="调整目录"><a href="#调整目录" class="headerlink" title="调整目录"></a>调整目录</h3><p>我们需要一个目录存放示例，一个目录存放真的组件代码，所以我们将原先的src目录改名成examples，然后新增一个packages目录，用来放组件代码。</p><p>所以调整后的目录是这样的</p><p><img src="/2019/06/12/基于vue-cli3实现自己的组件库且发布到npm（一）环境搭建/目录结构.png" alt=""></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="重新配置入口为example-main-js"><a href="#重新配置入口为example-main-js" class="headerlink" title="重新配置入口为example/main.js"></a>重新配置入口为example/main.js</h3><p>因为我们刚把src目录改成了example，所以我们要修改一下项目的入口文件的路径，我们创建在根目录下创建一个vue.config.js文件。</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">pages: &#123;</span><br><span class="line">index: &#123;</span><br><span class="line">entry: <span class="string">'examples/main.js'</span>, <span class="comment">// 修改src目录为examples</span></span><br><span class="line">template: <span class="string">'public/index.html'</span>,</span><br><span class="line">filename: <span class="string">'index.html'</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="支持对packages目录的支持"><a href="#支持对packages目录的支持" class="headerlink" title="支持对packages目录的支持"></a>支持对packages目录的支持</h3><p>packages是我们新增的，我们需要手动配置，要不然webpack是不会处理。</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">pages: &#123;</span><br><span class="line">index: &#123;</span><br><span class="line">entry: <span class="string">'examples/main.js'</span>, <span class="comment">// 修改src目录为examples</span></span><br><span class="line">template: <span class="string">'public/index.html'</span>,</span><br><span class="line">filename: <span class="string">'index.html'</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 扩展webpack位置，让packages加入编译</span></span><br><span class="line">config.module</span><br><span class="line">.rule(<span class="string">'js'</span>)</span><br><span class="line">.incluede</span><br><span class="line">.add(<span class="string">'packages'</span>)</span><br><span class="line">.end()</span><br><span class="line">.use(<span class="string">'babel'</span>)</span><br><span class="line">.loader(<span class="string">'babel-loader'</span>)</span><br><span class="line">.tap(<span class="function"><span class="params">options</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 修改它的选项</span></span><br><span class="line"><span class="keyword">return</span> options</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编写组件"><a href="#编写组件" class="headerlink" title="编写组件"></a>编写组件</h2><h3 id="创建一个新组件"><a href="#创建一个新组件" class="headerlink" title="创建一个新组件"></a>创建一个新组件</h3><pre><code>1. 我们在packages目录下创建一个button文件夹，每个组件都一个文件夹2. 在button文件夹下创建src文件夹，用来存放组件源码，并在src文件夹里创建一个z-button.vue3. 在button文件里创建一个index.js,用来对外提供组件的引用</code></pre><p><img src="/2019/06/12/基于vue-cli3实现自己的组件库且发布到npm（一）环境搭建/button1.png" alt=""></p><p>为了测试，我们在z-button.vue的template里写一个<code>&lt;button&gt;</code></p><p><img src="/2019/06/12/基于vue-cli3实现自己的组件库且发布到npm（一）环境搭建/button.png" alt=""></p><p>然后再button/index.js里写组件的install方法，创建相应的组件方法，供外部调用。</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入组件，组件必须声明name</span></span><br><span class="line"><span class="keyword">import</span> zButton <span class="keyword">from</span> <span class="string">'./src/z-button.vue'</span></span><br><span class="line"><span class="comment">// 为组件提供install方法，供按需引入</span></span><br><span class="line">zButton.install = <span class="function"><span class="keyword">function</span> (<span class="params">Vue</span>) </span>&#123;</span><br><span class="line">Vue.component(zButton.name, zButton)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 默认导出组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> zButton</span><br></pre></td></tr></table></figure><h3 id="整合所有组件，对外导出"><a href="#整合所有组件，对外导出" class="headerlink" title="整合所有组件，对外导出"></a>整合所有组件，对外导出</h3><p>修改packages/index.js</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入z-button组件</span></span><br><span class="line"><span class="keyword">import</span> zButton <span class="keyword">from</span> <span class="string">'./button'</span></span><br><span class="line"><span class="comment">// 存储组件列表</span></span><br><span class="line"><span class="keyword">const</span> components = [</span><br><span class="line">zButton</span><br><span class="line">]</span><br><span class="line"><span class="comment">// 定义 install 方法，接收 Vue 作为参数。如果使用 use 注册插件，则所有的组件都将被注册</span></span><br><span class="line"><span class="keyword">const</span> install = <span class="function"><span class="keyword">function</span> (<span class="params">Vue</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 判断是否安装</span></span><br><span class="line"><span class="keyword">if</span> (install.installed) <span class="keyword">return</span></span><br><span class="line"><span class="comment">// 遍历注册全局组件</span></span><br><span class="line">components.map(<span class="function"><span class="params">component</span> =&gt;</span> Vue.component(component.name, component))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断是否是直接引入文件</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span> &amp;&amp; <span class="built_in">window</span>.Vue) &#123;</span><br><span class="line">install(<span class="built_in">window</span>.Vue)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"><span class="comment">// 导出的对象必须具有 install，才能被 Vue.use() 方法安装</span></span><br><span class="line">install,</span><br><span class="line"><span class="comment">// 以下是具体的组件列表</span></span><br><span class="line">zButton</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建主题样式"><a href="#创建主题样式" class="headerlink" title="创建主题样式"></a>创建主题样式</h2><p>因为第一次建组件库，没什么经验，然后借鉴了好多ui组件库，比如element ui,iView,VV-UI等，我看到他们都没有在组件vue文件中去写相应的样式，也没有显示调用样式文件，然后研究了一下element ui的，发现它是将样式所有抽离出来，用gulp打包编译。然后我们在项目中需要引用样式文件。</p><h3 id="创建一个github新项目"><a href="#创建一个github新项目" class="headerlink" title="创建一个github新项目"></a>创建一个github新项目</h3><p>我创建了一个名为theme-default的github项目用来存放主题样式。然后得到了一个项目地址。</p><h3 id="创建样式文件目录"><a href="#创建样式文件目录" class="headerlink" title="创建样式文件目录"></a>创建样式文件目录</h3><p>我们在packages/下新建一个样式目录，叫做‘theme-default’，这个名字你可以随意。</p><h3 id="初始化样式文件"><a href="#初始化样式文件" class="headerlink" title="初始化样式文件"></a>初始化样式文件</h3><p>我们通过<code>npm init</code>初始化，然后命令行会出现一些内容让你填写，比如name,main,author等，关于git项目的选项，我们要填上第一步创建的github项目地址，然后结束后在theme-default目录下会出现package.json,里面的内容就是你刚刚填写的。</p><p>我们在样式目录下新建一个src目录用来放置样式文件，然后在src目录下创建button.scss,和index.scss.</p><p>然后安装一下scss/sass</p><pre><code>npm install -D sass-loader node-sass</code></pre><p>在button.scss里先写</p><figure class="hljs highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.z-button</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: inline-block;</span><br><span class="line"><span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line"><span class="attribute">cursor</span>: pointer;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#eee</span>;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在index.scss</p><figure class="hljs highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">import</span> <span class="string">"./button.scss"</span></span><br></pre></td></tr></table></figure><h2 id="安装gulp"><a href="#安装gulp" class="headerlink" title="安装gulp"></a>安装gulp</h2><p>下面的命令都是在theme-default目录下执行</p><p>全局安装：</p><pre><code>npm install --global gulp</code></pre><p>作为项目的开发依赖（devDependencies）安装：</p><pre><code>npm install --save-dev gulp</code></pre><p>在theme-default目录下创建一个gulpfile.js，在改文件中编写</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; series, src, dest &#125; = <span class="built_in">require</span>(<span class="string">'gulp'</span>)</span><br><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">'gulp-sass'</span>)</span><br><span class="line"><span class="keyword">const</span> autoprefixer = <span class="built_in">require</span>(<span class="string">'gulp-autoprefixer'</span>)</span><br><span class="line"><span class="keyword">const</span> cssmin = <span class="built_in">require</span>(<span class="string">'gulp-cssmin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compile</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> src(<span class="string">'./src/*.scss'</span>)</span><br><span class="line">.pipe(sass.sync())</span><br><span class="line">.pipe(autoprefixer(&#123;</span><br><span class="line">browsers: [<span class="string">'ie &gt; 9'</span>, <span class="string">'last 2 versions'</span>],</span><br><span class="line">cascade: <span class="literal">false</span></span><br><span class="line">&#125;))</span><br><span class="line">.pipe(cssmin())</span><br><span class="line">.pipe(dest(<span class="string">'../../lib/theme-default'</span>)) <span class="comment">// 这是输出地址，我写到了和组件编译后的地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyfont</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> src(<span class="string">'./src/fonts/**'</span>)</span><br><span class="line">.pipe(cssmin())</span><br><span class="line">.pipe(dest(<span class="string">'../../lib/fonts/theme-default'</span>))<span class="comment">// 同上</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.build = series(compile, copyfont)</span><br></pre></td></tr></table></figure><h2 id="发布到npm"><a href="#发布到npm" class="headerlink" title="发布到npm"></a>发布到npm</h2><h3 id="配置命令"><a href="#配置命令" class="headerlink" title="配置命令"></a>配置命令</h3><p>我们在zzilcc-ui目录下的package.json的scripts里加一个lib命令</p><figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">"serve": "vue-cli-service serve",</span><br><span class="line">"build": "vue-cli-service build",</span><br><span class="line">"lint": "vue-cli-service lint",</span><br><span class="line">"lib": "vue-cli-service build --target lib --name zzilcc-ui --dest lib packages/index.js &amp;&amp; gulp build --gulpfile packages/theme-default/gulpfile.js"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>然后运行lib命令  <code>npm run lib</code></p><p>该命令其实执行了两个命令，第一个是vue-cli3.0的vue-cli-service build</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">用法：vue-cli-service build [options] [entry|pattern]</span><br><span class="line">选项：</span><br><span class="line"></span><br><span class="line">--mode        指定环境模式 (默认值：production)</span><br><span class="line">--dest        指定输出目录 (默认值：dist)</span><br><span class="line">--modern      面向现代浏览器带自动回退地构建应用</span><br><span class="line">--target      app | lib | wc | wc-async (默认值：app)</span><br><span class="line">--name        库或 Web Components 模式下的名字 (默认值：package.json 中的 &quot;name&quot; 字段或入口文件名)</span><br><span class="line">--no-clean    在构建项目之前不清除目标目录</span><br><span class="line">--report      生成 report.html 以帮助分析包内容</span><br><span class="line">--report-json 生成 report.json 以帮助分析包内容</span><br><span class="line">--watch       监听文件变化</span><br></pre></td></tr></table></figure><p>vue-cli-service build 会在 dist/ 目录产生一个可用于生产环境的包，带有 JS/CSS/HTML 的压缩，和为更好的缓存而做的自动的 vendor chunk splitting。 –vue-cli官网</p><p>第二个命令是执行样式文件的gulp build</p><p>命令执行完后会在zzilcc-ui下生成一个lib文件</p><p><img src="/2019/06/12/基于vue-cli3实现自己的组件库且发布到npm（一）环境搭建/lib.png" alt=""></p><p>箭头指向的是生成主题样式文件，然后是html，和压缩后的js</p><h3 id="配置-package-json-文件中发布到-npm-的字段"><a href="#配置-package-json-文件中发布到-npm-的字段" class="headerlink" title="配置 package.json 文件中发布到 npm 的字段"></a>配置 package.json 文件中发布到 npm 的字段</h3><ol><li>name: 包名，该名字是唯一的。可在 npm 官网搜索名字，如果存在则需换个名字。我第一个名的名字叫”zzilccComponent”发布失败了，改成”zzilcc-component”才可以，不知道是不是大写不行</li><li>version: 版本号，每次发布至 npm 需要修改版本号，不能和历史版本号相同。</li><li>description: 描述。</li><li>main: 入口文件，该字段需指向我们最终编译后的包文件。</li><li>keyword：关键字，以空格分离希望用户最终搜索的词。</li><li>author：作者</li><li>private：是否私有，需要修改为 false 才能发布到 npm</li><li>license： 开源协议</li></ol><p>贴上我的配置</p><figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">"name": "zzilcc-ui",</span><br><span class="line">"version": "0.1.4",</span><br><span class="line">"description": "基于 Vue 的简易组件库",</span><br><span class="line">"main": "lib/zzilcc-ui.umd.min.js",</span><br><span class="line">"keyword": "zzilcc-ui vue",</span><br><span class="line">"private": false,</span><br></pre></td></tr></table></figure><h3 id="添加npm发布忽略文件"><a href="#添加npm发布忽略文件" class="headerlink" title="添加npm发布忽略文件"></a>添加npm发布忽略文件</h3><p>我们在zzilcc-ui目录下新建一个.npmignore文件，语法和git的忽略文件是一样的，内容如下<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 忽略目录</span><br><span class="line">examples/</span><br><span class="line">packages/</span><br><span class="line">public/</span><br><span class="line"></span><br><span class="line"># 忽略指定文件</span><br><span class="line">vue.config.js</span><br><span class="line">babel.config.js</span><br><span class="line">*.map</span><br></pre></td></tr></table></figure></p><h3 id="注册npm账号"><a href="#注册npm账号" class="headerlink" title="注册npm账号"></a>注册npm账号</h3><p>去<a href="https://www.npmjs.com/package/npm" target="_blank" rel="noopener">npm官网</a>注册一个账号，然后网站会发一封邮件到你注册的邮箱，点击邮件中的链接，就表示邮箱验证成功。</p><p>然后在zzilcc-ui目录打开命令行输入</p><pre><code>npm login</code></pre><p>该命令会让你输如npm 账号，密码，邮箱，相应的输入你注册的账号，密码输入不会显示，输入完回车就行</p><h3 id="发布你的第一个npm包"><a href="#发布你的第一个npm包" class="headerlink" title="发布你的第一个npm包"></a>发布你的第一个npm包</h3><p>最后我们只要执行发布命令</p><pre><code>npm publish</code></pre><p>成功后，去npm官网上搜索你写的npm name，搜到你相应的包就算成功了。</p><p><img src="/2019/06/12/基于vue-cli3实现自己的组件库且发布到npm（一）环境搭建/npm.png" alt=""></p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>下一篇文章我将会细讲怎么写一个组件，今天只是把环境搭好，有什么疑惑可以到<a href="https://github.com/zzilcc/zzilccComponent/issues" target="_blank" rel="noopener">issues</a>给我提问。要是觉得我写的还行，能帮助到你，也可以给我github项目star一下。</p><p>打赏植发钱</p><p>一入前端发直掉，</p><p>网络一线牵，</p><p>珍惜这段缘。</p><p>感觉要开始存钱植发了。</p><p><img width="100" src="/2019/06/12/基于vue-cli3实现自己的组件库且发布到npm（一）环境搭建/zf.png"></p><p><img width="120" src="/2019/06/12/基于vue-cli3实现自己的组件库且发布到npm（一）环境搭建/wxZf.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h2 id=&quot;安装vue-cli3-0&quot;&gt;&lt;a href=&quot;#安装vue-cli3-0&quot; class=&quot;headerlink&quot; title=&quot;安装vue-cli3.0&quot;&gt;&lt;/a&gt;安装vue-cli3.0&lt;/h2&gt;&lt;p&gt;因为我电脑之前有装了vue-cli2的，所以要先卸载以前的版本，再安装新的版本。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm uninstall vue-cli -g
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后再安装新版本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install -g @vue/cli 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安装成功后用&lt;code&gt;vue -V&lt;/code&gt;查看，发现还是2.9.x版本，我看了一下node版本是符合要求的，然后我真是的一脸懵逼。然后网上搜了下，最后找到了一个解决办法（window系统有遇到这个问题，mac没有）。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把node完全卸载了，文件也删除干净。&lt;/li&gt;
&lt;li&gt;然后下载nvm，&lt;a href=&quot;https://github.com/coreybutler/nvm-windows/releases&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;下载传送门&lt;/a&gt;，选择相应的版本，然后选择下载nvm-setup.zip这个包，然后安装成功后，命令行输入nvm，会出现nvm版本号和一系列指令。&lt;/li&gt;
&lt;li&gt;命令行输入 &lt;code&gt;nvm install node版本号&lt;/code&gt;,就可以安装相应版本的node,最后&lt;code&gt;nvm use node版本号&lt;/code&gt;使用指定版本的node&lt;/li&gt;
&lt;li&gt;最后在命令行输入&lt;code&gt;npm install -g @vue/cli&lt;/code&gt;，发现输出终于是3.x了，欢呼！！&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="vue vue-cli webpack" scheme="http://yoursite.com/tags/vue-vue-cli-webpack/"/>
    
  </entry>
  
  <entry>
    <title>半个小时学不会的正则表达式</title>
    <link href="http://yoursite.com/2019/05/28/%E5%8D%8A%E4%B8%AA%E5%B0%8F%E6%97%B6%E5%AD%A6%E4%B8%8D%E4%BC%9A%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/05/28/半个小时学不会的正则表达式/</id>
    <published>2019-05-28T14:35:41.000Z</published>
    <updated>2019-06-01T11:40:15.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、-为什么用正则表达式"><a href="#一、-为什么用正则表达式" class="headerlink" title="一、 为什么用正则表达式"></a>一、 为什么用正则表达式</h1><p>我们去学习某个新技能，肯定是因为它有某些实用价值，它能解决某些问题，能提高某些方面效率。</p><p>正则表达式也是如此。</p><p>正则表达式是匹配模式，</p><p>正则表达式能做的事情：</p><ol><li>验证<ul><li>表单验证</li></ul></li><li>切分<ul><li>“2019-05-25这一天，我们去密室逃脱.”切分出日期</li><li>切分出url的参数</li></ul></li><li>提取<ul><li>”2019-05-28“提取出年月日</li></ul></li><li>替换<ul><li>替换空格等</li></ul></li></ol><p>总的来说，正则表达式可以用来匹配字符，也可以匹配位置，可以使我们少写很多行代码。<br><a id="more"></a><br><a href="https://www.jianshu.com/p/e7bb97218946" target="_blank" rel="noopener">知道这20个正则表达式，能让你少写1,000行代码</a></p><blockquote><p>​ “如果罗列计算机软件领域的伟大发明, 我相信绝对不会超过二十项, 在这个名单当中, 当然应该包括分组交换网络, Web, Lisp, 哈希算法, UNIX, 编译技术, 关系模型, 面向对象, XML这些大名鼎鼎的家伙, 而正则表达式也绝对不应该被漏掉.</p></blockquote><p>​ 对很多实际工作而言, 正则表达式简直是灵丹妙药, 能够成百倍的提高开发效率和程序质量, 正则表达式在生物信息学和人类基因图谱的研究中所发挥的关键作用, 更是被传为佳话. CSDN的创始人蒋涛先生在早年开发专业软件产品时, 就曾经体验过这一工具的巨大威力, 并且一直印象深刻.”<br>奔着能少写代码，精简代码，我们开始学习正则表达式</p><h1 id="二、-正则表达式是什么"><a href="#二、-正则表达式是什么" class="headerlink" title="二、 正则表达式是什么"></a>二、 正则表达式是什么</h1><blockquote><p>百度百科： 正则表达式，又称规则表达式。（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。</p></blockquote><p>正则表达式是由普通字符和特殊字符(也叫元字符或限定符)组成。</p><p>然后由’//‘两个斜杠包裹着</p><p>比如我们要匹配’hello’, 可以写/hello/</p><p>  var regex = ‘/hello/‘;<br>  console.log(regex.test(“hello,world!”)) // true</p><p>这是最简单的精确匹配，但是正则表达式能做的不止这些，主要的还是模糊匹配。</p><p>模糊匹配有两种： 横向模糊匹配和纵向模糊匹配。</p><h2 id="横向模糊匹配"><a href="#横向模糊匹配" class="headerlink" title="横向模糊匹配"></a>横向模糊匹配</h2><p>横向模糊是指一个正则匹配的字符串的长度不是固定的，可以是多种情况的。</p><p>譬如： 删除字符串首尾空格（后面会写该正则）</p><p>字符串首尾空格的个数我们是不知道的，所以我们要用到量词{n,m}，代表字符重复次数在n到m次。</p><p>/ab{2,5}c/表示匹配这样的一个字符串，第一个字符是’a‘，然后是2到5个字符’b‘，最后是’c‘</p><pre><code>var reg = /ab{2,5}c/gvar str1 = &quot;abc abbc abbbc abbbbc abbbbbc abbbbbbc&quot;var str2 = &apos;abcabcabbc&apos;console.log(str1.match(reg))console.log(str2.match(reg))</code></pre><h2 id="纵向模糊匹配"><a href="#纵向模糊匹配" class="headerlink" title="纵向模糊匹配"></a>纵向模糊匹配</h2><p>纵向模糊是指一个正则匹配的字符串，具体到某一位字符时，它可以是不确定的字符，可以有多种可能。</p><p>譬如 [0123456789]指可以是0-9其中的一个字符，注意是一个。</p><p>/123[abc]/可以匹配’123a‘，’123b‘，’123c‘</p><pre><code>var reg = /123[abc]/gvar str1 = &quot;123a 123b 123c&quot;console.log(str1.match(reg))</code></pre><h2 id="字符组（字符类）"><a href="#字符组（字符类）" class="headerlink" title="字符组（字符类）"></a>字符组（字符类）</h2><p>可以理解成匹配这一组字符里的其中一个，虽然叫组，但是只是其中一个字符，注意不要混淆。</p><p>我们刚刚举例过的[abc]就是一个字符组，表示’a’,’b’,’c’的其中一个。</p><p>如果字符组里的字符很多，比如所有数字和大小字母，[0123456789abcd…zA….Z]我们可以写成[0-9a-zA-Z]，通过连字符’-‘代表范围。</p><p>那么我们要匹配’a‘,’-‘,’z’呢？</p><p>我们可以写成[az-],[-az],[a-z]。</p><p>然后系统对于一些常见的字符组定义了一些符号去表示：（^表示取反）</p><p>字符组|具体含义<br>|:-:|:-:|<br>|\d|表示[0-9]数字|<br>|\D|表示[^0-9]非数字|<br>|\s|表示空白符，包括空格，水平制表符，垂直制表符，换行符，回车符，换页符|<br>|\S|表示非空白符|<br>|\w|[0-9a-zA-Z_]表示单词字符,包括数字，大小写字母还有下划线|<br>|\W|[^0-9a-zA-Z_]表示非单词字符|<br>|.|通配符，几乎表示任意字符，换行符，回车符，行分隔符，段分隔符除外|</p><p>思考： 怎么匹配任意字符？</p><h2 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h2><p>量词可以理解成重复次数，在正则中用{n,m}表示。</p><p>量词|具体含义<br>|:-:|:-:|<br>|{n,m}|表示出现n到m次|<br>|{n}|表示只能出现n次|<br>|{n,}|表示至少出现n次|<br>|{,m}|表示至多出现m次|<br>|?|等价于{0,1}|<br>|+|等价于{1,}|<br>|*|等价于{0,}|</p><pre><code>var reg = /a{1,8}b{2,}c{4}d?e+h*/gvar str1 = &quot;abbbccccc abbbccccde&quot;console.log(str1.match(reg))    </code></pre><h2 id="贪婪匹配"><a href="#贪婪匹配" class="headerlink" title="贪婪匹配"></a>贪婪匹配</h2><pre><code>var reg = /\w{1,4}/gvar str1 = &quot;a 12a 22 aaaa adkdd 123dff&quot;console.log(str1.match(reg))</code></pre><p>结果我们可以看到是[“a”, “12a”, “22”, “aaaa”, “adkd”, “d”, “123d”, “ff”]，从结果中我们可以看到，结果是尽量去匹配的，给我5个字符，我能要到四个，给我四个，我也能要到四个，给3个，我也要三个。这在正则中叫做贪婪匹配，也就是尽可能的匹配。</p><h2 id="懒惰匹配"><a href="#懒惰匹配" class="headerlink" title="懒惰匹配"></a>懒惰匹配</h2><p>懒惰匹配只需要在量词后面加上’?’</p><ol><li>{n,m}?</li><li>{n}?</li><li>{n,}?</li><li>{,m}?</li><li>??</li><li>+?</li><li>*?</li></ol><pre><code>var reg = /\w{1,4}?/gvar str1 = &quot;a 12a 22 aaaa adkdd 123dff&quot;console.log(str1.match(reg))</code></pre><p>结果为：[“a”, “1”, “2”, “a”, “2”, “2”, “a”, “a”, “a”, “a”, “a”, “d”, “k”, “d”, “d”, “1”, “2”, “3”, “d”, “f”, “f”]</p><h2 id="多选分支"><a href="#多选分支" class="headerlink" title="多选分支"></a>多选分支</h2><p>多选分支的形式:(a|b)</p><p>a，b是子模式，用管道符’|’分隔，表示匹配其一。</p><p>比如要匹配hello或者hi 可以/hello|hi/</p><pre><code>var reg = /hello|hi/gvar str = &apos;hello,girl.hi,boy&apos;console.log(str.match(reg)) // [&quot;hello&quot;, &quot;hi&quot;]</code></pre><p>其实多选分支其实是惰性的，比如我们用/hello|helloworld/去匹配‘helloworld’,结果是</p><pre><code>var reg = /hello|helloworld/gvar str = &apos;helloworld&apos;console.log(str.match(reg)) //hello</code></pre><p>它匹配到了’hello’,就不会继续去匹配’helloworld’ </p><h2 id="正则表达式回溯原理法"><a href="#正则表达式回溯原理法" class="headerlink" title="正则表达式回溯原理法"></a>正则表达式回溯原理法</h2><p>比如正则表达式是/ab{1,3}c/ str=”abbc“</p><p><img src="/2019/05/28/半个小时学不会的正则表达式/回溯.png" alt="回溯"></p><p>可以看到第1步我们匹配’a’，匹配成功了，然后下面到匹配’b{1,3}’,也就是1到3次的b,由于这是贪婪匹配,然后第2，3步正常匹配到了’b’，然后往下一步要找最后一次’b’,但是发现是’c’,所以没有匹配成功，这时候回溯，然后开始匹配’c’，去匹配’c’，匹配成功。</p><p>第5步就是回溯。</p><blockquote><p>回溯法也称试探法，它的基本思想是：从问题的某一种状态（初始状态）出发，搜索从这种状态出发<br>所能达到的所有“状态”，当一条路走到“尽头”的时候（不能再前进），再后退一步或若干步，从<br>另一种可能“状态”出发，继续搜索，直到所有的“路径”（状态）都试探过。这种不断“前进”、<br>不断“回溯”寻找解的方法，就称作“回溯法”。<br>— 百度百科</p></blockquote><p>那么当多个贪婪量词挨着，并互相有冲突，那么会怎么样？</p><p>var string = “12345”;<br>var regex = /(\d{1,3})(\d{1,3})/;<br>console.log( string.match(regex) ); //[“12345”, “123”, “45”, index: 0, input: “12345”]</p><p>我们可以看到是谁先谁‘贪’的更多，因为回溯的本质是深度优先算法，所以会先满足前面的。</p><h2 id="位置匹配"><a href="#位置匹配" class="headerlink" title="位置匹配"></a>位置匹配</h2><blockquote><p>正则表达式是匹配模式，要么匹配字符，要么匹配位置。 -老姚</p></blockquote><p>位置包括</p><ol><li>多行开头’^’</li><li>多行结尾’$’</li><li>单词边界’\b’</li><li>非单词边界’\B’</li><li>(?=p)p是子模式，该正则表达式表示p前面的位置</li><li>(?!p)与(?=p)相反。</li></ol><p>比如我们在字符串的开头和结尾加上‘@’</p><pre><code>var reg = /^|$/gvar str = &apos;hello,world&apos;var result = str.replace(reg,&apos;@&apos;)console.log(result)// @hello,world@</code></pre><p>我们在单词边界加上‘@’</p><pre><code>var reg = /\b/gvar str = &apos;hello,world&apos;var result = str.replace(reg,&apos;@&apos;)console.log(result) //@hello@,@world@</code></pre><p>我们在非单词边界加上‘@’</p><pre><code>var reg = /\B/gvar str = &apos;hello,world&apos;var result = str.replace(reg,&apos;@&apos;)console.log(result) // h@e@l@l@o,w@o@r@l@d</code></pre><p>我们在’l’前面加上‘@’</p><pre><code>var reg = /(?=l)/gvar str = &apos;hello,world&apos;var result = str.replace(reg,&apos;@&apos;)console.log(result) // he@l@lo,wor@ld</code></pre><p>我们在非’l’的前面加上‘@’</p><pre><code>var reg = /(?!l)/gvar str = &apos;hello,world&apos;var result = str.replace(reg,&apos;@&apos;)console.log(result) // h@ell@o@,@w@o@rl@d@</code></pre><h2 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h2><p>括号最大的作用是分组，用来匹配子表达式，</p><p>比如匹配12个月，01-12，我们可以分成两种情况。第一种情况：第一个数字0开头的话，第二个数字可以是1-9，然后第二种情况，第一个数字1开头的话，只有0-2</p><p>所以正则表达式为: /(0[1-9])|(1[0-2])/</p><h3 id="第一次课堂作业"><a href="#第一次课堂作业" class="headerlink" title="第一次课堂作业"></a>第一次课堂作业</h3><ol><li>数字的千位分隔符表示法。比如‘12345678’变成‘12,345,678’</li></ol><p><a href="#第一次课堂作业答案">第一次课堂作业答案</a></p><h3 id="第二次课堂作业"><a href="#第二次课堂作业" class="headerlink" title="第二次课堂作业"></a>第二次课堂作业</h3><ol><li>匹配16进制颜色值</li><li>匹配时间（例如23:22）</li><li>匹配日期（例如2019-06-10）</li></ol><p><a href="#第二次课堂作业答案">第二次课堂作业答案</a></p><h1 id="三、-怎么使用正则表达式"><a href="#三、-怎么使用正则表达式" class="headerlink" title="三、 怎么使用正则表达式"></a>三、 怎么使用正则表达式</h1><h2 id="JavaScript-正则"><a href="#JavaScript-正则" class="headerlink" title="JavaScript 正则"></a>JavaScript 正则</h2><h3 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h3><p>js通过RegExp类型支持正则</p><p>var reg = new RegExp(“[bc]at”, “i”)</p><p>上面代码等价于 var reg = /[bc]at/i</p><p>‘i’（不区分大小写）是正则表达式的标志，还有’g’（全局模式）,’m’(多行模式)</p><p>一个正则表达式可以带多个标志</p><pre><code>/[bc]at/ig</code></pre><p>我们上面所接触到的特殊字符<code>({\^$|?+.})</code>，叫做元字符，我们如果要匹配元字符的话需要进行转义。</p><pre><code>匹配第一个&apos;[bc]at&apos;，不区分大小写var reg = /\[bc\]/i</code></pre><h4 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h4><pre><code>语法  reg.exec(str) 返回值：包含第一个匹配项信息的数组，或者nullvar str = &quot;mom and dad and baby&quot;var reg = new RegExp(&quot;mom( and dad( and baby)?)?&quot;, &quot;gi&quot;)var res = reg.exec(str)console.log(res)// [&quot;mom and dad and baby&quot;, &quot; and dad and baby&quot;, &quot; and baby&quot;, index: 0, input: &quot;mom and dad and baby&quot;, groups: undefined]</code></pre><p>exec返回数组的第一项是匹配的整个字符串，然后第二项是第一个捕获组匹配的内容，第三项是第二个捕获组匹配的内容，然后是index属性，为0是因为整个字符串本身和模式匹配。</p><pre><code>var str = &quot;m  mom and dad and baby&quot;var reg = new RegExp(&quot;mom( and dad( and baby)?)?&quot;, &quot;gi&quot;)var res = reg.exec(str)console.log(res)// [&quot;mom and dad and baby&quot;, &quot; and dad and baby&quot;, &quot; and baby&quot;, index: 2, input: &quot;  mom and dad and baby&quot;, groups: undefined]</code></pre><p>因为是第三个字符匹配，所以index2</p><h4 id="test"><a href="#test" class="headerlink" title="test"></a>test</h4><pre><code>语法 reg.test(str) 返回值为布尔值 true和false</code></pre><p>功能： 判断某个字符串是不是匹配某个正则</p><pre><code>var str = &quot;m  mom and dad and baby&quot;var reg = new RegExp(&quot;mom( and dad( and baby)?)?&quot;, &quot;gi&quot;)var res = reg.test(str)console.log(res) // true</code></pre><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="match-reg"><a href="#match-reg" class="headerlink" title="match(reg)"></a>match(reg)</h4><pre><code>语法str.match(str1)str.match(regexp)返回值和exec函数类似</code></pre><p>match()函数有两种参数，第一种是某个字符串str1，去str匹配有没有str1</p><pre><code>var str = &quot;hello&quot;var str1 = &quot;he&quot;var res = str.match(str1)console.log(res)//[&quot;he&quot;, index: 0, input: &quot;hello&quot;, groups: undefined]</code></pre><p>第二种参数是正则表达式</p><pre><code>var str = &quot;m  mom and dad and baby&quot;var reg = new RegExp(&quot;mom( and dad( and baby)?)?&quot;, &quot;i&quot;)var res =str.match(reg)console.log(res)//[&quot;mom and dad and baby&quot;, &quot; and dad and baby&quot;, &quot; and baby&quot;, index: 3, input: &quot;m  mom and dad and baby&quot;, groups: undefined]</code></pre><h4 id="search"><a href="#search" class="headerlink" title="search"></a>search</h4><pre><code>语法str.search(regexp) 如果匹配成功，会返回匹配成功的位置 ，如果匹配失败，则返回-1var str = &quot;hello,world&quot;var reg = /world/ivar res = str.search(reg)console.log(res)// 6var res1 = str.search(/hi/i)console.log(res1) // -1</code></pre><p>注意： search方法会忽略全局标’g’</p><h4 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h4><p>replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。</p><pre><code>语法 str.replace(regexp/substr,replacement) 返回值为一个新字符串var str = &quot;hello,world&quot;var reg = /he/var res = str.replace(reg,&apos;@&apos;)console.log(res) // @llo,world</code></pre><p>replacement 可以是字符串，也可以是函数。如果它是字符串，那么每个匹配都将由字符串替换。但是 replacement 中的 $ 字符具有特定的含义。</p><h4 id="split"><a href="#split" class="headerlink" title="split"></a>split</h4><p><a name="第一次课堂作业答案">第一次课堂作业答案</a></p><ol><li>/(?=(\d{3})+$)/g</li></ol><p><a name="第二次课堂作业答案">第二次课堂作业答案</a></p><ol><li>匹配16进制 /#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})/g</li><li>匹配时间 /([01][0-9]|[2][0-3]):[0-5][0-9]/g</li><li>匹配日期 /[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])/g</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、-为什么用正则表达式&quot;&gt;&lt;a href=&quot;#一、-为什么用正则表达式&quot; class=&quot;headerlink&quot; title=&quot;一、 为什么用正则表达式&quot;&gt;&lt;/a&gt;一、 为什么用正则表达式&lt;/h1&gt;&lt;p&gt;我们去学习某个新技能，肯定是因为它有某些实用价值，它能解决某些问题，能提高某些方面效率。&lt;/p&gt;
&lt;p&gt;正则表达式也是如此。&lt;/p&gt;
&lt;p&gt;正则表达式是匹配模式，&lt;/p&gt;
&lt;p&gt;正则表达式能做的事情：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;验证&lt;ul&gt;
&lt;li&gt;表单验证&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;切分&lt;ul&gt;
&lt;li&gt;“2019-05-25这一天，我们去密室逃脱.”切分出日期&lt;/li&gt;
&lt;li&gt;切分出url的参数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;提取&lt;ul&gt;
&lt;li&gt;”2019-05-28“提取出年月日&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;替换&lt;ul&gt;
&lt;li&gt;替换空格等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总的来说，正则表达式可以用来匹配字符，也可以匹配位置，可以使我们少写很多行代码。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="正则表达式" scheme="http://yoursite.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>js原型和原型链</title>
    <link href="http://yoursite.com/2019/04/30/js%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://yoursite.com/2019/04/30/js原型和原型链/</id>
    <published>2019-04-30T08:32:10.000Z</published>
    <updated>2019-05-06T11:58:23.852Z</updated>
    
    <content type="html"><![CDATA[<h2 id="prtotype和proto"><a href="#prtotype和proto" class="headerlink" title="prtotype和proto"></a>prtotype和<strong>proto</strong></h2><p>说到原型，我们必须要了解prototype和<strong>proto</strong>,这两个很多人可能总是会分不清，接下来我会尽可能以通俗易懂的语言去解释这两者的不同。</p><p>我们看到的大多数引用类型值：函数，数组，对象都是Object的实例，所以Object可以说是一个基本。</p><p>我们去创建一个Object的实例，有两种方法，一种是通过new</p><p>例如：</p><pre><code>var obj = new Object()</code></pre><p>还有一种通过对象字面量</p><pre><code>var obj = {}  </code></pre><p>每个构造函数都有一个原型对象，通过prototype去访问，比如Object.prototype,然后这个原型对象包含一个constructor属性，指向构造函数，也就是Object.prototype.constructor === Object，还包含了一些内置函数，或者自定义的函数。</p><p>然后实例化这个构造函数，得到的实例，有一个<strong>proto</strong>属性指向构造函数的原型对象。</p><p>下面是Object的一个例子。</p><p><img src="/2019/04/30/js原型和原型链/Object的原型.jpg" alt=""></p><p>所以我们可以看到obj.<strong>proto</strong>=== Object.prototype</p><p>总结：</p><ol><li>每个函数都有prototype指向原型对象</li><li>每个对象都有<strong>protot</strong>指向构造函数的原型对象</li></ol><p>在js中，函数是一种特殊的对象，所以函数也有<strong>proto</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;prtotype和proto&quot;&gt;&lt;a href=&quot;#prtotype和proto&quot; class=&quot;headerlink&quot; title=&quot;prtotype和proto&quot;&gt;&lt;/a&gt;prtotype和&lt;strong&gt;proto&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;说到原型，
      
    
    </summary>
    
    
      <category term="javaScript" scheme="http://yoursite.com/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>this和常用css</title>
    <link href="http://yoursite.com/2019/04/26/this%E5%92%8C%E5%B8%B8%E7%94%A8css/"/>
    <id>http://yoursite.com/2019/04/26/this和常用css/</id>
    <published>2019-04-26T01:44:50.000Z</published>
    <updated>2019-04-30T08:32:46.629Z</updated>
    
    <content type="html"><![CDATA[<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><h3 id="第一段代码"><a href="#第一段代码" class="headerlink" title="第一段代码"></a>第一段代码</h3><pre><code>var count = 1;function a () {    this.count ++    console.log(this.count)}a.count = 0;a()console.log(a.count)</code></pre><p>谣言： this指向自身</p><h3 id="第二段代码"><a href="#第二段代码" class="headerlink" title="第二段代码"></a>第二段代码</h3><p>重要的事情说三遍</p><p>this永远指向最后调用它的对象</p><p>this永远指向最后调用它的对象</p><p>this永远指向最后调用它的对象<br><a id="more"></a></p><pre><code>var name = &apos;windowName&apos;;function a () {    var name = &apos;aName&apos;;    console.log(&apos;a: &apos; + this.name)}a()console.log(&apos;window: &apos; + this.name)</code></pre><p>输出？</p><p>两个都是输出windowName，因为a函数在全局对象里调用的，所以this指向的是window，所以第一个代码a函数里this.count++,这个count是全局的coount，也就是window.count,a.count不会变,所以输出的是2，0。然后第二段代码两个输出都是windowName</p><h3 id="第三段代码"><a href="#第三段代码" class="headerlink" title="第三段代码"></a>第三段代码</h3><pre><code>var name = &apos;windowName&apos;;function a () {    var name = &apos;aName&apos;;    console.log(&apos;a: &apos; + this.name);}var obj = {    name: &apos;objName&apos;,    fn: a}obj.fn()</code></pre><p>输出？</p><p>因为最后调用this的对象是obj，所以this指向obj，this.name指的是obj.name</p><h3 id="第四段代码"><a href="#第四段代码" class="headerlink" title="第四段代码"></a>第四段代码</h3><pre><code>var name = &apos;windowName&apos;;function a () {    var name = &apos;aName&apos;;    console.log(&apos;a: &apos; + this.name);    function b() {        console.log(&apos;b: &apos; + this.name)     }     b();}a()console.log(&apos;window: &apos; + this.name)</code></pre><p>输出？</p><p>在js里，函数是一种特殊的对象，只要函数里没有被正常对象包裹着，函数调用this都是指向window。</p><p>所以这里输出都是windowName</p><h3 id="第五段代码"><a href="#第五段代码" class="headerlink" title="第五段代码"></a>第五段代码</h3><pre><code>var name = &apos;windowName&apos;;function a () {    var name = &apos;aName&apos;;    console.log(&apos;a: &apos; + this.name);}var obj = {    name: &apos;objName&apos;,    fn: a}var foo =  obj.fn foo()</code></pre><p>这里我们变形一下第三段代码，将obj.fn赋值给一个变量foo，然后再运行foo，这样会输出什么？</p><p>很神奇，这里会输出的是‘windowName’,而不是‘objName’，这是因为把obj.fn赋值给foo时，是相当于foo指向了fn函数，然后foo时再全局执行的，所以相当于window.foo,所以this指向是window，所以输出的是‘windowName’。</p><h3 id="第六段代码"><a href="#第六段代码" class="headerlink" title="第六段代码"></a>第六段代码</h3><pre><code>var name = &apos;windowName&apos;;setTimeout(function(){    var name = &apos;setTimeout_name&apos;    console.log(this.name)},1000)</code></pre><p>我们之前说过setTimeout是window的方法，setTimeout的回调函数是在window里执行的，所以setTimeout回调函数里的this指向的是window。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>this永远指向最后调用它的对象</p><p>this永远指向最后调用它的对象</p><p>this永远指向最后调用它的对象</p><h2 id="改变this指向"><a href="#改变this指向" class="headerlink" title="改变this指向"></a>改变this指向</h2><ol><li>使用es6的箭头函数</li><li>在函数内部使用_this = this</li><li>使用apply，call，bind</li><li>new实例话一个对象。 </li></ol><h3 id="es6的箭头函数"><a href="#es6的箭头函数" class="headerlink" title="es6的箭头函数"></a>es6的箭头函数</h3><p>es6的箭头函数的this始终指向的是函数定义时的this，而非执行时。</p><pre><code>var name = &apos;windowName&apos;;var obj = {    name: &apos;objName&apos;,    fn: function() {        setTimeout(()=&gt;{            console.log(this.name)        },0)    }}obj.fn()</code></pre><h3 id="this-that-self"><a href="#this-that-self" class="headerlink" title="_this,that,self"></a>_this,that,self</h3><p>这种方法最常见了，用一个变量_this,that,self保存一下调用这个函数的对象，然后在函数里用这个变量</p><pre><code>var name = &apos;windowName&apos;;var obj = {    name: &apos;objName&apos;,    fn: function() {        var _this = this;        setTimeout(function(){            console.log(_this.name)        },0)    }}obj.fn()</code></pre><h3 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call,apply,bind"></a>call,apply,bind</h3><pre><code>var name = &apos;window_name&apos;var a = {    name: &apos;a_name&apos;,    fn: function(age){        console.log(this.name);    }}var b = {    name: &apos;b_name&apos;,    fn1: function(){        console.log(this.name);    }}a.fn.apply(b)b.fn1.apply(a)b.fn1.apply(this)a.fn.call(b)b.fn1.call(a)b.fn1.call(this)a.fn.bind(b)()b.fn1.bind(a)()b.fn1.bind(this)()</code></pre><p>apply 语法 fun.apply(thisArg, [argsArr])</p><ul><li>thisArg fun函数运行时指定的this值</li><li>argsArr 一个数组或者类数组对象。</li></ul><p>call 语法 fun.call(thisArgs, arg1, arg2…)</p><p>apply和call的区别是call是接受多个参数，apply接受一个参数数组</p><pre><code>var a = {    name: &apos;a_name&apos;,    fn: function(age, sex){        debugger        var age = age;var sex = sex;        console.log(this.name);    }}var b = {    name: &apos;b_name&apos;,    fn1: function(age, sex){        debugger        console.log(this.name);    }}a.fn.apply(b,[ 11, &apos;man&apos;])b.fn1.call(b,  11, &apos;man&apos;)</code></pre><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>我们经常说没有对象，new一个就行。这里的new将this指向</p><pre><code>var Person (name) {    this.name = name}new Person(&apos;zzilcc&apos;)</code></pre><p>new 做了什么，下面解释一下</p><ol><li>创建了一个空对象obj</li><li>把obj的_proto_z指向Person的原型对象prototype，此时便建立了obj对象的原型链obj-&gt;Person.prototype-&gt;Object.prototype-&gt;null</li><li>在obj的执行环境调用Person的方法，也就是Person.call(obj,’zzilcc’),然后执行obj.name = ‘zzilcc’</li><li>将obj当作返回值返回</li></ol><p>所以我们用一个变量去接受下这个obj</p><pre><code>var person1 = new Person(&apos;zzilcc&apos;)person1.name === &apos;zzilcc&apos; // true</code></pre><h2 id="常用css属性"><a href="#常用css属性" class="headerlink" title="常用css属性"></a>常用css属性</h2><ol><li><p>css背景属性</p><ul><li>background: #fff url() center 100% no-repeat<ul><li>background-color</li><li>background-image</li><li>background-position</li><li>background-size</li><li>background-repeat</li></ul></li></ul></li><li><p>css边框属性</p><ul><li>border<ul><li>border-color</li><li>border-width</li><li>border-style</li></ul></li><li>border-top: 1px solid #fff<ul><li>border-top-color: #fff</li><li>border-top-width: 1px</li><li>border-top-style: solid(实线)/dotted(点状)/dashed(虚线)</li></ul></li><li>border-right<ul><li>border-right-color</li><li>border-right-width</li><li>border-right-style</li></ul></li><li>border-bottom<ul><li>border-bottom-color</li><li>border-bottom-width</li><li>border-bottom-style</li></ul></li><li>border-left<ul><li>border-left-color</li><li>border-left-width</li><li>border-left-style</li></ul></li></ul></li><li><p>css尺寸属性</p><ul><li>height</li><li>max-height</li><li>min-height</li><li>width</li><li>min-width</li><li>max-width</li></ul></li><li><p>css字体属性</p><ul><li>font<ul><li>font-size</li><li>font-family</li><li>font-style</li><li>font-weight</li></ul></li></ul></li><li><p>css外边距属性</p><ul><li>margin<ul><li>margin-top</li><li>margin-right</li><li>margin-bottom</li><li>margin-left</li></ul></li></ul></li><li><p>css内边距属性</p><ul><li>padding<ul><li>padding-top</li><li>padding-right</li><li>padding-bottom</li><li>padding-left</li></ul></li></ul></li><li><p>css定位属性</p><ul><li>position</li><li>top</li><li>right</li><li>bottom</li><li>left</li><li>overflow</li><li>float</li><li>display</li><li>z-index</li><li>vertical-align</li><li>cursor: default|pointer</li></ul></li><li><p>css文本属性</p><ul><li>color: #fff; // 颜色</li><li>line-height:40px; //行高 </li><li>text-align: left|center|right// 规定文本的水平对齐方式</li><li>text-indent: 2px|1% // 属性规定文本块中首行文本的缩进。</li><li>white-space:nowrap //     文本不会换行，文本会在在同一行上继续，直到遇到 <br> 标签为止</li><li>text-overflow:ellipsis // 规定当文本溢出包含元素时发生的事情。</li><li>word-break: normal|break-all|keep-all;// 规定非中日韩文本的换行规则。</li><li>word-wrap: normal|break-word // 单词分割且换行</li></ul></li></ol><h2 id="常用css解决某些问题"><a href="#常用css解决某些问题" class="headerlink" title="常用css解决某些问题"></a>常用css解决某些问题</h2><ol><li>css画各种形状</li></ol><h3 id="圆形"><a href="#圆形" class="headerlink" title="圆形"></a>圆形</h3><pre><code>div {    width: 100px;    height: 100px;    background: red;    border-radius: 50%;}&lt;div&gt;&lt;/div&gt;</code></pre><h3 id="三角形"><a href="#三角形" class="headerlink" title="三角形"></a>三角形</h3><pre><code>div {      width: 0;      border-left: 50px solid transparent;      border-right: 50px solid transparent;      border-bottom: 100px solid red;}</code></pre><ol start="2"><li><p>省略号</p><h3 id="省略号"><a href="#省略号" class="headerlink" title="省略号"></a>省略号</h3><pre><code>max-width: 100px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap</code></pre></li></ol><h2 id="绑定数据"><a href="#绑定数据" class="headerlink" title="绑定数据"></a>绑定数据</h2><h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><p>git reflog &amp;&amp; git reset –hard ‘哈希数’</p><p>遇到一些奇怪的现象时我们可以用git reflog 找到我们最新的一次commit时的哈希数。</p><p>然后灭霸一个响指可以消灭一半的‘人’</p><p>我们git reset –hard ‘哈希数’则能让我们回到刚刚commit完的时候，仿佛之前进行了一切操作犹如云烟飘散。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;this&quot;&gt;&lt;a href=&quot;#this&quot; class=&quot;headerlink&quot; title=&quot;this&quot;&gt;&lt;/a&gt;this&lt;/h2&gt;&lt;h3 id=&quot;第一段代码&quot;&gt;&lt;a href=&quot;#第一段代码&quot; class=&quot;headerlink&quot; title=&quot;第一段代码&quot;&gt;&lt;/a&gt;第一段代码&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;var count = 1;
function a () {
    this.count ++
    console.log(this.count)
}
a.count = 0;
a()
console.log(a.count)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;谣言： this指向自身&lt;/p&gt;
&lt;h3 id=&quot;第二段代码&quot;&gt;&lt;a href=&quot;#第二段代码&quot; class=&quot;headerlink&quot; title=&quot;第二段代码&quot;&gt;&lt;/a&gt;第二段代码&lt;/h3&gt;&lt;p&gt;重要的事情说三遍&lt;/p&gt;
&lt;p&gt;this永远指向最后调用它的对象&lt;/p&gt;
&lt;p&gt;this永远指向最后调用它的对象&lt;/p&gt;
&lt;p&gt;this永远指向最后调用它的对象&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="this | css" scheme="http://yoursite.com/tags/this-css/"/>
    
  </entry>
  
  <entry>
    <title>js作用域和闭包</title>
    <link href="http://yoursite.com/2019/04/15/js%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/"/>
    <id>http://yoursite.com/2019/04/15/js作用域和闭包/</id>
    <published>2019-04-15T11:28:34.000Z</published>
    <updated>2019-04-19T10:02:35.478Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、js引擎执行过程"><a href="#一、js引擎执行过程" class="headerlink" title="一、js引擎执行过程"></a>一、js引擎执行过程</h2><pre><code>var a;console.log(a);console.log(b);</code></pre><p>输出？</p><pre><code>a = 2;var a;console.log(a);</code></pre><p>输出？</p><pre><code>console.log(a);var a = 2;</code></pre><p>输出？</p><p>我们之前说过js代码是由上到下去执行的，但是上面代码的输出结果好像显示的不是这样，其实不是的，js代码确实是由上到下去执行的，只是执行的不是我们直接写的代码，而是我们代码通过编译后生成的代码。</p><p>我们可以将js引擎执行过程分为三个阶段，分别是语法分析，预编译和解释执行阶段。<br><a id="more"></a></p><h2 id="（1）语法分析"><a href="#（1）语法分析" class="headerlink" title="（1）语法分析"></a>（1）语法分析</h2><p>语法分析主要是对代码进行语法检查，如果语法有错，会抛出错误，如果没有错，则进入预编译阶段，</p><h2 id="（2）预编译"><a href="#（2）预编译" class="headerlink" title="（2）预编译"></a>（2）预编译</h2><p>我们可以将预编译分成四个步骤</p><ol><li>创建GO（全局）/ AO（活动）对象</li><li>找形参和变量声明，将变量和形参名作为GO/AO属性名，值为undefined</li><li>将实参和形参统一</li><li>在函数体里找函数声明，值赋予函数体</li></ol><h3 id="函数声明和函数表达式的区别"><a href="#函数声明和函数表达式的区别" class="headerlink" title="函数声明和函数表达式的区别"></a>函数声明和函数表达式的区别</h3><p>主要看第一个词是不是function,第一个词是function为函数声明，其他的都是函数表达式</p><pre><code>function () {} // 函数声明var a = function () {} // 函数表达式</code></pre><p>示例： （代码已经过语法检查，没有语法错误）</p><pre><code>function a () {    var b =10;    function c () {        var b =123;        console.log(b);        function d (){}    }    console.log(b);    console.log(c);}var b =123;a();</code></pre><ol><li><p>一进来默认的是全局对象GO，在此是window对象</p></li><li><p>找变量声明b，将其作为window的属性，值为undefined </p></li><li><p>找函数声明，发现a函数, 将其作为window属性，值为a函数的函数体</p></li></ol><p>此时Go对象为： </p><pre><code>GO = {    b: undefined,    a: function () {        var b =10;        function c () {            var b =123;            console.log(b);            function d (){}        }        console.log(b);        console.log(c);    }}</code></pre><p>所以此时代码可以理解成 </p><pre><code>var b;var a = function(){    // a的函数体};b = 123;a();</code></pre><h2 id="（3）解释执行"><a href="#（3）解释执行" class="headerlink" title="（3）解释执行"></a>（3）解释执行</h2><p>此时引擎开始执行代码</p><p>把123赋值给b，运行a，运行a之前也会进行预编译。</p><pre><code>function a () {    var b =10;    function c () {        var b =123;        console.log(b);        function d (){}    }    console.log(b);    console.log(c);}</code></pre><ol><li>新建一个AO对象</li><li>查找变量声明，发现b,给AO对象添加一个属性b，值为undefined</li><li>查找函数声明，发现c函数，给AO对象添加一个属性c，值为c函数体</li></ol><p>AO对象</p><pre><code>AO = {    b: undefined,    c: function () {        var b =123;        console.log(b);        function d (){}    }}</code></pre><p>此时代码可以理解成</p><pre><code>function a () {    var b;    function c () {        var b =123;        console.log(b);        function d (){}    }    b = 10;    console.log(b);    console.log(c);}</code></pre><p>然后开始执行a函数</p><h2 id="变量和函数提升的一些注意事项"><a href="#变量和函数提升的一些注意事项" class="headerlink" title="变量和函数提升的一些注意事项"></a>变量和函数提升的一些注意事项</h2><p>重名的声明后一个会覆盖前一个</p><pre><code>function foo () {    console.log(a)}function foo () {    console.log(b)}console.log(foo)</code></pre><p>如果函数声明和变量声明重名了，函数声明会优先</p><pre><code>function foo () {}var foo;console.log(foo)</code></pre><h2 id="二、js作用域"><a href="#二、js作用域" class="headerlink" title="二、js作用域"></a>二、js作用域</h2><h3 id="作用域是什么？"><a href="#作用域是什么？" class="headerlink" title="作用域是什么？"></a>作用域是什么？</h3><p>作用域是根据名称查找变量一套规则。可以把作用域假设成一个管家。</p><h3 id="作用域的类型"><a href="#作用域的类型" class="headerlink" title="作用域的类型"></a>作用域的类型</h3><p>作用域可以分为全局作用域和局部作用域。</p><p>在执行<code>&lt;script&gt;&lt;/script&gt;</code>块或者js文件时，会生成一个全局作用域和一个window对象，在全局作用域里定义的变量和函数会变成window对象的属性。</p><p>局部作用域包括函数作用域和块级作用域</p><p>每次声明一个函数，就会生成一个函数作用域。</p><p>块级作用域： </p><pre><code>1. with（不推荐）2. try/catch catch会创建一个块级作用域3. let</code></pre><p>注意： 作用域可以嵌套，但是不能重叠。</p><pre><code>var a = 1;function get2 () {    var a = 2;    console.log(&apos;get2 a: &apos;+ a);    function get3 () {        console.log(&apos;get3 a: &apos; + a);    }    get3();    console.log(&apos;get3.prototype: &apos;);    console.log(get3.prototype);}function set2 () {}console.log(&apos;get2.prototype: &apos;);console.log(get2.prototype);get2();</code></pre><p>输出结果</p><p><img src="/2019/04/15/js作用域和闭包/作用域1.png" alt=""></p><p>可以看到我们在全局声明了一个函数叫get2，产生了一个函数作用域，这个作用域是被全局作用域包裹着，然后在get2函数里我们也声明了一个get3函数，也产生了一个函数作用域，这个作用域是被get2的作用域包裹着，所以是一层套一层。</p><p><img src="/2019/04/15/js作用域和闭包/作用域嵌套.jpg" alt=""></p><p>###执行环境和作用域</p><p>执行环境是js中很重要的一个概念，他包括三部分： 变量对象（AO），作用域链，this。</p><p>执行环境有三个类型</p><pre><code>1. 全局执行环境 （js默认执行环境，在web浏览器的话是window对象）2. 函数执行环境 （每个函数自己的执行环境）3. eval执行环境</code></pre><p><img src="/2019/04/15/js作用域和闭包/eventLoop.png" alt=""></p><p>每个执行环境都有一个变量对象，环境中定义的函数和变量都保存在这个对象中。</p><pre><code>var c = 1;function a () {    console.log(c)    return function b () {        console.log(c)    }}a()let aa = a()aa()</code></pre><p>当执行到一个函数a时，该函数a的执行环境会被推进一个执行栈，函数a里调用了其他函数b的话，会将调用的函数b的执行环境推进栈，然后执行完b函数的代码后，b执行环境被推出栈，然后继续执行a函数的代码，a执行完后，把a的执行环境推出栈，以此类推。</p><p>被推出栈的执行环境会被销毁，保存在其中的所有变量和函数定义也会被销毁，全局执行环境在页面关闭或者浏览器关闭时被销毁。</p><p><img src="/2019/04/15/js作用域和闭包/执行栈.jpg" alt=""></p><pre><code>function aa () {    for(var a = 0; a &lt; 5; a++){        console.log(a)    }}console.log(a)for(var b = 0; b &lt; 5; b++){    console.log(b)}console.log(b)</code></pre><p>在函数外部是不能访问到函数内部定义的变量，所以第一个输出a会报错。然后b会输出5，因为js没有块级作用域，所以声明的b是被当作window的属性的，所以可以访问到。</p><p><img src="/2019/04/15/js作用域和闭包/作用域链.jpg" alt=""></p><p>当代码在一个环境执行的时候会创建变量对象的一个作用域链，全局执行环境的变量对象始终都是作用域链的最后一个。</p><p>很明显，a函数有自己的作用域，然后a函数又是在全局定义的，所以被包裹在全局作用域里，所以a的作用域链是自身作用域-全局作用域，在a中查找一个变量是，会在自身作用域查找（也就是找自身的变量对象里有没有这个属性），如果没有查找到就沿着作用域链上去找，找他的上一级作用域链，在这里是全局作用域。</p><p>我们之前说过作用域根据名称查找变量一套规则，可以把作用域理解成管家。</p><p>全局执行环境是一个酒店，函数执行环境是一个房间。</p><p>全局作用域是总管家，a函数作用域是a管家，依次类推。</p><p>我们以下面例子来说：</p><pre><code>var c = 1;function a () {    console.log(c)    return function b () {        console.log(c)    }}a()let aa = a()aa()</code></pre><p>js引擎执行代码，从上到下执行，执行到a函数时发现<code>console.log(a)</code>，这时候引擎和作用域的对话如下：</p><p><img src="/2019/04/15/js作用域和闭包/js引擎与作用域聊天.jpeg" alt=""></p><p>b函数里<code>console.log(c)</code>里查找c以此类推，一层层找。如果在某个作用域里找到了，就不会继续找了，只会返回当前找到的值。</p><p>作用域链是单向的，只能从内到外，外面的执行环境是访问不到函数内部的变量。</p><h2 id="三、闭包"><a href="#三、闭包" class="headerlink" title="三、闭包"></a>三、闭包</h2><pre><code>function foo () {    var a = 2;    function bar () {        console.log(a)    }    return bar;}var f = foo();f();</code></pre><p>我们来执行一下这段代码，</p><p>首先是语法检查，看有没有语法错误，没有，下一步</p><p>创建了全局对象GO，然后进行声明查找，先找变量声明，发现var a = foo();然后声明了一个a，作为GO的属性，值为undefined，然后查找函数声明，发现function foo，然后声明了一个函数foo作为GO的属性，值为foo的函数体。</p><p>然后开始解释执行代码，从上至下，首先将全局执行环境推进栈。</p><p>然后var f = foo() 执行foo函数。</p><p>将foo函数执行环境推进执行栈，然后进行第1-第2步，然后开始执行foo预编译后的代码，给a赋值为2，然后返回了一个函数bar。</p><p>将foo返回的bar赋值给f。这时候foo函数执行完，按照之前我们说的，函数执行完对应函数执行环境栈会被推出执行栈，但是这里没有，这就是闭包的神奇之处。</p><p>f()执行f函数，也就是foo里的bar函数。</p><p>在foo()执行之后，为什么内部作用域还在，没有被回收，是因为有‘人’在使用这个作用域，也就是f()，因为他保持着对foo作用域的引用，所以这个作用域没有被回收，这个引用就是闭包。</p><pre><code>var fn;function foo () {    var a = 2;    function baz () {        console.log(a);    }    fn = baz;}function bb () {    fn();}foo();bb();</code></pre><p>也就是，将函数里的内部函数传递到他定义时所在定义域A之前，这个函数都会保留着对原始定义域A的引用，无论在何时调用这个内部函数都会使用闭包。</p><pre><code>function sleep (message) {    setTimeout(function(){        console.log(message)    }, message)}sleep(&apos;hello&apos;);</code></pre><p>这里也体现了闭包，我们可以先把代码再分解一下。</p><pre><code>function sleep (message) {    function a () {        console.log(message)    }    setTimeout(a, 1000)}sleep(&apos;hello&apos;);</code></pre><p>我们在sleep函数里定义里一个函数a，然后将这个函数a当作参数传给了setTimeout函数，然后执行sleep函数，设置了一个定时器，此时sleep运行完了，理论上他的执行环境要被弹出执行栈，但是因为1秒后这个setTimeout函数时在全局执行环境里去执行的，也就是不是在sleep函数里执行，所以a函数当作参数执行时会保留着对sleep作用域的引用，所以此时输出message是‘hello’。</p><p>这就是闭包的神奇之处。</p><pre><code>for (var i = 0; i &lt; 5; i++) {    setTimeout(function(){        console.log(i)    }, i * 1000)}</code></pre><p>上篇博客说这个程序是隔秒输出5，那么我们想要隔秒输出0，1，2，3，4呢？</p><p>这时候我们就可以利用函数作用域了，我们可以在for循环里定义一个函数，然后将每次循环的i传进函数里，函数里用一个变量存储，这样就能保存每次的i的值。</p><pre><code>for (var i = 0; i &lt; 5; i++) {    function aa(){        var j = i;        setTimeout(function(){            console.log(j)        }, j * 1000)    }    aa(i)}</code></pre><p>然后我们再优化一下这个函数，</p><pre><code>for (var i = 0; i &lt; 5; i++) {    function aa(j){        setTimeout(function(){            console.log(j)        }, j * 1000)    }    aa(i)}</code></pre><p>在aa函数的形参里接收i的值。</p><p>然后我们再可以优化一下</p><pre><code>for (var i = 0; i &lt; 5; i++) {    (function(j){        setTimeout(function(){            console.log(j)        }, j * 1000)    })(i)}</code></pre><p>在这里我们定义了一个匿名函数，然后立即执行了它。</p><p>上面的立即执行函数还有一种写法，把(i)放到（）里</p><pre><code>for (var i = 0; i &lt; 5; i++) {    (function(j){        setTimeout(function(){            console.log(j)        }, j * 1000)    }(i))}</code></pre><p>一个函数怎么执行，一般是函数名+(),比如前面的aa(),然后我们要怎么让一个匿名函数执行呢，匿名函数没有函数名，其实只要把匿名函数的函数声明转换成一个函数表达式然后再加()就可以。</p><p>那么问题就变成了怎么把函数声明变成函数表达式</p><p>上面代码里用一对括号把函数括起来是其中一种方法，在函数前加上一元操作符<code>+</code>,<code>-</code>,<code>!</code>也可以将函数声明转换成表达式。</p><pre><code>-function    (j) {    console.log(j)}(1)+function    (j) {    console.log(j)}(1)!function    (j) {    console.log(j)}(1)</code></pre><p>但是不推荐用<code>+,-,!</code>，因为如果函数有返回值的话，<code>+,-,!</code>会和返回值进行操作。</p><pre><code>var result = -function    (j) {    return j}(1) // result: -1</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、js引擎执行过程&quot;&gt;&lt;a href=&quot;#一、js引擎执行过程&quot; class=&quot;headerlink&quot; title=&quot;一、js引擎执行过程&quot;&gt;&lt;/a&gt;一、js引擎执行过程&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;var a;
console.log(a);
console.log(b);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a = 2;
var a;
console.log(a);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(a);
var a = 2;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出？&lt;/p&gt;
&lt;p&gt;我们之前说过js代码是由上到下去执行的，但是上面代码的输出结果好像显示的不是这样，其实不是的，js代码确实是由上到下去执行的，只是执行的不是我们直接写的代码，而是我们代码通过编译后生成的代码。&lt;/p&gt;
&lt;p&gt;我们可以将js引擎执行过程分为三个阶段，分别是语法分析，预编译和解释执行阶段。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="js作用域 闭包" scheme="http://yoursite.com/tags/js%E4%BD%9C%E7%94%A8%E5%9F%9F-%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript运行机制</title>
    <link href="http://yoursite.com/2019/04/12/JavaScript%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/04/12/JavaScript运行机制/</id>
    <published>2019-04-11T16:13:56.000Z</published>
    <updated>2019-04-15T13:15:23.609Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-1-前言"><a href="#0-1-前言" class="headerlink" title="0.1. 前言"></a>0.1. 前言</h2><h3 id="0-1-1-ES5，ES6和JavaScript的关系"><a href="#0-1-1-ES5，ES6和JavaScript的关系" class="headerlink" title="0.1.1. ES5，ES6和JavaScript的关系"></a>0.1.1. ES5，ES6和JavaScript的关系</h3><p>众所周知，JavaScript是一位网景公司的奇人布兰登艾奇花了十天就开发出来的。一开始JavaScript叫LiveScript，当时Java特别火，为了蹭个热度，网景公司将其改名成了JavaScript。</p><p>微软在IE3的时候加入了JavaScript的实现，为了避免纠纷，命名为JScript。还有其他公司自己研发了JavaScript，所以这样兼容性就称为一个很头疼的事情，所以业内人士强烈呼吁定制一个标准。</p><p>1996年，网景公司将JavaScript提交给国际标准化组织ECMA，次年，该组织发布了浏览器脚本语言的标准，并将这种语言称为ECMAScript，也就是我们常说的ES。所以ES是一种标准，JavaScript是ES的实现。</p><p>ES5是指ECMAScript5.0，ECMAScript5.1版本，ES6是泛指，指5.1版本以后的JavaScript的下一代标准。</p><a id="more"></a><h2 id="0-2-编译性语言-vs-解释性语言"><a href="#0-2-编译性语言-vs-解释性语言" class="headerlink" title="0.2. 编译性语言 vs 解释性语言"></a>0.2. 编译性语言 vs 解释性语言</h2><p>高级语言要经过翻译，称为机器语言，然后才能被计算机识别。</p><p>翻译分为编译和解释。</p><p>编译性语言在程序运行前有一个专门的编译过程，把程序编译成计算机可执行的文件，比如.exe,以后要运行的话就不用在编译了，直接执行就可以了。Java就是比较典型的编译性语言。Java有一句很有名的口号：一次编译，到处运行。</p><p>解释性语言也是要转换成计算机能识别的语言，只是它是在代码运行时执行，所以需要将解释器安装在环境中。</p><p>JavaScript，python是解释性语言。</p><p>需要注意的一点是解释性语言不是说没有编译，它们有的会有编译特性，即时编译的。</p><h2 id="0-3-浏览器内核"><a href="#0-3-浏览器内核" class="headerlink" title="0.3. 浏览器内核"></a>0.3. 浏览器内核</h2><p>浏览器内核指的是浏览器运行的最核心的程序，分为两个部分，JS引擎和渲染引擎。</p><p><img src="/2019/04/12/JavaScript运行机制/浏览器内核.jpg" alt=""></p><p><img src="/2019/04/12/JavaScript运行机制/js引擎.jpg" alt=""></p><p>JavaScript引擎的主要作用是，读取网页中的JavaScript代码，对其处理后运行。</p><h2 id="0-4-引子"><a href="#0-4-引子" class="headerlink" title="0.4. 引子"></a>0.4. 引子</h2><pre><code>console.log(0)setTimeout(function(){    console.log(1)},0)console.log(2)</code></pre><p>输出结果是什么？</p><h2 id="0-5-单线程"><a href="#0-5-单线程" class="headerlink" title="0.5. 单线程"></a>0.5. 单线程</h2><p>单线程说明在同一个时间里只能做一件事情，有人会说js为什么是单线程，不能多线程，多线程效率不更高吗。原因是js主要用来做页面交互，操作DOM。如果是多线程的话，有可能会发生两个线程同时对一个DOM进行操作，比如一个是添加了一个节点，一个是删除节点，那么浏览器怎么去执行？所以为了避免复杂性，js就是单线程的。</p><h2 id="0-6-事件循环机制"><a href="#0-6-事件循环机制" class="headerlink" title="0.6. 事件循环机制"></a>0.6. 事件循环机制</h2><p>事件循环机制分为浏览器和node事件循环机制，在此主要介绍浏览器事件循环机制。</p><p><img src="/2019/04/12/JavaScript运行机制/eventLoop.png" alt=""></p><p>在js中任务分为两种，同步任务和异步任务。</p><p>所谓同步就是函数或方法执行时要接收到返回的值或者消息才会往下执行，相当于打电话，你说一句，我说一句，一句接一句。</p><p>异步则是函数或方法执行时，不需要等待收到返回的信息和值，直接向系统委托一个异步过程，系统接收到返回结果时，系统会触发委托的异步过程，从而完成一个完整的流程。</p><p>一般异步任务有：</p><ol><li>setTimeout和setlnterval</li><li>DOM事件</li><li>ES6中的Promise</li><li>Ajax异步请求</li></ol><p>事件循环机制的流程是这样的：</p><ol><li>主流程上有一个执行栈，同步任务依次进栈排队，任务从栈的顶部开始执行，执行完的任务会被弹出去。</li><li>异步任务有了结果的时候，会在任务队列里放入‘回调’事件。</li><li>执行栈里所有的同步任务运行完后，会去任务队列里查看，是否还有任务，如果有的话就会将任务读进执行栈中，开始执行。</li><li>主线程不断重复以上3个行为。</li></ol><p>因为这个过程是循环不断的，所以称为事件循环机制。</p><h3 id="0-6-1-练习题-写出以下输出结果"><a href="#0-6-1-练习题-写出以下输出结果" class="headerlink" title="0.6.1. 练习题 写出以下输出结果"></a>0.6.1. 练习题 写出以下输出结果</h3><p>练习题1</p><pre><code>console.log(&apos;a&apos;)while(true){}console.log(&apos;b&apos;)</code></pre><p>练习题2</p><pre><code>console.log(&apos;1&apos;)setTimeout(function(){     console.log(&apos;2&apos;) },0)while(true){}</code></pre><p>练习题3</p><pre><code>for(var i = 0; i &lt; 5; i++) {    setTimeout(function(){        console.log(i)    },1000)} </code></pre><p>练习题4</p><pre><code>for(var i = 0; i &lt; 5; i++) {    setTimeout(function(){        console.log(i)    },1000 * i)} </code></pre><p>作业</p><p>怎么依次隔秒输出0，1，2，3，4</p><h2 id="0-7-css常见布局"><a href="#0-7-css常见布局" class="headerlink" title="0.7. css常见布局"></a>0.7. css常见布局</h2><h3 id="0-7-1-上定高，中间分左右，左定宽，右自适应"><a href="#0-7-1-上定高，中间分左右，左定宽，右自适应" class="headerlink" title="0.7.1. 上定高，中间分左右，左定宽，右自适应"></a>0.7.1. 上定高，中间分左右，左定宽，右自适应</h3><h3 id="0-7-2-div垂直水平居中"><a href="#0-7-2-div垂直水平居中" class="headerlink" title="0.7.2. div垂直水平居中"></a>0.7.2. div垂直水平居中</h3><ol><li><p>行内元素居中 缺点： 会继承，影响到后代行内内容，子元素大于父元素宽度时无效</p><p> text-align: center</p></li><li><p>单个块级元素 必须定宽，且元素宽度要小于父元素宽度</p><p> width: 100px // 定宽<br> margin: 0 auto</p></li><li><p>多个块级元素</p><p> <code>#parant</code> { text-aligin: center}</p><p> <code>#son</code> {display: inline-block}</p></li><li><p>使用绝对定位 （子元素定宽定高）</p><p> <code>#parant</code> { </p><pre><code>position: relativewidth: 100px</code></pre><p> }</p><p> <code>#son</code> {</p><pre><code>position: absoluteleft: 50%width： 100pxheight：100pxmargin-left: -50px // 或者translateX(-50%)margin-top：-50px; // translateY(-50%)</code></pre><p> }</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0-1-前言&quot;&gt;&lt;a href=&quot;#0-1-前言&quot; class=&quot;headerlink&quot; title=&quot;0.1. 前言&quot;&gt;&lt;/a&gt;0.1. 前言&lt;/h2&gt;&lt;h3 id=&quot;0-1-1-ES5，ES6和JavaScript的关系&quot;&gt;&lt;a href=&quot;#0-1-1-ES5，ES6和JavaScript的关系&quot; class=&quot;headerlink&quot; title=&quot;0.1.1. ES5，ES6和JavaScript的关系&quot;&gt;&lt;/a&gt;0.1.1. ES5，ES6和JavaScript的关系&lt;/h3&gt;&lt;p&gt;众所周知，JavaScript是一位网景公司的奇人布兰登艾奇花了十天就开发出来的。一开始JavaScript叫LiveScript，当时Java特别火，为了蹭个热度，网景公司将其改名成了JavaScript。&lt;/p&gt;
&lt;p&gt;微软在IE3的时候加入了JavaScript的实现，为了避免纠纷，命名为JScript。还有其他公司自己研发了JavaScript，所以这样兼容性就称为一个很头疼的事情，所以业内人士强烈呼吁定制一个标准。&lt;/p&gt;
&lt;p&gt;1996年，网景公司将JavaScript提交给国际标准化组织ECMA，次年，该组织发布了浏览器脚本语言的标准，并将这种语言称为ECMAScript，也就是我们常说的ES。所以ES是一种标准，JavaScript是ES的实现。&lt;/p&gt;
&lt;p&gt;ES5是指ECMAScript5.0，ECMAScript5.1版本，ES6是泛指，指5.1版本以后的JavaScript的下一代标准。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>D3.js画3D方柱</title>
    <link href="http://yoursite.com/2019/03/28/D3.js%E7%94%BB3D%E6%96%B9%E6%9F%B1/"/>
    <id>http://yoursite.com/2019/03/28/D3.js画3D方柱/</id>
    <published>2019-03-28T08:24:45.000Z</published>
    <updated>2019-03-28T09:45:39.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="D3-js入门实例-3D方柱"><a href="#D3-js入门实例-3D方柱" class="headerlink" title="D3.js入门实例-3D方柱"></a>D3.js入门实例-3D方柱</h2><p>最近由于项目需要去实现3D可视化，所以学了一下D3.js。使用版本是v4.x。<br><a id="more"></a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们先定义下要引用的参数</p><pre><code>let param = {    data: [        {            xName: &apos;1月&apos;，            value: &apos;0.01&apos;        },        {            xName: &apos;2月&apos;，            value: &apos;0.1&apos;        },        {            xName: &apos;3月&apos;，            value: &apos;1000&apos;        },        {            xName: &apos;4月&apos;，            value: &apos;7&apos;        },        {            xName: &apos;5月&apos;，            value: &apos;22&apos;        },        {            xName: &apos;6月&apos;，            value: &apos;90&apos;        },        {            xName: &apos;7月&apos;，            value: &apos;700&apos;        }    ],    padding: { // svg内部padding        top: 20,        bottom: 20,        left: 20,        right: 20    },    svgHeight: 500, // svg高度    svgWdith: 500, // svg宽度    id: &apos;#js-svg&apos; // svg标签}</code></pre><h3 id="比例尺"><a href="#比例尺" class="headerlink" title="比例尺"></a>比例尺</h3><p>我们画一个柱状图，y轴的数据大小如上，最大值和最小值之间间隔由差不多1000，我们不可能在y轴坐标上显示0到1000都显示出来,这时候我们需要一个映射关系，由某个区域的值去映射到另一个区域，但是它们之间的关系不变。</p><p>在这里，我主要介绍两个常用比例尺，线性比例尺和序数比例尺。</p><p>这个实例中，我们X轴用的是序数比例尺，Y轴用的是线性比例尺。</p><h4 id="线性比例尺（Y轴）"><a href="#线性比例尺（Y轴）" class="headerlink" title="线性比例尺（Y轴）"></a>线性比例尺（Y轴）</h4><p>定义一个Y轴比例尺函数</p><pre><code>let drawYscale () {}</code></pre><p>在函数里定义一个线性比例尺</p><pre><code>d3.scaleLinear()</code></pre><p>接下来我们要规定其定义域 domain(arr)</p><pre><code>d3.scaleLinear().domain(param.data.map((d) =&gt; {    return d.value}))</code></pre><p>注意：这里domain(arr)接受一个数值数组，数组需要包含两个及两个以上值，而且如果不是数值会被强制转换成数值类型。多个值会形成分段比例尺。</p><p>然后我们规定值域 range([range])</p><pre><code>d3.scaleLinear().domain(param.data.map((d) =&gt; {    return d.value})).range([svgHeight - padding.top - padding.bottom, 0])</code></pre><p>range和domain一样，接受一个数组，和domain不一样的是数组不一定是要数值类型。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;D3-js入门实例-3D方柱&quot;&gt;&lt;a href=&quot;#D3-js入门实例-3D方柱&quot; class=&quot;headerlink&quot; title=&quot;D3.js入门实例-3D方柱&quot;&gt;&lt;/a&gt;D3.js入门实例-3D方柱&lt;/h2&gt;&lt;p&gt;最近由于项目需要去实现3D可视化，所以学了一下D3.js。使用版本是v4.x。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="D3.js" scheme="http://yoursite.com/tags/D3-js/"/>
    
  </entry>
  
  <entry>
    <title>Git浅解</title>
    <link href="http://yoursite.com/2018/09/05/Git%E6%B5%85%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/09/05/Git浅解/</id>
    <published>2018-09-05T12:16:00.000Z</published>
    <updated>2019-03-17T13:07:33.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git浅解"><a href="#Git浅解" class="headerlink" title="Git浅解"></a><center>Git浅解</center></h1><h2 id="一、为什么选择Git"><a href="#一、为什么选择Git" class="headerlink" title="一、为什么选择Git"></a>一、为什么选择Git</h2><p>比如我们写东西的时候刚开始写了一部分，先保存为了文章1，然后后续写的时候，改了一些东西，删除了之前的一部分，但是你又可能需要之前的部分，所以你会另存为文章2，所以这样下去，等你的文章写完，可能会有文章1,2,3,4。。。很多个副本，然后你想去找其中的一段，但是又可能不记得在哪了，所以要一个个文件查看，这样就没有效率，重复做了很多事情，而且很乱。</p><p>然后Git可以帮你解决这些问题，它能帮我们记录每次文件的改动，而且可以多人协同完成，这样我们可以快速，高效的进行版本管理。</p><p>GIt是分布式版本控制系统。</p><p>Git不需要联网，每个人都可以拷贝一份完整的版本库到本地，然后在本地进行一系列操作。</p><h2 id="二、学习Git前须知"><a href="#二、学习Git前须知" class="headerlink" title="二、学习Git前须知"></a>二、学习Git前须知</h2><h3 id="（1）git文件的四种状态"><a href="#（1）git文件的四种状态" class="headerlink" title="（1）git文件的四种状态"></a>（1）git文件的四种状态</h3><ol><li>modified 修改了，但没有被保存在本地版本库</li><li>staged（已暂存）</li><li>untracked（）</li><li>commit（已提交）</li></ol><h3 id="（2）git的五个区域"><a href="#（2）git的五个区域" class="headerlink" title="（2）git的五个区域"></a>（2）git的五个区域</h3><h2 id="三、一般使用Git的流程"><a href="#三、一般使用Git的流程" class="headerlink" title="三、一般使用Git的流程"></a>三、一般使用Git的流程</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Git浅解&quot;&gt;&lt;a href=&quot;#Git浅解&quot; class=&quot;headerlink&quot; title=&quot;Git浅解&quot;&gt;&lt;/a&gt;&lt;center&gt;Git浅解&lt;/center&gt;&lt;/h1&gt;&lt;h2 id=&quot;一、为什么选择Git&quot;&gt;&lt;a href=&quot;#一、为什么选择Git&quot; cl
      
    
    </summary>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
</feed>
