<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>算法题-找出所有父节点</title>
      <link href="/2019/07/28/%E7%AE%97%E6%B3%95%E9%A2%98-%E6%89%BE%E5%87%BA%E6%89%80%E6%9C%89%E7%88%B6%E8%8A%82%E7%82%B9/"/>
      <url>/2019/07/28/%E7%AE%97%E6%B3%95%E9%A2%98-%E6%89%BE%E5%87%BA%E6%89%80%E6%9C%89%E7%88%B6%E8%8A%82%E7%82%B9/</url>
      <content type="html"><![CDATA[<h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2><p>已知数据格式，实现一个函数 fn 找出链条中所有的父级id</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json = [</span><br><span class="line">&#123;</span><br><span class="line">id: <span class="string">'1'</span>,</span><br><span class="line">name: <span class="string">'广东省'</span>,</span><br><span class="line">children: [</span><br><span class="line">&#123;</span><br><span class="line">id: <span class="string">'11'</span>,</span><br><span class="line">name: <span class="string">'深圳市'</span>,</span><br><span class="line">children: [</span><br><span class="line">&#123;</span><br><span class="line">id: <span class="string">'111'</span>,</span><br><span class="line">name: <span class="string">'福田区'</span>,</span><br><span class="line">children: []</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">id: <span class="string">'112'</span>,</span><br><span class="line">name: <span class="string">'龙华区'</span>,</span><br><span class="line">children: []</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = <span class="string">'112'</span></span><br><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">fn(value) <span class="comment">// 输出 ['1'， '11'， '112']</span></span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="方法一-递归实现深度遍历，并添加path数组，记录父路径"><a href="#方法一-递归实现深度遍历，并添加path数组，记录父路径" class="headerlink" title="方法一 递归实现深度遍历，并添加path数组，记录父路径"></a>方法一 递归实现深度遍历，并添加path数组，记录父路径</h3><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="string">'112'</span>;</span><br><span class="line"><span class="keyword">var</span> fn = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">var</span> stack = json;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">var</span> node = stack.pop();<span class="keyword">debugger</span></span><br><span class="line"><span class="keyword">if</span>(node.children.length) &#123;</span><br><span class="line">stack.push(...node.children.map(<span class="function"><span class="params">x</span>=&gt;</span>(&#123;...x, <span class="attr">path</span>: (node.path || node.id) + <span class="string">'-'</span> + x.id&#125;)))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(node.id === value) &#123;</span><br><span class="line"><span class="keyword">return</span> node.path.split(<span class="string">'-'</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">while</span>(stack.length) </span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line">fn(value) <span class="comment">// 输出 [1， 11， 112]</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> javaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>20190727算法题-两数之和</title>
      <link href="/2019/07/27/20190727%E7%AE%97%E6%B3%95%E9%A2%98-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2019/07/27/20190727%E7%AE%97%E6%B3%95%E9%A2%98-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      <content type="html"><![CDATA[<h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2><p>给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。</p><p>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。</p><p>示例：</p><p>给定 nums = [2, 7, 11, 15], target = 9</p><p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一-双层for循环"><a href="#方法一-双层for循环" class="headerlink" title="方法一 双层for循环"></a>方法一 双层for循环</h3><p>我们用双层for循环，遍历每个元素el，找到是否有target-el的元素存在数组里，找到则输出索引。</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(nums[i] === target - nums[j] &amp;&amp; i!==j) &#123;</span><br><span class="line"><span class="keyword">return</span> [i, j]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的时间复杂度是 O(n^2)，空间复杂度为O(1)</p><p>很明显，这样的方法耗时太久，不好。</p><h3 id="方法二-利用对象查找"><a href="#方法二-利用对象查找" class="headerlink" title="方法二 利用对象查找"></a>方法二 利用对象查找</h3><p>因为在一个对象里找到是否有某个属性值，时间复杂度为O(1),所以我们可以第一次遍历数组，生成一个对象，然后第二次遍历，去找对象中是否有target-nums[i]的值，有的话返回。这样总的时间复杂度为O(n)，比第一种方法要好一些，只是需要一些内存去存储对象，空间复杂度为O(n),相当于拿空间换时间。</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">obj[nums[i]] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(obj[target - nums[i]] &amp;&amp; i == obj[target - nums[i]]) &#123;</span><br><span class="line"><span class="keyword">return</span> [i, obj[target - nums[i]]]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法三-优化第二种方法"><a href="#方法三-优化第二种方法" class="headerlink" title="方法三 优化第二种方法"></a>方法三 优化第二种方法</h3><p>上面我们执行了两次for循环，我们进行一下优化，在一次循环里解决。第一次循环将数组生成对象时就返回去检查对象里是否有符合target - nums[i]的属性值，有则返回。</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(obj[target - nums[i]] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> [obj[target - nums[i]], i]</span><br><span class="line">&#125;</span><br><span class="line">obj[nums[i]] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>20190727算法题-降维数组</title>
      <link href="/2019/07/27/20190727%E7%AE%97%E6%B3%95%E9%A2%98-%E9%99%8D%E7%BB%B4%E6%95%B0%E7%BB%84/"/>
      <url>/2019/07/27/20190727%E7%AE%97%E6%B3%95%E9%A2%98-%E9%99%8D%E7%BB%B4%E6%95%B0%E7%BB%84/</url>
      <content type="html"><![CDATA[<h2 id="算法题目："><a href="#算法题目：" class="headerlink" title="算法题目："></a>算法题目：</h2><p>已知如下数组：</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, [<span class="number">11</span>, <span class="number">12</span>, [<span class="number">12</span>, <span class="number">13</span>, [<span class="number">14</span>] ] ] ], <span class="number">10</span>];</span><br></pre></td></tr></table></figure><h3 id="要求1：-将多维数组降成一维数组"><a href="#要求1：-将多维数组降成一维数组" class="headerlink" title="要求1： 将多维数组降成一维数组"></a>要求1： 将多维数组降成一维数组</h3><h4 id="方法一：-es6的flat"><a href="#方法一：-es6的flat" class="headerlink" title="方法一： es6的flat()"></a>方法一： es6的flat()</h4><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.flat(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h4 id="方法二：-投机取巧"><a href="#方法二：-投机取巧" class="headerlink" title="方法二： 投机取巧"></a>方法二： 投机取巧</h4><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.toString().split(<span class="string">','</span>);</span><br></pre></td></tr></table></figure><p>或者</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.join().split(<span class="string">','</span>);</span><br></pre></td></tr></table></figure><h4 id="方法三：-递归"><a href="#方法三：-递归" class="headerlink" title="方法三： 递归"></a>方法三： 递归</h4><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flat</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> result = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_flat</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">value, index</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">_flat(value)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">result.push(value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">_flat(arr)</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">flat(arr)</span><br></pre></td></tr></table></figure><p>简写：</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> flat = <span class="function"><span class="params">arr</span> =&gt;</span> [].concat(...arr.map(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">Array</span>.isArray(v) ? flat(v) : v))</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript数据结构</title>
      <link href="/2019/07/27/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2019/07/27/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>想要做一个技术人，数据结构和算法都是必须的，在大学中，最让我头疼的也是这两门课，总觉得脑豁疼，毕业工作后一直想要找时间学习，但是奈何在前公司总是搬砖，做一些简单的工作，现离职后开始找工作，终于抽出时间开始学习数据结构和算法。数据结构和算法对我来说是难以翻越两座大山，但是做人要不断挑战自己，这一篇博客主要是记录一下学习数据结构的成果。</p><p>数据结构按可以分为逻辑结构和物理结构。把数据结构比作人的话，物理结构就是看得见，摸得着的人体，逻辑结构就是人的精神和思想。</p><p>物理结构分为顺序存储结构和链式存储结构。顺序存储结构有数组，链式存储结构有链表。</p><p>逻辑结构分为线性结构和非线性结构。线性结构主要有顺序表，栈，队列。非线性结构主要有树，图。</p><a id="more"></a><h2 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h2><h3 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h3><p>顺序存储结构顾名思义就是数据在内存中是顺序存储。</p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组是最简单的数据结构，它一般来说存储着有限个相同类型的变量，在js中，数组可以保存着不同类型的值，但是不推荐这么用。</p><p>我们知道，内存是由一个个连续的内存单元组成，数组中的每个元素都连续存储在内存中，而且是顺序存储。</p><h5 id="创建和初始化数组"><a href="#创建和初始化数组" class="headerlink" title="创建和初始化数组"></a>创建和初始化数组</h5><p>创建和初始化数组有三种方式，一种是通过构造函数，一种是字面量，最后一种是Array.of()。</p><p>第一种： </p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>) <span class="comment">// 创建一个空数组，数组长度为10</span></span><br><span class="line"><span class="keyword">let</span> arr1 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">'10'</span>) <span class="comment">// 创建了一个数组['10'],数组长度为1</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">'10'</span>,<span class="string">'11'</span>) <span class="comment">// 创建了一个数组['10,11'],长度为2</span></span><br></pre></td></tr></table></figure><p>我们可以看到通过构造函数创建数组时，如果向构造函数传递了一个Number类型的参数，那么会生成一个length为传进来的参数的大小，否则则生成一个包含参数的数组。</p><p>第二种：</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [] <span class="comment">// 创建一个空数组，数组长度为0</span></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="string">'10'</span>] <span class="comment">// 创建了一个数组['10'],数组长度为1</span></span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="string">'10,11'</span>] <span class="comment">// 创建了一个数组['10,11'],长度为2</span></span><br></pre></td></tr></table></figure><p>第二种方法是字面量方法，直接通过‘[]’创建数组。</p><p>第三种是新增的方法</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.of() <span class="comment">// 创建一个空数组，数组长度为0</span></span><br><span class="line"><span class="keyword">let</span> arr1 = <span class="built_in">Array</span>.of(<span class="string">'10'</span>) <span class="comment">// 创建了一个数组['10'],数组长度为1</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.of(<span class="string">'10'</span>,<span class="string">'11'</span>) <span class="comment">// 创建了一个数组['10,11'],长度为2</span></span><br></pre></td></tr></table></figure><h5 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h5><p>我们通过元素下标访问元素数组。数组第一个元素的下标为0，最后一个为length-1。</p><h5 id="添加和删除数组元素"><a href="#添加和删除数组元素" class="headerlink" title="添加和删除数组元素"></a>添加和删除数组元素</h5><h6 id="添加元素到数组首位–unshift"><a href="#添加元素到数组首位–unshift" class="headerlink" title="添加元素到数组首位–unshift()"></a>添加元素到数组首位–unshift()</h6><p>语法： arrayObject.unshift(item)</p><p>参数： item： 要插入到首位的元素</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr.unshift(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr)<span class="comment">// [0, 1, 2, 3]</span></span><br></pre></td></tr></table></figure><h6 id="删除数组首位元素–shift"><a href="#删除数组首位元素–shift" class="headerlink" title="删除数组首位元素–shift()"></a>删除数组首位元素–shift()</h6><p>语法： arrayObject.shift()</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr.shift()</span><br><span class="line"><span class="built_in">console</span>.log(arr)<span class="comment">// [2, 3]</span></span><br></pre></td></tr></table></figure><h6 id="添加元素到数组末尾–push"><a href="#添加元素到数组末尾–push" class="headerlink" title="添加元素到数组末尾–push()"></a>添加元素到数组末尾–push()</h6><p>语法： arrayObject.push(item)</p><p>参数： item： 要插入到末位的元素</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr.push(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr)<span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>####### 删除数组末尾元素–pop()</p><p>语法： arrayObject.pop()</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr.pop()</span><br><span class="line"><span class="built_in">console</span>.log(arr)<span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure><h6 id="添加-删除元素到数组任意位置–splice"><a href="#添加-删除元素到数组任意位置–splice" class="headerlink" title="添加/删除元素到数组任意位置–splice()"></a>添加/删除元素到数组任意位置–splice()</h6><p>语法： arrayObject.splice(index,howmany,item1,…..,itemX)</p><p>参数： </p><ol><li>index：必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。</li><li>howmany：必需。要删除的项目数量。如果设置为 0，则不会删除项目。</li><li>item1,…..,itemX：可选。向数组添加的新项目。</li></ol><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr)<span class="comment">// [1, 5, 5, 2, 3]</span></span><br></pre></td></tr></table></figure><h5 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h5><p>上面我们已经接触了5个方法了。下面将介绍一下数组的其他的方法。</p><h6 id="concat-连接数组"><a href="#concat-连接数组" class="headerlink" title="concat 连接数组"></a>concat 连接数组</h6><p>连接两个及以上的数组，并返回一个新数组，不会影响旧数组</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.concat(arr2);</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// [1, 2, 3, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><h6 id="every-返回值是boolean"><a href="#every-返回值是boolean" class="headerlink" title="every 返回值是boolean"></a>every 返回值是boolean</h6><p>对数组中的每个元素运行一个函数，如果每个元素运行该函数返回为true，则为true。</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.every(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, arrObj</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> item &gt; <span class="number">0</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>该函数接收三个参数，item是当前元素，index是该元素的下标，arrObj是执行every方法的数组。</p><h6 id="some-返回值是boolean"><a href="#some-返回值是boolean" class="headerlink" title="some 返回值是boolean"></a>some 返回值是boolean</h6><p>对数组中的每个元素运行一个函数，如果每个元素运行该函数有一个返回为true，则为true。</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.some(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, arrObj</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> item &gt; <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// true</span></span><br></pre></td></tr></table></figure><h6 id="map-返回新数组"><a href="#map-返回新数组" class="headerlink" title="map 返回新数组"></a>map 返回新数组</h6><p>对数组中的每个元素运行一个函数，每次调用该函数的结果组成新数组返回</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, arrObj</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> item * <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure><h6 id="filter-过滤元素，返回新数组"><a href="#filter-过滤元素，返回新数组" class="headerlink" title="filter 过滤元素，返回新数组"></a>filter 过滤元素，返回新数组</h6><p>对数组中的每个元素运行一个函数，每次调用该函数的返回值为true的元素组成新数组返回</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, arrObj</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> item &gt; <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// [3]</span></span><br></pre></td></tr></table></figure><h6 id="forEach-无返回值"><a href="#forEach-无返回值" class="headerlink" title="forEach 无返回值"></a>forEach 无返回值</h6><p>对数组中的每个元素运行一个函。</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">// 某些操作</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h6 id="slice-截取数组，返回新数组"><a href="#slice-截取数组，返回新数组" class="headerlink" title="slice 截取数组，返回新数组"></a>slice 截取数组，返回新数组</h6><p>传入索引值(start, end)，将数组里对应索引范围内(包含start，不包含end)的元素组成新数组返回</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.slice(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// [1]</span></span><br></pre></td></tr></table></figure><h6 id="sort-排序数组，影响arr数组"><a href="#sort-排序数组，影响arr数组" class="headerlink" title="sort 排序数组，影响arr数组"></a>sort 排序数组，影响arr数组</h6><p>按照字母顺序对数组排序，支持指定的排序函数当作参数</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.sort();</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// [1, 2, 2, 3, 3, 4]</span></span><br></pre></td></tr></table></figure><h6 id="reverse-颠倒数组，影响arr数组"><a href="#reverse-颠倒数组，影响arr数组" class="headerlink" title="reverse 颠倒数组，影响arr数组"></a>reverse 颠倒数组，影响arr数组</h6><p>颠倒数组，原先第一位元素变成最后一位，第二位变成倒数第二位，以此类推。</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.reverse();</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// [3, 2, 1]</span></span><br></pre></td></tr></table></figure><h6 id="indexOf-返回第一个与给定参数相等的元素的下标，没有返回-1"><a href="#indexOf-返回第一个与给定参数相等的元素的下标，没有返回-1" class="headerlink" title="indexOf 返回第一个与给定参数相等的元素的下标，没有返回-1"></a>indexOf 返回第一个与给定参数相等的元素的下标，没有返回-1</h6><p>从数组的第一个元素开始匹配，匹配成功则返回下标</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.indexOf(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h6 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf"></a>lastIndexOf</h6><p>从数组的最后一个元素开始匹配，匹配成功则返回下标，没有匹配成功返回-1</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.lastIndexOf(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h6 id="join-将所有元素拼接成字符串"><a href="#join-将所有元素拼接成字符串" class="headerlink" title="join 将所有元素拼接成字符串"></a>join 将所有元素拼接成字符串</h6><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.join();</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// "1,2,3"</span></span><br></pre></td></tr></table></figure><h6 id="toString-将所有元素拼接成字符串"><a href="#toString-将所有元素拼接成字符串" class="headerlink" title="toString 将所有元素拼接成字符串"></a>toString 将所有元素拼接成字符串</h6><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.toString();</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// "1,2,3"</span></span><br></pre></td></tr></table></figure><h6 id="reduce-累加"><a href="#reduce-累加" class="headerlink" title="reduce 累加"></a>reduce 累加</h6><p>reduce对元素的每一项运行一个函数，这个函数接收四个参数，preV前一个元素的值，curV当前元素值，index当前元素的下标，arrObj，执行reduce函数的数组。</p><p>reduce会返回数组每一项的累加值。</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">preV, curV, index, arrObj</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> preV + curV</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">//6  1+2+3=6</span></span><br></pre></td></tr></table></figure><h6 id="copyWithin-复制数组的某个范围的元素到同一个数组指定的起始位置"><a href="#copyWithin-复制数组的某个范围的元素到同一个数组指定的起始位置" class="headerlink" title="copyWithin 复制数组的某个范围的元素到同一个数组指定的起始位置"></a>copyWithin 复制数组的某个范围的元素到同一个数组指定的起始位置</h6><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.copyWithin(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// [1, 1, 3]</span></span><br></pre></td></tr></table></figure><p>copyWithin接收三个参数，第一个参数值指定元素放的起始位置，第二个，第三个参数分别是复制元素的起始位置和结束位置。</p><p>复制的元素包括开始位置的元素，不包括结束位置的元素。</p><h6 id="entries-返回包含数组所有键值对的-iterator"><a href="#entries-返回包含数组所有键值对的-iterator" class="headerlink" title="entries 返回包含数组所有键值对的 @@iterator"></a>entries 返回包含数组所有键值对的 @@iterator</h6><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.entries();</span><br><span class="line"><span class="built_in">console</span>.log(res.next().value)<span class="comment">// [0, 1] 0是下标，1时该下标对应的元素</span></span><br></pre></td></tr></table></figure><h6 id="includes-检测数组是否包含某个值"><a href="#includes-检测数组是否包含某个值" class="headerlink" title="includes 检测数组是否包含某个值"></a>includes 检测数组是否包含某个值</h6><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.include(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// true</span></span><br></pre></td></tr></table></figure><h6 id="find-数组每一项运行一个给定的函数，如果运行返回true，则返回这个元素"><a href="#find-数组每一项运行一个给定的函数，如果运行返回true，则返回这个元素" class="headerlink" title="find 数组每一项运行一个给定的函数，如果运行返回true，则返回这个元素"></a>find 数组每一项运行一个给定的函数，如果运行返回true，则返回这个元素</h6><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.find(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> item &gt; <span class="number">1</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h6 id="findIndex-数组每一项运行一个给定的函数，如果运行返回true，则返回这个元素的下标"><a href="#findIndex-数组每一项运行一个给定的函数，如果运行返回true，则返回这个元素的下标" class="headerlink" title="findIndex 数组每一项运行一个给定的函数，如果运行返回true，则返回这个元素的下标"></a>findIndex 数组每一项运行一个给定的函数，如果运行返回true，则返回这个元素的下标</h6><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.findIndex(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> item &gt; <span class="number">1</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h6 id="fill-用静态值填充数组"><a href="#fill-用静态值填充数组" class="headerlink" title="fill 用静态值填充数组"></a>fill 用静态值填充数组</h6><p>fill函数接收三个参数，填充值（必须），开始位置，结束位置</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.fill(<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">// [2, 3, 3]</span></span><br></pre></td></tr></table></figure><h6 id="from-从一个类似数组或可迭代对象中创建一个新的，浅拷贝的数组实例"><a href="#from-从一个类似数组或可迭代对象中创建一个新的，浅拷贝的数组实例" class="headerlink" title="from 从一个类似数组或可迭代对象中创建一个新的，浅拷贝的数组实例"></a>from 从一个类似数组或可迭代对象中创建一个新的，浅拷贝的数组实例</h6><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(<span class="string">"foo"</span>);<span class="comment">//['f', 'o', 'o']</span></span><br></pre></td></tr></table></figure><p>Array.from这个方法接收三个参数，第一个是要转换成数组的类数组对象，第二个是新数组的每一项都会运行的函数，第三个参数this</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = <span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], x =&gt; x*<span class="number">2</span>);<span class="comment">//[2, 4, 6]</span></span><br></pre></td></tr></table></figure><h6 id="values-包含数组所有值的-iterator"><a href="#values-包含数组所有值的-iterator" class="headerlink" title="values 包含数组所有值的@@iterator"></a>values 包含数组所有值的@@iterator</h6><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> res = arr.values().next().value <span class="comment">// 1</span></span><br><span class="line">arr.values().next().value <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h6 id="key-包含数组所有下标的-iterator"><a href="#key-包含数组所有下标的-iterator" class="headerlink" title="key 包含数组所有下标的@@iterator"></a>key 包含数组所有下标的@@iterator</h6><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> res = arr.keys().next().value <span class="comment">// 0</span></span><br><span class="line">arr.values().next().value <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h6 id="flat-降维数组"><a href="#flat-降维数组" class="headerlink" title="flat 降维数组"></a>flat 降维数组</h6><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]], <span class="number">3</span>];</span><br><span class="line">arr.flat(<span class="number">1</span>) <span class="comment">// [1, 2, [3, [4, 5]], 3]</span></span><br><span class="line">arr.flat(<span class="number">2</span>) <span class="comment">// [1, 2, 3, [4, 5], 3]</span></span><br><span class="line">arr.flat(<span class="number">3</span>) <span class="comment">// [1, 2, 3, 4, 5, 3]</span></span><br></pre></td></tr></table></figure><p>flat函数接收一个参数，要提取嵌套数组的结构深度，默认值为 1。</p><h6 id="flatMap-包含数组所有下标的-iterator"><a href="#flatMap-包含数组所有下标的-iterator" class="headerlink" title="flatMap 包含数组所有下标的@@iterator"></a>flatMap 包含数组所有下标的@@iterator</h6><p>它与 map 和 深度值1的 flat 几乎相同</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">arr1.map(<span class="function"><span class="params">x</span> =&gt;</span> [x * <span class="number">2</span>]); </span><br><span class="line"><span class="comment">// [[2], [4], [6], [8]]</span></span><br><span class="line">arr1.flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [x * <span class="number">2</span>]);</span><br><span class="line"><span class="comment">// [2, 4, 6, 8]</span></span><br><span class="line"><span class="comment">// 只会将 flatMap 中的函数返回的数组 “压平” 一层</span></span><br><span class="line">arr1.flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [[x * <span class="number">2</span>]]);</span><br><span class="line"><span class="comment">// [[2], [4], [6], [8]]</span></span><br></pre></td></tr></table></figure><h3 id="链式储存结构"><a href="#链式储存结构" class="headerlink" title="链式储存结构"></a>链式储存结构</h3><p>数组的大小是固定，我们向数组的首部或者中间插入或者删除元素的成本很高，因为要移动元素。链式存储结构就很好的解决了这个问题，因为链式存储结构的元素不是连续存放在内存中。</p><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>链表就是一种很常见的链式存储结构，链表中的每个元素由一个存储数据的节点和指向下一个元素的指针。因此向链表中添加和删除元素是速度很快的，只要改变一下元素的指向，而不需要移动元素。</p><p>下面我们用js去实现一个链表结构</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkList</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> node = <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.el = el;</span><br><span class="line"><span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> head = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 链表的常用操作</span></span><br><span class="line"><span class="keyword">this</span>.append = <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;&#125;; <span class="comment">// 向链表尾部添加新的元素</span></span><br><span class="line"><span class="keyword">this</span>.insert = <span class="function"><span class="keyword">function</span> (<span class="params">position, el</span>) </span>&#123;&#125;; <span class="comment">// 向链表的特定的位置添加一个元素</span></span><br><span class="line"><span class="keyword">this</span>.removeAt = <span class="function"><span class="keyword">function</span> (<span class="params">position</span>) </span>&#123;&#125;; <span class="comment">// 删掉指定位置的元素</span></span><br><span class="line"><span class="keyword">this</span>.remove = <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;&#125;; <span class="comment">// 删除元素</span></span><br><span class="line"><span class="keyword">this</span>.indexOf = <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;&#125;; <span class="comment">//返回指定元素的索引，没有这返回-1</span></span><br><span class="line"><span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 判断是否是空链表</span></span><br><span class="line"><span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;; <span class="comment">//  返回链表长度</span></span><br><span class="line"><span class="keyword">this</span>.getHead = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 返回链表头部</span></span><br><span class="line"><span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 输出元素值</span></span><br><span class="line"><span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 输出链表元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><h3 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h3><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>栈是一个有序集合，并且遵循着先进后出，后进先出的原则。元素出去或者是进来的地方叫做栈顶，另一端是栈底。</p><p>下面上代码</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> items = [];</span><br><span class="line"><span class="keyword">this</span>.push = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123; <span class="comment">// 添加一个元素</span></span><br><span class="line">items.push(element);</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">this</span>.pop = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 移除栈顶的元素，同时返回被移除的元素</span></span><br><span class="line">items.pop();</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 判断栈是否空，为空返回true，否则返回false</span></span><br><span class="line"><span class="keyword">if</span>(items.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 移除栈里的元素</span></span><br><span class="line">items = []</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 返回栈的元素个数。</span></span><br><span class="line"><span class="keyword">return</span> items.length;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 输出栈</span></span><br><span class="line"><span class="keyword">return</span> items</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>队列是一组有序的项，遵守先进先出，后进后出的原则。比较常见的例子是打印机的打印队列，先发起的打印请求肯定先打印，后发起的请求后打印。</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> items = [];</span><br><span class="line"><span class="keyword">this</span>.enqueue = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123; <span class="comment">// 添加一个元素</span></span><br><span class="line">items.push(element);</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">this</span>.dequeue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 移除队列头部的元素，同时返回被移除的元素</span></span><br><span class="line">items.shift();</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 判断队列是否空，为空返回true，否则返回false</span></span><br><span class="line"><span class="keyword">if</span>(items.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 移除队列里的元素</span></span><br><span class="line">items = []</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 返回队列的元素个数。</span></span><br><span class="line"><span class="keyword">return</span> items.length;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 输出队列</span></span><br><span class="line"><span class="keyword">return</span> items</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非线性结构"><a href="#非线性结构" class="headerlink" title="非线性结构"></a>非线性结构</h3><h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><h4 id="图"><a href="#图" class="headerlink" title="图"></a>图</h4>]]></content>
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript的三种编程范式比较</title>
      <link href="/2019/07/23/JavaScript%E7%9A%84%E4%B8%89%E7%A7%8D%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E6%AF%94%E8%BE%83/"/>
      <url>/2019/07/23/JavaScript%E7%9A%84%E4%B8%89%E7%A7%8D%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E6%AF%94%E8%BE%83/</url>
      <content type="html"><![CDATA[<h2 id="过程式编程"><a href="#过程式编程" class="headerlink" title="过程式编程"></a>过程式编程</h2><p>也就是从上至下，流水般的实现功能。</p><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程范式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>js实现树的深度优先遍历和广度优先遍历</title>
      <link href="/2019/07/19/js%E5%AE%9E%E7%8E%B0%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
      <url>/2019/07/19/js%E5%AE%9E%E7%8E%B0%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/</url>
      <content type="html"><![CDATA[<h2 id="树数据结构的介绍"><a href="#树数据结构的介绍" class="headerlink" title="树数据结构的介绍"></a>树数据结构的介绍</h2><p>数据结构可以分为顺序数据结构和非顺序结构。顺序数据结构是指把数据元素放在地址连续的存储单元里。非顺序结构可以把数据元素任意放在连续或者不连续的存储单元里。</p><p>树是一种非顺序数据结构。族谱，公司里的组织结构都可以看成是树模型。</p><p>树结构是包含一个根节点，还有内部节点，叶子节点。根节点是位于树的顶部。叶子节点是没有后代的节点。内部节点是除了根节点和叶子节点外的所有节点。一个节点可以有祖先和后代。根节点没有祖先。</p><p>节点的深度是节点的祖先节点数。</p><p>树的高度是所有节点深度中的最大的深度。</p><p>树可以分层级，根节点在第零层，它的子节点是第一层，依次类推。</p><p><img src="/2019/07/19/js实现树的深度优先遍历和广度优先遍历/tree.jpg" alt=""></p><h2 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h2><h2 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h2><h2 id="js实现两种方式的遍历"><a href="#js实现两种方式的遍历" class="headerlink" title="js实现两种方式的遍历"></a>js实现两种方式的遍历</h2>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树的遍历 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue Router学习（一）</title>
      <link href="/2019/07/02/Vue-Router%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2019/07/02/Vue-Router%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="单页应用-vs-多页应用"><a href="#单页应用-vs-多页应用" class="headerlink" title="单页应用 vs 多页应用"></a>单页应用 vs 多页应用</h3><p><img src="/2019/07/02/Vue-Router学习（一）/blog.png" alt=""></p><p>以我的博客为例，很多网站会有这样的布局，头部会有一个导航栏，每次点击页面会切换。</p><p>如果是多页应用MPA（Mutiple Page Application）的话，就是每一个导航是一个html，比如我的博客，导航里有5项，那么就有5个html，每次点击，都进行了html切换，每次都要加载新的html。</p><p>如果是单页应用，就只有一个html，没有导航切换的时候只是切换html页面内容，不会切换html。</p><a id="more"></a><h4 id="多页应用"><a href="#多页应用" class="headerlink" title="多页应用"></a>多页应用</h4><p>多页应用的优点是首次页面加载时间快，SEO效果好，缺点是页面切换慢。</p><p>因为多页应用是把系统分成很多个html，所以每次加载只加载了一个html，所以首次页面加载快。</p><p>SEO指搜索引擎优化，它是一种通过分析搜索引擎的排名规律，了解各种搜索引擎怎样进行搜索、怎样抓取互联网页面、怎样确定特定关键词的搜索结果排名的技术。</p><p>多页应用的内容基本都是直接写在html页面，这样搜索引擎就比较好好识别，所以seo排名效果好。</p><p>页面切换慢的原因是因为没有切换页面，都要重新请求html，相当于重新渲染页面，渲染整颗DOM树。</p><h4 id="单页应用"><a href="#单页应用" class="headerlink" title="单页应用"></a>单页应用</h4><blockquote><p>单页Web应用（single page web application，SPA）无疑是目前网站开发技术的弄潮儿，很多传统网站都在或者已经转型为单页Web应用       —《单页Web应用：JavaScript从前端到后端》</p></blockquote><p>单页应用相对于多页应用，比较明显的优点就是切换页面时间比较快，因为单页应用切换不需要重新请求html，它只是重新渲染dom树的其中一部分。但是因为单页应用把所有的内容都放到一个html里，所以他的首次加载页面时间会相对来说比较慢，要加载的内容比较多，而且一般单页应用的内容主要通过js去切换渲染，所以内容都是动态生成，不是直接写在html里，所以seo效果比较差。</p><p>搭建一个项目的时候到底是用多页面还是单页，这需要根据具体情况去分析。</p><h2 id="Vue-Router是什么？"><a href="#Vue-Router是什么？" class="headerlink" title="Vue Router是什么？"></a>Vue Router是什么？</h2><p>官方解释什么是Vue Router</p><p>Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。包含的功能有：</p><ol><li>嵌套的路由/视图表</li><li>模块化的、基于组件的路由配置</li><li>路由参数、查询、通配符</li><li>基于 Vue.js 过渡系统的视图过渡效果</li><li>细粒度的导航控制</li><li>带有自动激活的 CSS class 的链接</li><li>HTML5 历史模式或 hash 模式，在 IE9 中自动降级</li><li>自定义的滚动条行为</li></ol><h2 id="为什么要用Vue-Router？"><a href="#为什么要用Vue-Router？" class="headerlink" title="为什么要用Vue Router？"></a>为什么要用Vue Router？</h2><p>在单页应用中所有的东西都在一个html页面中，我们进行页面切换需要用到路由。</p><h2 id="怎么用Vue-Router？"><a href="#怎么用Vue-Router？" class="headerlink" title="怎么用Vue Router？"></a>怎么用Vue Router？</h2><h3 id="一个简单的单页面应用"><a href="#一个简单的单页面应用" class="headerlink" title="一个简单的单页面应用"></a>一个简单的单页面应用</h3><p>下面介绍的是vue-cli2.0下怎么用Vue Router</p><p> 首先我们先安装一下vue-cli2.0</p><p> <img src="/2019/07/02/Vue-Router学习（一）/vue-init.jpg" alt=""></p><p> 可以看到，我们安装vue-cli 模版的时候可以选择安不安装Vue-Router，在这边我们选择yes。</p><p> 项目创建完成后我们看下<code>src\main.js</code></p> <figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// The Vue build version to load with the `import` command</span></span><br><span class="line"><span class="comment">// (runtime-only or standalone) has been set in webpack.base.conf with an alias.</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span> <span class="comment">// 引入了路由</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router, <span class="comment">// 使用路由</span></span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: <span class="string">'&lt;App/&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>首先我们把<code>src\App.vue</code>这个文件加上一个导航nav</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> &lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;./assets/logo.png&quot;&gt;</span><br><span class="line">    &lt;nav&gt;</span><br><span class="line">      &lt;router-link class=&quot;fd-header-item&quot; to=&quot;/&quot;&gt;Home&lt;/router-link&gt;</span><br><span class="line">      &lt;router-link class=&quot;fd-header-item&quot; to=&quot;/achives&quot;&gt;Achives&lt;/router-link&gt;</span><br><span class="line">      &lt;router-link class=&quot;fd-header-item&quot; to=&quot;/categories&quot;&gt;Categories&lt;/router-link&gt;</span><br><span class="line">      &lt;router-link class=&quot;fd-header-item&quot; to=&quot;/tags&quot;&gt;Tags&lt;/router-link&gt;</span><br><span class="line">      &lt;router-link class=&quot;fd-header-item&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;</span><br><span class="line">    &lt;/nav&gt;</span><br><span class="line">    &lt;router-view/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;App&apos;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">#app &#123;</span><br><span class="line">  font-family: &apos;Avenir&apos;, Helvetica, Arial, sans-serif;</span><br><span class="line">  -webkit-font-smoothing: antialiased;</span><br><span class="line">  -moz-osx-font-smoothing: grayscale;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: #2c3e50;</span><br><span class="line">  margin-top: 60px;</span><br><span class="line">&#125;</span><br><span class="line">.fd-header-item &#123;</span><br><span class="line">  cursor: pointer;</span><br><span class="line">&#125;</span><br><span class="line">.fd-header-item:hover, .router-link-exact-active&#123;</span><br><span class="line">  color: aqua;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>我们可以看到两个比较特殊的标签<code>&lt;router-link&gt;&lt;/router-link&gt;</code>，<code>&lt;router-view/&gt;</code></p><p><code>&lt;router-link&gt;</code>主要是用来做页面跳转的，一般写导航，<code>&lt;router-link&gt;</code>里的组件会渲染到<code>&lt;router-view/&gt;</code></p><p>我们一个导航项创建一个组件，所以我们在<code>src\components\</code>下创建五个组件，分别是home.vue, achives.vue, categories.vue, tags.vue, about.vue</p><p>Vue Router 给我们设置了高亮的样式<code>router-link-exact-active</code>，所以我们可以设置一个选中颜色。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.fd-header-item:hover, .router-link-exact-active&#123;</span><br><span class="line">  color: aqua;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>router-link里的to参数代表着你要跳转的路径，我们可以看下<code>src\Router\index.js</code></p><p>在这个js中我们引入了这五个组件，然后写了它们相应的路由</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> home <span class="keyword">from</span> <span class="string">'@/components/home'</span></span><br><span class="line"><span class="keyword">import</span> achives <span class="keyword">from</span> <span class="string">'@/components/achives'</span></span><br><span class="line"><span class="keyword">import</span> categories <span class="keyword">from</span> <span class="string">'@/components/categories'</span></span><br><span class="line"><span class="keyword">import</span> tags <span class="keyword">from</span> <span class="string">'@/components/tags'</span></span><br><span class="line"><span class="keyword">import</span> about <span class="keyword">from</span> <span class="string">'@/components/about'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      name: <span class="string">'home'</span>,</span><br><span class="line">      component: home</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/achives'</span>,</span><br><span class="line">      name: <span class="string">'achives'</span>,</span><br><span class="line">      component: achives</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/categories'</span>,</span><br><span class="line">      name: <span class="string">'categories'</span>,</span><br><span class="line">      component: categories</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/tags'</span>,</span><br><span class="line">      name: <span class="string">'tags'</span>,</span><br><span class="line">      component: tags</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/about'</span>,</span><br><span class="line">      name: <span class="string">'about'</span>,</span><br><span class="line">      component: about</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们看下这个home.vue,在点击home时我们显示I am Home ，其他几个页面相应的会输出。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;hello&quot;&gt;</span><br><span class="line">    &#123;&#123;msg&#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;home&apos;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &apos;I am Home&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p><img src="/2019/07/02/Vue-Router学习（一）/vueRouter1.jpg" alt=""></p><p>到此一个简单单页面应用的基本框架就算搭好了。在此之中我们接触到了三个很类似的单词：route，routes，router。</p><p>route他是一条路由，比如home这个a标签链接指向home页面的内容。</p><p>routes是一组路由，也就是由route组成的一组数组</p><p>router是一个机制，路由机制。</p><h3 id="多级导航（嵌套路由）"><a href="#多级导航（嵌套路由）" class="headerlink" title="多级导航（嵌套路由）"></a>多级导航（嵌套路由）</h3><h4 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h4><p>现在在Achives导航下有两个二级导航achives1和achives2，点击Achives1和Achives2分别跳转到相应的页面。</p><h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><ol><li>在src/component下创建两个子页面achives1.vu和achives2.vue</li><li>在src/router/index.js里配置子路由</li><li>在archives.vue写上<code>&lt;router-view/&gt;</code></li><li>在App.vue里写Achives点击事件，点击后出现二级导航</li></ol><h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><p>创建了两个子页面</p><p><img src="/2019/07/02/Vue-Router学习（一）/子页面.jpg" alt=""></p><p>achives1.vue页面如下</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;hello&quot;&gt;</span><br><span class="line">    &#123;&#123;msg&#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;achives1&apos;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &apos;I am Achives1&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>src/router/index.js</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: <span class="string">'/achives'</span>,</span><br><span class="line">  component: achives,</span><br><span class="line">  children: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'achives1'</span>,</span><br><span class="line">      component: achives1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'achives2'</span>,</span><br><span class="line">      component: achives2</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们在achives的路由中加了一个children属性,这个属性是一个数组，然后有两项，也就是我们的两个子页面的路由，相应的path是路径，component是组件，所以我们要在src/router/index.js里引入这两个组件</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> achives1 <span class="keyword">from</span> <span class="string">'@/components/achives1'</span></span><br><span class="line"><span class="keyword">import</span> achives2 <span class="keyword">from</span> <span class="string">'@/components/achives2'</span></span><br></pre></td></tr></table></figure><p>在父页面achives.vue</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;hello&quot;&gt;</span><br><span class="line">    &#123;&#123;msg&#125;&#125;</span><br><span class="line">   &lt;router-view/&gt; // 新增的</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;achives&apos;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &apos;I am Achives&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>最后我们只要在App.vue添加相应的点击事件和router-link</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>《单页Web应用：JavaScript从前端到后端》</li></ol>]]></content>
      
      
        <tags>
            
            <tag> vue vue-Router </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浏览器缓存详解</title>
      <link href="/2019/06/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/06/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>可能有人会和以前的我一样，觉得缓存不是后台设置的吗，感觉和前端人员没有太大联系，平时关于缓存最常做的就是在浏览器<code>Ctrl+Shit+Delete</code>清空缓存。</p><p>web缓存可以大致分为三类：</p><pre><code>1. 浏览器缓存2. 代理缓存3. 网关缓存</code></pre><p>我们这篇文章主要讲的是浏览器缓存，浏览器主要是通过http/https和服务器进行通信，所以浏览器缓存我们也可以说是HTTP缓存。<br><a id="more"></a></p><h2 id="二、什么是浏览器缓存"><a href="#二、什么是浏览器缓存" class="headerlink" title="二、什么是浏览器缓存"></a>二、什么是浏览器缓存</h2><blockquote><p>浏览器缓存（Browser Caching）是为了节约网络的资源加速浏览，浏览器在用户磁盘上对最近请求过的文档进行存储，当访问者再次请求这个页面时，浏览器就可以从本地磁盘显示文档，这样就可以加速页面的阅览。-百度百科</p></blockquote><p>缓存了的文档应该怎么命中，应该什么时候删除，应该什么时候更新，所以有一套缓存机制去进行处理这些问题，下面会详细说明。</p><h2 id="三、为什么用浏览器缓存"><a href="#三、为什么用浏览器缓存" class="headerlink" title="三、为什么用浏览器缓存"></a>三、为什么用浏览器缓存</h2><p>我们判断一个网站的用户体验的好坏的一个标准就是这个网站加载的速度，而影响速度的因素有很多，比如浏览器和服务器通信的时间，服务器处理时间等等，而缓存如果命中的话是从客户端取数据，所以不需要请求服务器，所以提高了加载速度。缓存存在以下优点：</p><ol><li>减少了等待时间</li><li>减少了网络通信量</li></ol><h2 id="四、怎么设置浏览器缓存"><a href="#四、怎么设置浏览器缓存" class="headerlink" title="四、怎么设置浏览器缓存"></a>四、怎么设置浏览器缓存</h2><h3 id="HTTP响应头"><a href="#HTTP响应头" class="headerlink" title="HTTP响应头"></a>HTTP响应头</h3><h4 id="a-HTTP报文"><a href="#a-HTTP报文" class="headerlink" title="a. HTTP报文"></a>a. HTTP报文</h4><p>客户端和服务端通过HTTP报文进行通信，请求端（客户端）的HTTP报文叫做请求报文，响应端（服务器端）的叫做响应报文。</p><p>HTTP报文大致可以分为报文首部和报文主体。</p><p>如图：</p><h5 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h5><p><img src="/2019/06/16/浏览器缓存详解/HTTP请求报文.png" alt="请求报文"></p><p>这个是我本地的一个ajax请求的报文。</p><p><img src="浏览器缓存详解/http请求报文真实.png" alt="http请求报文"></p><p>代码如下</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">oneClick () &#123;</span><br><span class="line">  <span class="keyword">this</span>.$axioss.get(<span class="string">'/users'</span>).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到请求方法为GET，请求url为‘/users’，请求协议HTTP1.1，下面是一串头部字段名和值。</p><p>下面列出了常用的几种请求方法</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. GET: 主要用于获取数据.</span><br><span class="line">2. HEAD: 请求一个与GET请求的响应相同的响应，但没有响应体.</span><br><span class="line">3. POST: 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。</span><br><span class="line">4. PUT: 从客户端向服务器传送的数据取代指定的文档的内容。</span><br><span class="line">5. DELETE: 删除指定的资源。</span><br></pre></td></tr></table></figure><h5 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h5><p><img src="/2019/06/16/浏览器缓存详解/HTTP响应报文.png" alt="响应报文"></p><p>响应代码如下</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">router.get(&apos;/&apos;, function(req, res, next) &#123;</span><br><span class="line">  res.json(&#123;</span><br><span class="line">    code: 200,</span><br><span class="line">    success: true,</span><br><span class="line">    message: &apos;请求成功&apos;,</span><br><span class="line">    data: []</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们看真实的请求报文：</p><p><img src="浏览器缓存详解/http响应报文真实.png" alt="http请求报文"></p><p>一开始是http协议，然后是状态码，现在是200，然后是原因短语‘OK’，下面是一串响应头部字段。</p><p>状态码描述了饭回的结果状态，用户可以根据状态码知道服务器是正常处理了请求，还是出现问题。<br>状态码主要类别有‘1xx’，‘2xx’，‘3xx’，‘4xx’，‘5xx’。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1. 1xx：信息性状态码</span><br><span class="line">2. 2xx： 成功状态码</span><br><span class="line">* 200 Ok 表示请求在服务端被正常的处理了</span><br><span class="line">* 204 no content 服务器接受的请求已成功处理，但响应报文不包含实体的主体部分</span><br><span class="line">* 206 partial content 表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求</span><br><span class="line">3. 3xx： 重定向状态码</span><br><span class="line">* 301 moveed permanently 永久性重定向</span><br><span class="line">* 302 found 临时性重定向</span><br><span class="line">* 303 see other</span><br><span class="line">* 304 not modified</span><br><span class="line">* 307 temporary redirect 临时重定向</span><br><span class="line">4. 4xx：客户端错误状态码</span><br><span class="line">* 400 bad request 请求报文存在语法错误</span><br><span class="line">* 401 unauthorized 发送的请求需要有通过http认证的认证信息</span><br><span class="line">* 403 forbidden 请求资源的访问被服务器拒绝</span><br><span class="line">* 404 not found 服务器上无法找到请求的资源</span><br><span class="line">5. 5xx：服务器错误状态码</span><br><span class="line">* 500 internal server error 服务器在执行请求时发生了错误</span><br><span class="line">* 503 service unavailable 服务器暂时处于超负载或正在进行停机维护</span><br></pre></td></tr></table></figure><h5 id="报文首部字段"><a href="#报文首部字段" class="headerlink" title="报文首部字段"></a>报文首部字段</h5><p>HTTP首部字段可以分为4种类型</p><ol><li>通用首部字段</li><li>请求首部字段</li><li>响应首部字段</li><li>实体首部字段</li></ol><table><br>    <caption>通用首部字段</caption><br>    <tr><br>        <th>首部字段名</th><br>        <th>说明</th><br>    </tr><br>    <tr><br>        <td>Cache-Control</td><br>        <td>控制缓存的行为</td><br>    </tr><br>    <tr><br>        <td>Connection</td><br>        <td>逐跳首部、连接的管理</td><br>    </tr><br>    <tr><br>        <td>Date</td><br>        <td>创建报文的日期时间</td><br>    </tr><br>    <tr><br>        <td>Pragma</td><br>        <td>报文指令</td><br>    </tr><br>    <tr><br>        <td>Trailer</td><br>        <td>报文末端的首部一览</td><br>    </tr><br>    <tr><br>        <td>Transfer-Encoding</td><br>        <td>指定报文主体的传输编码方式</td><br>    </tr><br>    <tr><br>        <td>Upgrade</td><br>        <td>升级为其他协议</td><br>    </tr><br>    <tr><br>        <td>Via</td><br>        <td>代理服务器的相关信息</td><br>    </tr><br>    <tr><br>        <td>Warning</td><br>        <td>错误通知</td><br>    </tr><br></table><table><br>    <caption>请求首部字段</caption><br>    <tr><br>        <th>首部字段名</th><br>        <th>说明</th><br>    </tr><br>    <tr><br>        <td>Accept</td><br>        <td>用户代理可以处理的媒体类型</td><br>    </tr><br>    <tr><br>        <td>Accept-Charset</td><br>        <td>优先的字符集</td><br>    </tr><br>    <tr><br>        <td>Accept-Encoding</td><br>        <td>优先的内容编码</td><br>    </tr><br>    <tr><br>        <td>Accept-Language</td><br>        <td>优优先的语言（自然语言）</td><br>    </tr><br>    <tr><br>        <td>Authorization</td><br>        <td>web认证信息</td><br>    </tr><br>    <tr><br>        <td>Expect</td><br>        <td>期待服务器的特定行为</td><br>    </tr><br>    <tr><br>        <td>From</td><br>        <td>用户的电子邮箱</td><br>    </tr><br>    <tr><br>        <td>Host</td><br>        <td>请求资源所在服务器</td><br>    </tr><br>    <tr><br>        <td>if-Match</td><br>        <td>比较实体标记（ETag）</td><br>    </tr><br>    <tr><br>        <td>if-modified-Since</td><br>        <td>比较资源的更新时间</td><br>    </tr><br>    <tr><br>        <td>if-none-Match</td><br>        <td>比较实体标记（ETag）</td><br>    </tr><br>    <tr><br>        <td>if-Range</td><br>        <td>资源未更新时发生实体Byte的范围请求</td><br>    </tr><br>    <tr><br>        <td>if-Unmodified-Since</td><br>        <td>比较资源的更新时间（与if-Modified-Since）</td><br>    </tr><br><br>    <tr><br>        <td>Max-Forwards</td><br>        <td>最大传输逐跳数</td><br>    </tr><br>    <tr><br>        <td>Proxy-Authorization</td><br>        <td>代理服务器邀请客户端的认证信息</td><br>    </tr><br><br>    <tr><br>        <td>Range</td><br>        <td>实体的字节范围请求</td><br>    </tr><br>    <tr><br>        <td>Referer</td><br>        <td>对请求中URI的原始获取方</td><br>    </tr><br><br>    <tr><br>        <td>TE</td><br>        <td>传输编码的优先级</td><br>    </tr><br><br>    <tr><br>        <td>User-Agent</td><br>        <td>HTTP客户端程序的信息</td><br>    </tr><br></table><table><br>    <caption>响应首部字段</caption><br>    <tr><br>        <th>首部字段名</th><br>        <th>说明</th><br>    </tr><br>    <tr><br>        <td>Accept-Ranges</td><br>        <td>是否接受字节范围请求</td><br>    </tr><br>    <tr><br>        <td>ETag</td><br>        <td>资源的匹配信息</td><br>    </tr><br>    <tr><br>        <td>Location</td><br>        <td>令客户端重定向至指定URI</td><br>    </tr><br>    <tr><br>        <td>Proxy-Authenticate</td><br>        <td>代理服务器对客户端的认证信息</td><br>    </tr><br>    <tr><br>        <td>Retry-After</td><br>        <td>对再次发起请求的时机要求</td><br>    </tr><br>    <tr><br>        <td>Server</td><br>        <td>HTTP服务器的安装信息</td><br>    </tr><br>    <tr><br>        <td>Vary</td><br>        <td>代理服务器的缓存管理信息</td><br>    </tr><br>    <tr><br>        <td>WWW-Authenticate</td><br>        <td>服务器对客户端的认证信息</td><br>    </tr><br></table><br><table><br>    <caption>实体首部字段</caption><br>    <tr><br>        <th>首部字段名</th><br>        <th>说明</th><br>    </tr><br>    <tr><br>        <td>Allow</td><br>        <td>资源可支持的HTTP方法</td><br>    </tr><br>    <tr><br>        <td>Content-Encoding</td><br>        <td>实体主体适用的编码方法</td><br>    </tr><br>    <tr><br>        <td>Content-Language</td><br>        <td>实体主体的自然语言</td><br>    </tr><br>    <tr><br>        <td>Content-Length</td><br>        <td>实体主体的大小（单位：字节）</td><br>    </tr><br>    <tr><br>        <td>Content-Location</td><br>        <td>代替对应资源的URI</td><br>    </tr><br>    <tr><br>        <td>Content-MD5</td><br>        <td>实体主体的报文摘要</td><br>    </tr><br>    <tr><br>        <td>Content-Range</td><br>        <td>实体主体的位置范围</td><br>    </tr><br>    <tr><br>        <td>Content-Type</td><br>        <td>实体主体的媒体类型</td><br>    </tr><br>    <tr><br>        <td>Expires</td><br>        <td>实体主体过期的日期时间</td><br>    </tr><br>    <tr><br>        <td>Last-Modified</td><br>        <td>资源最后修改日期时间</td><br>    </tr><br><br></table><h4 id="b-强缓存-Expires-vs-Cache-Control"><a href="#b-强缓存-Expires-vs-Cache-Control" class="headerlink" title="b. 强缓存(Expires vs Cache-Control)"></a>b. 强缓存(Expires vs Cache-Control)</h4><h5 id="Expires-http1-0"><a href="#Expires-http1-0" class="headerlink" title="Expires http1.0"></a>Expires http1.0</h5><p><img src="/2019/06/16/浏览器缓存详解/Exprires_we.jpeg" alt=""></p><p>Expires 设置缓存过期时间</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(<span class="string">'Expires'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.now() + <span class="number">600000</span>));<span class="comment">// 当前时间过十分钟后过期</span></span><br></pre></td></tr></table></figure><p><img src="/2019/06/16/浏览器缓存详解/Expires.jpg" alt="Expires"></p><p>图中表示该文件在Tue Jun 25 2019 16:17:08 GMT+0800 日期过期，所以第一次请求的时候我们可以看到状态是200，然后下次请求时从缓存中获取的资源而没有请求服务器</p><p>第一次请求</p><p><img src="/2019/06/16/浏览器缓存详解/Expires1.png" alt=""></p><p>第二次请求</p><p><img src="/2019/06/16/浏览器缓存详解/Expires2.png" alt=""></p><p>但是如果服务器时间和客户端时间不同步，如果服务器时间快于客户端时间的话，我们设置的缓存时间小于服务器大于客户端时间的话，那么我们设置的缓存时间就不起作用了；如果服务器时落后于客户端时间，有可能导致缓存时间已经过了，但是还是用的缓存。</p><p>为了避免这个问题，http1.1推出了Cache-Control</p><h5 id="Cache-Control-http1-1"><a href="#Cache-Control-http1-1" class="headerlink" title="Cache-Control http1.1"></a>Cache-Control http1.1</h5><p>Cache-Control的常见属性</p><ol><li>private: 客户端可以缓存</li><li>public: 客户端和代理服务器都可缓存</li><li>max-age=xxx: 缓存的内容将在 xxx 秒后失效</li><li>no-cache: 需要使用对比缓存来验证缓存数据</li><li>no-store: 所有内容都不会缓存，强制缓存，对比缓存都不会触发</li></ol><p><img src="/2019/06/16/浏览器缓存详解/Cache-Control.jpeg" alt=""></p><p>Cache-Control设置的是相对时间</p><pre><code>res.setHeader(&apos;Cache-Control&apos;, &apos;public, max-age=10&apos;);</code></pre><p>这个代码设置的是缓存相对于当前时间10s后过期，这样就算服务器和客户端时间不同步也不会影响。</p><p>如果同时存在Expires和Cache-Control，Cache-Control的优先级更高。</p><p>但是不管是Expires还是Cache-Control，都是设置缓存过期时间，但是缓存时间过期后其实资源并没有改变，但是还是去请求资源了，为了解决这样的问题，所以有了协商缓存。</p><h4 id="c-协商缓存"><a href="#c-协商缓存" class="headerlink" title="c. 协商缓存"></a>c. 协商缓存</h4><p>强缓存都是浏览器通过响应报文的某个字段去设置缓存，协商缓存是通过一组字段结合起来进行缓存。</p><h4 id="Last-Modified和If-Modified-Since"><a href="#Last-Modified和If-Modified-Since" class="headerlink" title="Last-Modified和If-Modified-Since"></a>Last-Modified和If-Modified-Since</h4><p><img src="/2019/06/16/浏览器缓存详解/Last.jpeg" alt=""></p><p>Last-Modified 顾名思义是最后一次修改时间，这个是服务端获取到的，在响应报文里会返回，If-Modified-Since（等于上一次请求的Last-Modified）是浏览器根据服务端返回的Last—Modified设置的，可以理解成浏览器端存储的资源的最后修改时间。</p><p>协商，也就是浏览器和服务器之间进行协商，如果资源有改动，那么服务器每次返回时会带上一个字段Last-Modified，该资源的最后修改时间，还有一个资源过期时间，可以是Cache-Control或者Expires，然后浏览器获取到这两个字段，并且保存下来，在缓存时间没有过期时，浏览器会从缓存中获取资源，不会请求服务器，等到缓存过期时，浏览器请求服务器，请求报文会带上一个字段If-Modified-Since，这个字段是上一次的Last-Modified，然后服务器会判断最新的Last-Modified和If-Modified-Since是否相等，如果相等，意味着该资源在这段时间并没有改动，那么浏览器会返回304，如果不想等的话，服务器会将最新的Last-Modified返回，并且返回改动后的资源，并且状态码为200</p><p>下面的图是一个我们修改demo.js后浏览器和服务器的通信。</p><p><img src="/2019/06/16/浏览器缓存详解/Last-modified.png" alt=""></p><p>这个缓存方法有两个问题：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 因为Last-Modified的时间是GMT时间，只能精确到秒，如果文件在1秒内有多次改动，服务器并不知道文件有改动，那么浏览器获取不到最新的文件。</span><br><span class="line">2. 如果服务器上某资源被多次改动，但是内容并没有变化，服务器会更新改动时间，所以每次都会返回给客户端</span><br></pre></td></tr></table></figure><p>为了解决这些问题，我们引入了ETag和If-None—Match</p><h4 id="ETag和If-None-Match"><a href="#ETag和If-None-Match" class="headerlink" title="ETag和If-None-Match"></a>ETag和If-None-Match</h4><p>上面的Last-Modified是通过资源改动时间去判断是否该给客户端返回新的资源，现在是通过ETag：资源的唯一标识来判断，只有资源的内容改变时，ETag才会改变。</p><p>If-None-Match是上一次的ETag。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>那么到这关于http缓存的几个首部字段且含义已经介绍完了，那么问题来了，浏览器无法主动得知资源的变化，只有没有Expires或者是Cache-Control设置的缓存时间过期后，浏览器主动请求服务端以此得知资源的变化。</p><p>那么我们应该怎么解决这个问题？</p><p><img src="/2019/06/16/浏览器缓存详解/黑人问号.jpeg" alt=""></p><p><img src="/2019/06/16/浏览器缓存详解/answer.jpeg" onclick="document.getElementsByClassName('fd-img')[0].style.display='block'"></p><p><style><br>.fd-img {<br>    display: none;<br>}<br></style><br><img src="/2019/06/16/浏览器缓存详解/version.png" class="fd-img"></p><p>在公司呆的时间比较长的话看到第一段代码可能比较熟悉，以前用require.js的时候我们会在文件名后面加上版本号和时间戳，最近的项目用webpack的话，打包文件的时候也会在文件名后加上哈希数。</p><p>这样做的思路就是因为每次文件有改动后，比如js，那么会导致html页面也会跟着改动，因为html里引用了该js文件，所以浏览器去访问html页面时发现页面已经改动了，就会去请求服务器。这样我们就能做到浏览器主动得知资源的变动。</p><h2 id="五、浏览器本地缓存"><a href="#五、浏览器本地缓存" class="headerlink" title="五、浏览器本地缓存"></a>五、浏览器本地缓存</h2><h3 id="一-manifest（H5的应用缓存）"><a href="#一-manifest（H5的应用缓存）" class="headerlink" title="(一) manifest（H5的应用缓存）"></a>(一) manifest（H5的应用缓存）</h3><p>浏览器缓存中划分出了一块缓存区，如果想要在这个缓存中保存数据，可以用一个描述文件，列出要下载和缓存的资源，然后将该描述文件于页面关联起来，可以在<html>中的manifest属性中指定这个文件的路径，比如：</html></p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;html manifest=&apos;/offline.manifest&apos;&gt;</span><br></pre></td></tr></table></figure><h3 id="（二）storage-Web-存储机制"><a href="#（二）storage-Web-存储机制" class="headerlink" title="（二）storage(Web 存储机制)"></a>（二）storage(Web 存储机制)</h3><p>Web Storage 包含如下两种机制：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. sessionStorage 为每一个给定的源（given origin）维持一个独立的存储区域，该存储区域在页面会话期间可用（即只要浏览器处于打开状态，包括页面重新加载和恢复）。</span><br><span class="line">2. localStorage 同样的功能，但是在浏览器关闭，然后重新打开后数据仍然存在。</span><br></pre></td></tr></table></figure><h3 id="（三）indexDB"><a href="#（三）indexDB" class="headerlink" title="（三）indexDB"></a>（三）indexDB</h3><blockquote><p>ndexedDB是一种低级API，用于客户端存储大量结构化数据(包括, 文件/ blobs)。该API使用索引来实现对该数据的高性能搜索。虽然 Web Storage 对于存储较少量的数据很有用，但对于存储更大量的结构化数据来说，这种方法不太有用。IndexedDB提供了一个解决方案。</p></blockquote><h3 id="（四）cookie"><a href="#（四）cookie" class="headerlink" title="（四）cookie"></a>（四）cookie</h3><blockquote><p>HTTP Cookie（也叫Web Cookie或浏览器Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie使基于无状态的HTTP协议记录稳定的状态信息成为了可能。</p></blockquote><h2 id="六、后记"><a href="#六、后记" class="headerlink" title="六、后记"></a>六、后记</h2><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ol><li><p><a href="https://juejin.im/post/5b70edd4f265da27df0938bc" target="_blank" rel="noopener">前端也要懂Http缓存机制</a></p></li><li><p><a href="https://juejin.im/post/5b3c87386fb9a04f9a5cb037" target="_blank" rel="noopener">面试精选之http缓存</a></p></li><li><p>《图解HTTP》</p></li><li>《JavaScript高级程序设计》</li></ol>]]></content>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>javaScript 数组方法总结</title>
      <link href="/2019/06/15/javaScript-%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2019/06/15/javaScript-%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h2 id="数组方法总结"><a href="#数组方法总结" class="headerlink" title="数组方法总结"></a>数组方法总结</h2><h3 id="1-concat"><a href="#1-concat" class="headerlink" title="1. concat()"></a>1. concat()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： arr1.concat(arrayX,arrayX,......,arrayX)</span><br><span class="line">返回值：一个连接新数组，包含了arr1和所有arrayX</span><br><span class="line">参数：arrayX：可以是具体元素值，也可以是数组，数量是任意</span><br><span class="line">作用：连接两个或多个数组</span><br><span class="line">缺点：效率低</span><br></pre></td></tr></table></figure><p>示例1：</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> resArr = arr1.concat(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(resArr);<span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>示例2:</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> resArr = arr1.concat([<span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="built_in">console</span>.log(resArr);<span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>示例3:</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> resArr = arr1.concat([<span class="number">4</span>, <span class="number">5</span>],[<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line"><span class="built_in">console</span>.log(resArr);<span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure><h3 id="2-Array"><a href="#2-Array" class="headerlink" title="2. Array()"></a>2. Array()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法： new Array(xArrayElement)</span><br><span class="line">返回值： 一个Array实例</span><br><span class="line">参数：xArrayElement数组里的内容</span><br><span class="line">作用：创建一个数组</span><br></pre></td></tr></table></figure><p>示例1：</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> resArr = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line"><span class="built_in">console</span>.log(resArr);<span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>示例2:</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> resArr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(resArr);<span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure><p>示例3:</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> resArr = <span class="keyword">new</span> <span class="built_in">Array</span>([<span class="number">1</span>, <span class="number">2</span>], <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(resArr);<span class="comment">//[[1, 2], 2]</span></span><br></pre></td></tr></table></figure><h3 id="3-copyWithin"><a href="#3-copyWithin" class="headerlink" title="3. copyWithin()"></a>3. copyWithin()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">语法： arr.copyWithin(target[, start[, end]])</span><br><span class="line">返回值：改变后的arr</span><br><span class="line">参数：</span><br><span class="line">1. target 复制的数组的某一部分到target下标的位置,如果target大于start，那么复制的序列会从start到end复制从target下标开始，超出数组长度的元素就不会复制成功，如示例1</span><br><span class="line">2. start 复制的起始下标，不设置代表复制从数组第一个元素开始</span><br><span class="line">3. end 复制的结束下标，不设置代表复制到数组结束</span><br><span class="line">作用：复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度。</span><br></pre></td></tr></table></figure><p>示例1：</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> resArr = arr.copyWithin(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(resArr);<span class="comment">// [1, 2, 3, 4, 1]</span></span><br></pre></td></tr></table></figure><p>示例2:</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> resArr = arr.copyWithin(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(resArr);<span class="comment">// [1, 3, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><h3 id="4-entries"><a href="#4-entries" class="headerlink" title="4. entries()"></a>4. entries()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法：arr.entries()</span><br><span class="line">返回值：新的Array Iterator对象</span><br><span class="line">参数：</span><br><span class="line">作用：</span><br></pre></td></tr></table></figure><p>示例1：</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">"hello"</span>, <span class="string">"hi"</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> iteartor = arr.entries()</span><br><span class="line"><span class="built_in">console</span>.log(iteartor); <span class="comment">//Array Iterator &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iteartor.next().value) <span class="comment">// [0, "hello"]</span></span><br><span class="line"><span class="built_in">console</span>.log(iteartor.next().value) <span class="comment">// [1, "hi"]</span></span><br><span class="line"><span class="built_in">console</span>.log(iteartor.next().done) <span class="comment">// true done表示迭代是否完成</span></span><br></pre></td></tr></table></figure><h3 id="5-every"><a href="#5-every" class="headerlink" title="5. every()"></a>5. every()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">语法： arr.every(callback[, thisArg])</span><br><span class="line">返回值：布尔值</span><br><span class="line">参数：</span><br><span class="line">1. callback函数 检测数组元素的函数</span><br><span class="line">callback接受三个参数element（检测数组当前的元素），index（检测数组当前的元素的下标），arr（被检测的数组）</span><br><span class="line">2. thisArg this指向</span><br><span class="line">作用：检测arr数组的所有元素都能经过callback函数的检测，如果所有数组元素都通过才返回true，如果只有一个不通过都会返回false</span><br></pre></td></tr></table></figure><p>示例1：</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBigTen</span> (<span class="params">element, index, array</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"element: "</span>+ element + <span class="string">";index: "</span> + index + <span class="string">";array: "</span>+ array);</span><br><span class="line"><span class="comment">/* element: 1;index: 0;array: 1, 10, 4, 5*/</span></span><br><span class="line"><span class="keyword">if</span> (element &gt; <span class="number">10</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> res = arr.every(isBigTen,<span class="keyword">this</span>)</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = [<span class="number">1</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">5</span>].every(<span class="function"><span class="params">x</span> =&gt;</span> x &gt; <span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>示例2:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let arr = [11, 110, 14, 15];</span><br><span class="line">function isBigTen (element, index, array) &#123;</span><br><span class="line">console.log(&quot;element: &quot;+ element + &quot;;index: &quot; + index + &quot;;array: &quot;+ array);</span><br><span class="line">/* element: 11;index: 0;array: 11,110,14,15</span><br><span class="line">element: 110;index: 1;array: 11,110,14,15</span><br><span class="line">element: 14;index: 2;array: 11,110,14,15</span><br><span class="line"> element: 15;index: 3;array: 11,110,14,15*/</span><br><span class="line">if (element &gt; 10) &#123;</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">let res = arr.every(isBigTen,this)</span><br><span class="line">console.log(res); // true</span><br></pre></td></tr></table></figure><h3 id="6-fill"><a href="#6-fill" class="headerlink" title="6. fill()"></a>6. fill()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">语法： arr.fill(value[, start[, end]])</span><br><span class="line">返回值：填充后的数组</span><br><span class="line">参数：</span><br><span class="line">1. value 用来填充的数值</span><br><span class="line">2. start 填充的起始位置，不填，默认0</span><br><span class="line">3. end 填充的结束位置，不填，默认arr.length-1</span><br><span class="line">作用：填充数组</span><br></pre></td></tr></table></figure><p>示例1：</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr = arr.fill(<span class="string">"hello"</span>,<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// ["hello", "hello", 4, 5]</span></span><br></pre></td></tr></table></figure><h3 id="7-filter"><a href="#7-filter" class="headerlink" title="7. filter()"></a>7. filter()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法： var newArray = arr.filter(callback(element[, index[, array]])[, thisArg])</span><br><span class="line">返回值：一个新数组</span><br><span class="line">参数：和every一样</span><br><span class="line">作用：找到数组中符合经过callback函数筛选出来的元素，返回到新数组里</span><br></pre></td></tr></table></figure><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBigTen</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> element &gt;= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> filtered = [<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>].filter(isBigTen);</span><br><span class="line"><span class="built_in">console</span>.log(filtered); <span class="comment">// [12, 130, 44]</span></span><br></pre></td></tr></table></figure><h3 id="8-find"><a href="#8-find" class="headerlink" title="8. find()"></a>8. find()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法： arr.find(callback[, thisArg])</span><br><span class="line">返回值：符合测试函数callback的第一个数组元素</span><br><span class="line">参数：和every()一样</span><br><span class="line">作用：找到第一个符合测试函数的数组元素</span><br></pre></td></tr></table></figure><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBigTen</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> element &gt;= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> filtered = [<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>].find(isBigTen);</span><br><span class="line"><span class="built_in">console</span>.log(filtered); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><h3 id="9-findIndex"><a href="#9-findIndex" class="headerlink" title="9. findIndex()"></a>9. findIndex()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法： arr.findIndex(callback[, thisArg])</span><br><span class="line">返回值：符合测试函数callback的第一个数组元素下标</span><br><span class="line">参数：和every()一样</span><br><span class="line">作用：找到第一个符合测试函数的数组元素的下标</span><br></pre></td></tr></table></figure><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBigTen</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> element &gt;= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> filtered = [<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>].findIndex(isBigTen);</span><br><span class="line"><span class="built_in">console</span>.log(filtered); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h3 id="10-flat"><a href="#10-flat" class="headerlink" title="10. flat()"></a>10. flat()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法： var newArray = arr.flat(depth)</span><br><span class="line">返回值：一个新数组</span><br><span class="line">参数：depth：遍历的深度</span><br><span class="line">作用：将一个多维数组按照遍历的深度合成一个新的数组，例如把多维数组扁平化成1维数组</span><br></pre></td></tr></table></figure><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> flatRes = [<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>,[<span class="number">11</span>, <span class="number">130</span>, <span class="string">"22"</span>, [<span class="string">"hello"</span>, <span class="number">33</span>]], <span class="number">44</span>].flat(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(flatRes); <span class="comment">//  [12, 5, 8, 11, 130, "22", "hello", 33, 44]</span></span><br></pre></td></tr></table></figure><h3 id="11-flatMap"><a href="#11-flatMap" class="headerlink" title="11. flatMap()"></a>11. flatMap()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">语法： var new_array = arr.flatMap(function callback(currentValue[, index[, array]]) &#123;</span><br><span class="line">    // 返回新数组的元素</span><br><span class="line">&#125;[, thisArg])</span><br><span class="line">返回值：一个新的数组，其中每个元素都是回调函数的结果，并且结构深度 depth 值为1。</span><br><span class="line">参数：</span><br><span class="line">1. callback:可以生成一个新数组中的元素的函数，可以传入三个参数：</span><br><span class="line">* currentValue当前正在数组中处理的元素</span><br><span class="line">* index可选可选的。数组中正在处理的当前元素的索引。</span><br><span class="line">* array可选可选的。被调用的 map 数组</span><br><span class="line">2.thisArg可选.执行 callback 函数时 使用的this值</span><br><span class="line">作用：首先使用映射函数映射每个元素，然后将结果压缩成一个新数组</span><br></pre></td></tr></table></figure><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> flatMapRes = [<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="string">"22"</span>, <span class="string">"hello"</span>, <span class="number">33</span>, <span class="number">44</span>].flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [<span class="built_in">parseInt</span>(x)*<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(flatMapRes); <span class="comment">//   [24, 10, 16, 44, NaN, 66, 88]</span></span><br></pre></td></tr></table></figure><h3 id="12-forEach"><a href="#12-forEach" class="headerlink" title="12. forEach()"></a>12. forEach()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法： arr.forEach(callback[, thisArg]);</span><br><span class="line">返回值：undefined</span><br><span class="line">参数：和flatMap一样</span><br><span class="line">作用：forEach 方法按升序为数组中含有效值的每一项执行一次callback 函数，那些已删除或者未初始化的项将被跳过（例如在稀疏数组上</span><br></pre></td></tr></table></figure><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">var</span> flatMapRes = [<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="string">"22"</span>, <span class="string">"hello"</span>, <span class="number">33</span>, <span class="number">44</span>].forEach(<span class="function"><span class="params">x</span> =&gt;</span> arr.push(x));</span><br><span class="line"><span class="built_in">console</span>.log(flatMapRes); <span class="comment">//  undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [12, 5, 8, "22", "hello", 33, 44]</span></span><br></pre></td></tr></table></figure><h3 id="13-includes"><a href="#13-includes" class="headerlink" title="13. includes()"></a>13. includes()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法： arr.includes(valueToFind[, fromIndex])</span><br><span class="line">返回值：true或false</span><br><span class="line">参数：valueToFind： 被查找到元素。fromIndex：从下标fromIndex开始查找</span><br><span class="line">作用：用来判断一个数组里是否包含某个元素，如果包含，则返回true，否则false</span><br></pre></td></tr></table></figure><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = [<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="string">"22"</span>, <span class="string">"hello"</span>, <span class="number">33</span>, <span class="number">44</span>]. includes(<span class="number">33</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">//  true</span></span><br><span class="line"><span class="keyword">var</span> res1 = [<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="string">"22"</span>, <span class="string">"hello"</span>, <span class="number">33</span>, <span class="number">44</span>]. includes(<span class="string">"hi"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res1); <span class="comment">//  false</span></span><br></pre></td></tr></table></figure><h3 id="14-indexOf"><a href="#14-indexOf" class="headerlink" title="14. indexOf()"></a>14. indexOf()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： </span><br><span class="line">返回值：</span><br><span class="line">参数：</span><br><span class="line">作用：</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure><h3 id="15-join"><a href="#15-join" class="headerlink" title="15. join()"></a>15. join()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： </span><br><span class="line">返回值：</span><br><span class="line">参数：</span><br><span class="line">作用：</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure><h3 id="16-keys"><a href="#16-keys" class="headerlink" title="16. keys()"></a>16. keys()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： </span><br><span class="line">返回值：</span><br><span class="line">参数：</span><br><span class="line">作用：</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure><h3 id="17-lastIndexOf"><a href="#17-lastIndexOf" class="headerlink" title="17. lastIndexOf()"></a>17. lastIndexOf()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： </span><br><span class="line">返回值：</span><br><span class="line">参数：</span><br><span class="line">作用：</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure><h3 id="18-map"><a href="#18-map" class="headerlink" title="18. map()"></a>18. map()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： </span><br><span class="line">返回值：</span><br><span class="line">参数：</span><br><span class="line">作用：</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure><h3 id="19-pop"><a href="#19-pop" class="headerlink" title="19. pop()"></a>19. pop()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： </span><br><span class="line">返回值：</span><br><span class="line">参数：</span><br><span class="line">作用：</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure><h3 id="20-push"><a href="#20-push" class="headerlink" title="20. push()"></a>20. push()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： </span><br><span class="line">返回值：</span><br><span class="line">参数：</span><br><span class="line">作用：</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure><h3 id="21-reduce"><a href="#21-reduce" class="headerlink" title="21. reduce()"></a>21. reduce()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： </span><br><span class="line">返回值：</span><br><span class="line">参数：</span><br><span class="line">作用：</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure><h3 id="22-reduceRight"><a href="#22-reduceRight" class="headerlink" title="22. reduceRight()"></a>22. reduceRight()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： </span><br><span class="line">返回值：</span><br><span class="line">参数：</span><br><span class="line">作用：</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure><h3 id="23-reverse"><a href="#23-reverse" class="headerlink" title="23. reverse()"></a>23. reverse()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： </span><br><span class="line">返回值：</span><br><span class="line">参数：</span><br><span class="line">作用：</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure><h3 id="24-shift"><a href="#24-shift" class="headerlink" title="24. shift()"></a>24. shift()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： </span><br><span class="line">返回值：</span><br><span class="line">参数：</span><br><span class="line">作用：</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure><h3 id="25-slice"><a href="#25-slice" class="headerlink" title="25. slice()"></a>25. slice()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： </span><br><span class="line">返回值：</span><br><span class="line">参数：</span><br><span class="line">作用：</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure><h3 id="26-some"><a href="#26-some" class="headerlink" title="26. some()"></a>26. some()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： </span><br><span class="line">返回值：</span><br><span class="line">参数：</span><br><span class="line">作用：</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure><h3 id="27-sort"><a href="#27-sort" class="headerlink" title="27. sort()"></a>27. sort()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： </span><br><span class="line">返回值：</span><br><span class="line">参数：</span><br><span class="line">作用：</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure><h3 id="28-splice"><a href="#28-splice" class="headerlink" title="28. splice()"></a>28. splice()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： </span><br><span class="line">返回值：</span><br><span class="line">参数：</span><br><span class="line">作用：</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure><h3 id="29-toLocaleString"><a href="#29-toLocaleString" class="headerlink" title="29. toLocaleString()"></a>29. toLocaleString()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： </span><br><span class="line">返回值：</span><br><span class="line">参数：</span><br><span class="line">作用：</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure><h3 id="30-toString"><a href="#30-toString" class="headerlink" title="30. toString()"></a>30. toString()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： </span><br><span class="line">返回值：</span><br><span class="line">参数：</span><br><span class="line">作用：</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure><h3 id="31-unshift"><a href="#31-unshift" class="headerlink" title="31. unshift()"></a>31. unshift()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： </span><br><span class="line">返回值：</span><br><span class="line">参数：</span><br><span class="line">作用：</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure><h3 id="32-values"><a href="#32-values" class="headerlink" title="32. values()"></a>32. values()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： </span><br><span class="line">返回值：</span><br><span class="line">参数：</span><br><span class="line">作用：</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure><h3 id="33-from"><a href="#33-from" class="headerlink" title="33. from()"></a>33. from()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： </span><br><span class="line">返回值：</span><br><span class="line">参数：</span><br><span class="line">作用：</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure><h3 id="34-isArray"><a href="#34-isArray" class="headerlink" title="34. isArray()"></a>34. isArray()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： </span><br><span class="line">返回值：</span><br><span class="line">参数：</span><br><span class="line">作用：</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure><h3 id="32-of"><a href="#32-of" class="headerlink" title="32.of()"></a>32.of()</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： </span><br><span class="line">返回值：</span><br><span class="line">参数：</span><br><span class="line">作用：</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> JavaScript Array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基于vue cli3实现自己的组件库且发布到npm（一）环境搭建</title>
      <link href="/2019/06/12/%E5%9F%BA%E4%BA%8Evue-cli3%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BB%84%E4%BB%B6%E5%BA%93%E4%B8%94%E5%8F%91%E5%B8%83%E5%88%B0npm%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2019/06/12/%E5%9F%BA%E4%BA%8Evue-cli3%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BB%84%E4%BB%B6%E5%BA%93%E4%B8%94%E5%8F%91%E5%B8%83%E5%88%B0npm%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="安装vue-cli3-0"><a href="#安装vue-cli3-0" class="headerlink" title="安装vue-cli3.0"></a>安装vue-cli3.0</h2><p>因为我电脑之前有装了vue-cli2的，所以要先卸载以前的版本，再安装新的版本。</p><pre><code>npm uninstall vue-cli -g</code></pre><p>然后再安装新版本</p><pre><code>npm install -g @vue/cli </code></pre><p>安装成功后用<code>vue -V</code>查看，发现还是2.9.x版本，我看了一下node版本是符合要求的，然后我真是的一脸懵逼。然后网上搜了下，最后找到了一个解决办法（window系统有遇到这个问题，mac没有）。</p><ol><li>把node完全卸载了，文件也删除干净。</li><li>然后下载nvm，<a href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="noopener">下载传送门</a>，选择相应的版本，然后选择下载nvm-setup.zip这个包，然后安装成功后，命令行输入nvm，会出现nvm版本号和一系列指令。</li><li>命令行输入 <code>nvm install node版本号</code>,就可以安装相应版本的node,最后<code>nvm use node版本号</code>使用指定版本的node</li><li>最后在命令行输入<code>npm install -g @vue/cli</code>，发现输出终于是3.x了，欢呼！！</li></ol><a id="more"></a><h2 id="创建github项目"><a href="#创建github项目" class="headerlink" title="创建github项目"></a>创建github项目</h2><p>为了后期维护，我把代码上传到了github上，<a href="https://github.com/zzilcc/zzilccComponent/tree/develop" target="_blank" rel="noopener">项目地址</a>,具体怎么上传到github请自行搜索。</p><p>代码上传后默认是提交到master分支，我们拉一个develop分支，在该分支上进行开发。</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>vue-cli3.0是通过 <code>create</code>创建，跟2.0是有区别。</p><pre><code>vue create zzilcc-ui</code></pre><p>通过上面的命令，我们创建了一个新的项目。</p><p>运行<code>npm run serve</code>就能把项目起起来。</p><h3 id="调整目录"><a href="#调整目录" class="headerlink" title="调整目录"></a>调整目录</h3><p>我们需要一个目录存放示例，一个目录存放真的组件代码，所以我们将原先的src目录改名成examples，然后新增一个packages目录，用来放组件代码。</p><p>所以调整后的目录是这样的</p><p><img src="/2019/06/12/基于vue-cli3实现自己的组件库且发布到npm（一）环境搭建/目录结构.png" alt=""></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="重新配置入口为example-main-js"><a href="#重新配置入口为example-main-js" class="headerlink" title="重新配置入口为example/main.js"></a>重新配置入口为example/main.js</h3><p>因为我们刚把src目录改成了example，所以我们要修改一下项目的入口文件的路径，我们创建在根目录下创建一个vue.config.js文件。</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">pages: &#123;</span><br><span class="line">index: &#123;</span><br><span class="line">entry: <span class="string">'examples/main.js'</span>, <span class="comment">// 修改src目录为examples</span></span><br><span class="line">template: <span class="string">'public/index.html'</span>,</span><br><span class="line">filename: <span class="string">'index.html'</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="支持对packages目录的支持"><a href="#支持对packages目录的支持" class="headerlink" title="支持对packages目录的支持"></a>支持对packages目录的支持</h3><p>packages是我们新增的，我们需要手动配置，要不然webpack是不会处理。</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">pages: &#123;</span><br><span class="line">index: &#123;</span><br><span class="line">entry: <span class="string">'examples/main.js'</span>, <span class="comment">// 修改src目录为examples</span></span><br><span class="line">template: <span class="string">'public/index.html'</span>,</span><br><span class="line">filename: <span class="string">'index.html'</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 扩展webpack位置，让packages加入编译</span></span><br><span class="line">config.module</span><br><span class="line">.rule(<span class="string">'js'</span>)</span><br><span class="line">.incluede</span><br><span class="line">.add(<span class="string">'packages'</span>)</span><br><span class="line">.end()</span><br><span class="line">.use(<span class="string">'babel'</span>)</span><br><span class="line">.loader(<span class="string">'babel-loader'</span>)</span><br><span class="line">.tap(<span class="function"><span class="params">options</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 修改它的选项</span></span><br><span class="line"><span class="keyword">return</span> options</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编写组件"><a href="#编写组件" class="headerlink" title="编写组件"></a>编写组件</h2><h3 id="创建一个新组件"><a href="#创建一个新组件" class="headerlink" title="创建一个新组件"></a>创建一个新组件</h3><pre><code>1. 我们在packages目录下创建一个button文件夹，每个组件都一个文件夹2. 在button文件夹下创建src文件夹，用来存放组件源码，并在src文件夹里创建一个z-button.vue3. 在button文件里创建一个index.js,用来对外提供组件的引用</code></pre><p><img src="/2019/06/12/基于vue-cli3实现自己的组件库且发布到npm（一）环境搭建/button1.png" alt=""></p><p>为了测试，我们在z-button.vue的template里写一个<code>&lt;button&gt;</code></p><p><img src="/2019/06/12/基于vue-cli3实现自己的组件库且发布到npm（一）环境搭建/button.png" alt=""></p><p>然后再button/index.js里写组件的install方法，创建相应的组件方法，供外部调用。</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入组件，组件必须声明name</span></span><br><span class="line"><span class="keyword">import</span> zButton <span class="keyword">from</span> <span class="string">'./src/z-button.vue'</span></span><br><span class="line"><span class="comment">// 为组件提供install方法，供按需引入</span></span><br><span class="line">zButton.install = <span class="function"><span class="keyword">function</span> (<span class="params">Vue</span>) </span>&#123;</span><br><span class="line">Vue.component(zButton.name, zButton)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 默认导出组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> zButton</span><br></pre></td></tr></table></figure><h3 id="整合所有组件，对外导出"><a href="#整合所有组件，对外导出" class="headerlink" title="整合所有组件，对外导出"></a>整合所有组件，对外导出</h3><p>修改packages/index.js</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入z-button组件</span></span><br><span class="line"><span class="keyword">import</span> zButton <span class="keyword">from</span> <span class="string">'./button'</span></span><br><span class="line"><span class="comment">// 存储组件列表</span></span><br><span class="line"><span class="keyword">const</span> components = [</span><br><span class="line">zButton</span><br><span class="line">]</span><br><span class="line"><span class="comment">// 定义 install 方法，接收 Vue 作为参数。如果使用 use 注册插件，则所有的组件都将被注册</span></span><br><span class="line"><span class="keyword">const</span> install = <span class="function"><span class="keyword">function</span> (<span class="params">Vue</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 判断是否安装</span></span><br><span class="line"><span class="keyword">if</span> (install.installed) <span class="keyword">return</span></span><br><span class="line"><span class="comment">// 遍历注册全局组件</span></span><br><span class="line">components.map(<span class="function"><span class="params">component</span> =&gt;</span> Vue.component(component.name, component))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断是否是直接引入文件</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span> &amp;&amp; <span class="built_in">window</span>.Vue) &#123;</span><br><span class="line">install(<span class="built_in">window</span>.Vue)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"><span class="comment">// 导出的对象必须具有 install，才能被 Vue.use() 方法安装</span></span><br><span class="line">install,</span><br><span class="line"><span class="comment">// 以下是具体的组件列表</span></span><br><span class="line">zButton</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建主题样式"><a href="#创建主题样式" class="headerlink" title="创建主题样式"></a>创建主题样式</h2><p>因为第一次建组件库，没什么经验，然后借鉴了好多ui组件库，比如element ui,iView,VV-UI等，我看到他们都没有在组件vue文件中去写相应的样式，也没有显示调用样式文件，然后研究了一下element ui的，发现它是将样式所有抽离出来，用gulp打包编译。然后我们在项目中需要引用样式文件。</p><h3 id="创建一个github新项目"><a href="#创建一个github新项目" class="headerlink" title="创建一个github新项目"></a>创建一个github新项目</h3><p>我创建了一个名为theme-default的github项目用来存放主题样式。然后得到了一个项目地址。</p><h3 id="创建样式文件目录"><a href="#创建样式文件目录" class="headerlink" title="创建样式文件目录"></a>创建样式文件目录</h3><p>我们在packages/下新建一个样式目录，叫做‘theme-default’，这个名字你可以随意。</p><h3 id="初始化样式文件"><a href="#初始化样式文件" class="headerlink" title="初始化样式文件"></a>初始化样式文件</h3><p>我们通过<code>npm init</code>初始化，然后命令行会出现一些内容让你填写，比如name,main,author等，关于git项目的选项，我们要填上第一步创建的github项目地址，然后结束后在theme-default目录下会出现package.json,里面的内容就是你刚刚填写的。</p><p>我们在样式目录下新建一个src目录用来放置样式文件，然后在src目录下创建button.scss,和index.scss.</p><p>然后安装一下scss/sass</p><pre><code>npm install -D sass-loader node-sass</code></pre><p>在button.scss里先写</p><figure class="hljs highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.z-button</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: inline-block;</span><br><span class="line"><span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line"><span class="attribute">cursor</span>: pointer;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#eee</span>;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在index.scss</p><figure class="hljs highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">import</span> <span class="string">"./button.scss"</span></span><br></pre></td></tr></table></figure><h2 id="安装gulp"><a href="#安装gulp" class="headerlink" title="安装gulp"></a>安装gulp</h2><p>下面的命令都是在theme-default目录下执行</p><p>全局安装：</p><pre><code>npm install --global gulp</code></pre><p>作为项目的开发依赖（devDependencies）安装：</p><pre><code>npm install --save-dev gulp</code></pre><p>在theme-default目录下创建一个gulpfile.js，在改文件中编写</p><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; series, src, dest &#125; = <span class="built_in">require</span>(<span class="string">'gulp'</span>)</span><br><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">'gulp-sass'</span>)</span><br><span class="line"><span class="keyword">const</span> autoprefixer = <span class="built_in">require</span>(<span class="string">'gulp-autoprefixer'</span>)</span><br><span class="line"><span class="keyword">const</span> cssmin = <span class="built_in">require</span>(<span class="string">'gulp-cssmin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compile</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> src(<span class="string">'./src/*.scss'</span>)</span><br><span class="line">.pipe(sass.sync())</span><br><span class="line">.pipe(autoprefixer(&#123;</span><br><span class="line">browsers: [<span class="string">'ie &gt; 9'</span>, <span class="string">'last 2 versions'</span>],</span><br><span class="line">cascade: <span class="literal">false</span></span><br><span class="line">&#125;))</span><br><span class="line">.pipe(cssmin())</span><br><span class="line">.pipe(dest(<span class="string">'../../lib/theme-default'</span>)) <span class="comment">// 这是输出地址，我写到了和组件编译后的地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyfont</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> src(<span class="string">'./src/fonts/**'</span>)</span><br><span class="line">.pipe(cssmin())</span><br><span class="line">.pipe(dest(<span class="string">'../../lib/fonts/theme-default'</span>))<span class="comment">// 同上</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.build = series(compile, copyfont)</span><br></pre></td></tr></table></figure><h2 id="发布到npm"><a href="#发布到npm" class="headerlink" title="发布到npm"></a>发布到npm</h2><h3 id="配置命令"><a href="#配置命令" class="headerlink" title="配置命令"></a>配置命令</h3><p>我们在zzilcc-ui目录下的package.json的scripts里加一个lib命令</p><figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">"serve": "vue-cli-service serve",</span><br><span class="line">"build": "vue-cli-service build",</span><br><span class="line">"lint": "vue-cli-service lint",</span><br><span class="line">"lib": "vue-cli-service build --target lib --name zzilcc-ui --dest lib packages/index.js &amp;&amp; gulp build --gulpfile packages/theme-default/gulpfile.js"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>然后运行lib命令  <code>npm run lib</code></p><p>该命令其实执行了两个命令，第一个是vue-cli3.0的vue-cli-service build</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">用法：vue-cli-service build [options] [entry|pattern]</span><br><span class="line">选项：</span><br><span class="line"></span><br><span class="line">--mode        指定环境模式 (默认值：production)</span><br><span class="line">--dest        指定输出目录 (默认值：dist)</span><br><span class="line">--modern      面向现代浏览器带自动回退地构建应用</span><br><span class="line">--target      app | lib | wc | wc-async (默认值：app)</span><br><span class="line">--name        库或 Web Components 模式下的名字 (默认值：package.json 中的 &quot;name&quot; 字段或入口文件名)</span><br><span class="line">--no-clean    在构建项目之前不清除目标目录</span><br><span class="line">--report      生成 report.html 以帮助分析包内容</span><br><span class="line">--report-json 生成 report.json 以帮助分析包内容</span><br><span class="line">--watch       监听文件变化</span><br></pre></td></tr></table></figure><p>vue-cli-service build 会在 dist/ 目录产生一个可用于生产环境的包，带有 JS/CSS/HTML 的压缩，和为更好的缓存而做的自动的 vendor chunk splitting。 –vue-cli官网</p><p>第二个命令是执行样式文件的gulp build</p><p>命令执行完后会在zzilcc-ui下生成一个lib文件</p><p><img src="/2019/06/12/基于vue-cli3实现自己的组件库且发布到npm（一）环境搭建/lib.png" alt=""></p><p>箭头指向的是生成主题样式文件，然后是html，和压缩后的js</p><h3 id="配置-package-json-文件中发布到-npm-的字段"><a href="#配置-package-json-文件中发布到-npm-的字段" class="headerlink" title="配置 package.json 文件中发布到 npm 的字段"></a>配置 package.json 文件中发布到 npm 的字段</h3><ol><li>name: 包名，该名字是唯一的。可在 npm 官网搜索名字，如果存在则需换个名字。我第一个名的名字叫”zzilccComponent”发布失败了，改成”zzilcc-component”才可以，不知道是不是大写不行</li><li>version: 版本号，每次发布至 npm 需要修改版本号，不能和历史版本号相同。</li><li>description: 描述。</li><li>main: 入口文件，该字段需指向我们最终编译后的包文件。</li><li>keyword：关键字，以空格分离希望用户最终搜索的词。</li><li>author：作者</li><li>private：是否私有，需要修改为 false 才能发布到 npm</li><li>license： 开源协议</li></ol><p>贴上我的配置</p><figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">"name": "zzilcc-ui",</span><br><span class="line">"version": "0.1.4",</span><br><span class="line">"description": "基于 Vue 的简易组件库",</span><br><span class="line">"main": "lib/zzilcc-ui.umd.min.js",</span><br><span class="line">"keyword": "zzilcc-ui vue",</span><br><span class="line">"private": false,</span><br></pre></td></tr></table></figure><h3 id="添加npm发布忽略文件"><a href="#添加npm发布忽略文件" class="headerlink" title="添加npm发布忽略文件"></a>添加npm发布忽略文件</h3><p>我们在zzilcc-ui目录下新建一个.npmignore文件，语法和git的忽略文件是一样的，内容如下<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 忽略目录</span><br><span class="line">examples/</span><br><span class="line">packages/</span><br><span class="line">public/</span><br><span class="line"></span><br><span class="line"># 忽略指定文件</span><br><span class="line">vue.config.js</span><br><span class="line">babel.config.js</span><br><span class="line">*.map</span><br></pre></td></tr></table></figure></p><h3 id="注册npm账号"><a href="#注册npm账号" class="headerlink" title="注册npm账号"></a>注册npm账号</h3><p>去<a href="https://www.npmjs.com/package/npm" target="_blank" rel="noopener">npm官网</a>注册一个账号，然后网站会发一封邮件到你注册的邮箱，点击邮件中的链接，就表示邮箱验证成功。</p><p>然后在zzilcc-ui目录打开命令行输入</p><pre><code>npm login</code></pre><p>该命令会让你输如npm 账号，密码，邮箱，相应的输入你注册的账号，密码输入不会显示，输入完回车就行</p><h3 id="发布你的第一个npm包"><a href="#发布你的第一个npm包" class="headerlink" title="发布你的第一个npm包"></a>发布你的第一个npm包</h3><p>最后我们只要执行发布命令</p><pre><code>npm publish</code></pre><p>成功后，去npm官网上搜索你写的npm name，搜到你相应的包就算成功了。</p><p><img src="/2019/06/12/基于vue-cli3实现自己的组件库且发布到npm（一）环境搭建/npm.png" alt=""></p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>下一篇文章我将会细讲怎么写一个组件，今天只是把环境搭好，有什么疑惑可以到<a href="https://github.com/zzilcc/zzilccComponent/issues" target="_blank" rel="noopener">issues</a>给我提问。要是觉得我写的还行，能帮助到你，也可以给我github项目star一下。</p><p>打赏植发钱</p><p>一入前端发直掉，</p><p>网络一线牵，</p><p>珍惜这段缘。</p><p>感觉要开始存钱植发了。</p><p><img width="100" src="/2019/06/12/基于vue-cli3实现自己的组件库且发布到npm（一）环境搭建/zf.png"></p><p><img width="120" src="/2019/06/12/基于vue-cli3实现自己的组件库且发布到npm（一）环境搭建/wxZf.png"></p>]]></content>
      
      
        <tags>
            
            <tag> vue vue-cli webpack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>半个小时学不会的正则表达式</title>
      <link href="/2019/05/28/%E5%8D%8A%E4%B8%AA%E5%B0%8F%E6%97%B6%E5%AD%A6%E4%B8%8D%E4%BC%9A%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2019/05/28/%E5%8D%8A%E4%B8%AA%E5%B0%8F%E6%97%B6%E5%AD%A6%E4%B8%8D%E4%BC%9A%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="一、-为什么用正则表达式"><a href="#一、-为什么用正则表达式" class="headerlink" title="一、 为什么用正则表达式"></a>一、 为什么用正则表达式</h1><p>我们去学习某个新技能，肯定是因为它有某些实用价值，它能解决某些问题，能提高某些方面效率。</p><p>正则表达式也是如此。</p><p>正则表达式是匹配模式，</p><p>正则表达式能做的事情：</p><ol><li>验证<ul><li>表单验证</li></ul></li><li>切分<ul><li>“2019-05-25这一天，我们去密室逃脱.”切分出日期</li><li>切分出url的参数</li></ul></li><li>提取<ul><li>”2019-05-28“提取出年月日</li></ul></li><li>替换<ul><li>替换空格等</li></ul></li></ol><p>总的来说，正则表达式可以用来匹配字符，也可以匹配位置，可以使我们少写很多行代码。<br><a id="more"></a><br><a href="https://www.jianshu.com/p/e7bb97218946" target="_blank" rel="noopener">知道这20个正则表达式，能让你少写1,000行代码</a></p><blockquote><p>​ “如果罗列计算机软件领域的伟大发明, 我相信绝对不会超过二十项, 在这个名单当中, 当然应该包括分组交换网络, Web, Lisp, 哈希算法, UNIX, 编译技术, 关系模型, 面向对象, XML这些大名鼎鼎的家伙, 而正则表达式也绝对不应该被漏掉.</p></blockquote><p>​ 对很多实际工作而言, 正则表达式简直是灵丹妙药, 能够成百倍的提高开发效率和程序质量, 正则表达式在生物信息学和人类基因图谱的研究中所发挥的关键作用, 更是被传为佳话. CSDN的创始人蒋涛先生在早年开发专业软件产品时, 就曾经体验过这一工具的巨大威力, 并且一直印象深刻.”<br>奔着能少写代码，精简代码，我们开始学习正则表达式</p><h1 id="二、-正则表达式是什么"><a href="#二、-正则表达式是什么" class="headerlink" title="二、 正则表达式是什么"></a>二、 正则表达式是什么</h1><blockquote><p>百度百科： 正则表达式，又称规则表达式。（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。</p></blockquote><p>正则表达式是由普通字符和特殊字符(也叫元字符或限定符)组成。</p><p>然后由’//‘两个斜杠包裹着</p><p>比如我们要匹配’hello’, 可以写/hello/</p><p>  var regex = ‘/hello/‘;<br>  console.log(regex.test(“hello,world!”)) // true</p><p>这是最简单的精确匹配，但是正则表达式能做的不止这些，主要的还是模糊匹配。</p><p>模糊匹配有两种： 横向模糊匹配和纵向模糊匹配。</p><h2 id="横向模糊匹配"><a href="#横向模糊匹配" class="headerlink" title="横向模糊匹配"></a>横向模糊匹配</h2><p>横向模糊是指一个正则匹配的字符串的长度不是固定的，可以是多种情况的。</p><p>譬如： 删除字符串首尾空格（后面会写该正则）</p><p>字符串首尾空格的个数我们是不知道的，所以我们要用到量词{n,m}，代表字符重复次数在n到m次。</p><p>/ab{2,5}c/表示匹配这样的一个字符串，第一个字符是’a‘，然后是2到5个字符’b‘，最后是’c‘</p><pre><code>var reg = /ab{2,5}c/gvar str1 = &quot;abc abbc abbbc abbbbc abbbbbc abbbbbbc&quot;var str2 = &apos;abcabcabbc&apos;console.log(str1.match(reg))console.log(str2.match(reg))</code></pre><h2 id="纵向模糊匹配"><a href="#纵向模糊匹配" class="headerlink" title="纵向模糊匹配"></a>纵向模糊匹配</h2><p>纵向模糊是指一个正则匹配的字符串，具体到某一位字符时，它可以是不确定的字符，可以有多种可能。</p><p>譬如 [0123456789]指可以是0-9其中的一个字符，注意是一个。</p><p>/123[abc]/可以匹配’123a‘，’123b‘，’123c‘</p><pre><code>var reg = /123[abc]/gvar str1 = &quot;123a 123b 123c&quot;console.log(str1.match(reg))</code></pre><h2 id="字符组（字符类）"><a href="#字符组（字符类）" class="headerlink" title="字符组（字符类）"></a>字符组（字符类）</h2><p>可以理解成匹配这一组字符里的其中一个，虽然叫组，但是只是其中一个字符，注意不要混淆。</p><p>我们刚刚举例过的[abc]就是一个字符组，表示’a’,’b’,’c’的其中一个。</p><p>如果字符组里的字符很多，比如所有数字和大小字母，[0123456789abcd…zA….Z]我们可以写成[0-9a-zA-Z]，通过连字符’-‘代表范围。</p><p>那么我们要匹配’a‘,’-‘,’z’呢？</p><p>我们可以写成[az-],[-az],[a-z]。</p><p>然后系统对于一些常见的字符组定义了一些符号去表示：（^表示取反）</p><p>字符组|具体含义<br>|:-:|:-:|<br>|\d|表示[0-9]数字|<br>|\D|表示[^0-9]非数字|<br>|\s|表示空白符，包括空格，水平制表符，垂直制表符，换行符，回车符，换页符|<br>|\S|表示非空白符|<br>|\w|[0-9a-zA-Z_]表示单词字符,包括数字，大小写字母还有下划线|<br>|\W|[^0-9a-zA-Z_]表示非单词字符|<br>|.|通配符，几乎表示任意字符，换行符，回车符，行分隔符，段分隔符除外|</p><p>思考： 怎么匹配任意字符？</p><h2 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h2><p>量词可以理解成重复次数，在正则中用{n,m}表示。</p><p>量词|具体含义<br>|:-:|:-:|<br>|{n,m}|表示出现n到m次|<br>|{n}|表示只能出现n次|<br>|{n,}|表示至少出现n次|<br>|{,m}|表示至多出现m次|<br>|?|等价于{0,1}|<br>|+|等价于{1,}|<br>|*|等价于{0,}|</p><pre><code>var reg = /a{1,8}b{2,}c{4}d?e+h*/gvar str1 = &quot;abbbccccc abbbccccde&quot;console.log(str1.match(reg))    </code></pre><h2 id="贪婪匹配"><a href="#贪婪匹配" class="headerlink" title="贪婪匹配"></a>贪婪匹配</h2><pre><code>var reg = /\w{1,4}/gvar str1 = &quot;a 12a 22 aaaa adkdd 123dff&quot;console.log(str1.match(reg))</code></pre><p>结果我们可以看到是[“a”, “12a”, “22”, “aaaa”, “adkd”, “d”, “123d”, “ff”]，从结果中我们可以看到，结果是尽量去匹配的，给我5个字符，我能要到四个，给我四个，我也能要到四个，给3个，我也要三个。这在正则中叫做贪婪匹配，也就是尽可能的匹配。</p><h2 id="懒惰匹配"><a href="#懒惰匹配" class="headerlink" title="懒惰匹配"></a>懒惰匹配</h2><p>懒惰匹配只需要在量词后面加上’?’</p><ol><li>{n,m}?</li><li>{n}?</li><li>{n,}?</li><li>{,m}?</li><li>??</li><li>+?</li><li>*?</li></ol><pre><code>var reg = /\w{1,4}?/gvar str1 = &quot;a 12a 22 aaaa adkdd 123dff&quot;console.log(str1.match(reg))</code></pre><p>结果为：[“a”, “1”, “2”, “a”, “2”, “2”, “a”, “a”, “a”, “a”, “a”, “d”, “k”, “d”, “d”, “1”, “2”, “3”, “d”, “f”, “f”]</p><h2 id="多选分支"><a href="#多选分支" class="headerlink" title="多选分支"></a>多选分支</h2><p>多选分支的形式:(a|b)</p><p>a，b是子模式，用管道符’|’分隔，表示匹配其一。</p><p>比如要匹配hello或者hi 可以/hello|hi/</p><pre><code>var reg = /hello|hi/gvar str = &apos;hello,girl.hi,boy&apos;console.log(str.match(reg)) // [&quot;hello&quot;, &quot;hi&quot;]</code></pre><p>其实多选分支其实是惰性的，比如我们用/hello|helloworld/去匹配‘helloworld’,结果是</p><pre><code>var reg = /hello|helloworld/gvar str = &apos;helloworld&apos;console.log(str.match(reg)) //hello</code></pre><p>它匹配到了’hello’,就不会继续去匹配’helloworld’ </p><h2 id="正则表达式回溯原理法"><a href="#正则表达式回溯原理法" class="headerlink" title="正则表达式回溯原理法"></a>正则表达式回溯原理法</h2><p>比如正则表达式是/ab{1,3}c/ str=”abbc“</p><p><img src="/2019/05/28/半个小时学不会的正则表达式/回溯.png" alt="回溯"></p><p>可以看到第1步我们匹配’a’，匹配成功了，然后下面到匹配’b{1,3}’,也就是1到3次的b,由于这是贪婪匹配,然后第2，3步正常匹配到了’b’，然后往下一步要找最后一次’b’,但是发现是’c’,所以没有匹配成功，这时候回溯，然后开始匹配’c’，去匹配’c’，匹配成功。</p><p>第5步就是回溯。</p><blockquote><p>回溯法也称试探法，它的基本思想是：从问题的某一种状态（初始状态）出发，搜索从这种状态出发<br>所能达到的所有“状态”，当一条路走到“尽头”的时候（不能再前进），再后退一步或若干步，从<br>另一种可能“状态”出发，继续搜索，直到所有的“路径”（状态）都试探过。这种不断“前进”、<br>不断“回溯”寻找解的方法，就称作“回溯法”。<br>— 百度百科</p></blockquote><p>那么当多个贪婪量词挨着，并互相有冲突，那么会怎么样？</p><p>var string = “12345”;<br>var regex = /(\d{1,3})(\d{1,3})/;<br>console.log( string.match(regex) ); //[“12345”, “123”, “45”, index: 0, input: “12345”]</p><p>我们可以看到是谁先谁‘贪’的更多，因为回溯的本质是深度优先算法，所以会先满足前面的。</p><h2 id="位置匹配"><a href="#位置匹配" class="headerlink" title="位置匹配"></a>位置匹配</h2><blockquote><p>正则表达式是匹配模式，要么匹配字符，要么匹配位置。 -老姚</p></blockquote><p>位置包括</p><ol><li>多行开头’^’</li><li>多行结尾’$’</li><li>单词边界’\b’</li><li>非单词边界’\B’</li><li>(?=p)p是子模式，该正则表达式表示p前面的位置</li><li>(?!p)与(?=p)相反。</li></ol><p>比如我们在字符串的开头和结尾加上‘@’</p><pre><code>var reg = /^|$/gvar str = &apos;hello,world&apos;var result = str.replace(reg,&apos;@&apos;)console.log(result)// @hello,world@</code></pre><p>我们在单词边界加上‘@’</p><pre><code>var reg = /\b/gvar str = &apos;hello,world&apos;var result = str.replace(reg,&apos;@&apos;)console.log(result) //@hello@,@world@</code></pre><p>我们在非单词边界加上‘@’</p><pre><code>var reg = /\B/gvar str = &apos;hello,world&apos;var result = str.replace(reg,&apos;@&apos;)console.log(result) // h@e@l@l@o,w@o@r@l@d</code></pre><p>我们在’l’前面加上‘@’</p><pre><code>var reg = /(?=l)/gvar str = &apos;hello,world&apos;var result = str.replace(reg,&apos;@&apos;)console.log(result) // he@l@lo,wor@ld</code></pre><p>我们在非’l’的前面加上‘@’</p><pre><code>var reg = /(?!l)/gvar str = &apos;hello,world&apos;var result = str.replace(reg,&apos;@&apos;)console.log(result) // h@ell@o@,@w@o@rl@d@</code></pre><h2 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h2><p>括号最大的作用是分组，用来匹配子表达式，</p><p>比如匹配12个月，01-12，我们可以分成两种情况。第一种情况：第一个数字0开头的话，第二个数字可以是1-9，然后第二种情况，第一个数字1开头的话，只有0-2</p><p>所以正则表达式为: /(0[1-9])|(1[0-2])/</p><h3 id="第一次课堂作业"><a href="#第一次课堂作业" class="headerlink" title="第一次课堂作业"></a>第一次课堂作业</h3><ol><li>数字的千位分隔符表示法。比如‘12345678’变成‘12,345,678’</li></ol><p><a href="#第一次课堂作业答案">第一次课堂作业答案</a></p><h3 id="第二次课堂作业"><a href="#第二次课堂作业" class="headerlink" title="第二次课堂作业"></a>第二次课堂作业</h3><ol><li>匹配16进制颜色值</li><li>匹配时间（例如23:22）</li><li>匹配日期（例如2019-06-10）</li></ol><p><a href="#第二次课堂作业答案">第二次课堂作业答案</a></p><h1 id="三、-怎么使用正则表达式"><a href="#三、-怎么使用正则表达式" class="headerlink" title="三、 怎么使用正则表达式"></a>三、 怎么使用正则表达式</h1><h2 id="JavaScript-正则"><a href="#JavaScript-正则" class="headerlink" title="JavaScript 正则"></a>JavaScript 正则</h2><h3 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h3><p>js通过RegExp类型支持正则</p><p>var reg = new RegExp(“[bc]at”, “i”)</p><p>上面代码等价于 var reg = /[bc]at/i</p><p>‘i’（不区分大小写）是正则表达式的标志，还有’g’（全局模式）,’m’(多行模式)</p><p>一个正则表达式可以带多个标志</p><pre><code>/[bc]at/ig</code></pre><p>我们上面所接触到的特殊字符<code>({\^$|?+.})</code>，叫做元字符，我们如果要匹配元字符的话需要进行转义。</p><pre><code>匹配第一个&apos;[bc]at&apos;，不区分大小写var reg = /\[bc\]/i</code></pre><h4 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h4><pre><code>语法  reg.exec(str) 返回值：包含第一个匹配项信息的数组，或者nullvar str = &quot;mom and dad and baby&quot;var reg = new RegExp(&quot;mom( and dad( and baby)?)?&quot;, &quot;gi&quot;)var res = reg.exec(str)console.log(res)// [&quot;mom and dad and baby&quot;, &quot; and dad and baby&quot;, &quot; and baby&quot;, index: 0, input: &quot;mom and dad and baby&quot;, groups: undefined]</code></pre><p>exec返回数组的第一项是匹配的整个字符串，然后第二项是第一个捕获组匹配的内容，第三项是第二个捕获组匹配的内容，然后是index属性，为0是因为整个字符串本身和模式匹配。</p><pre><code>var str = &quot;m  mom and dad and baby&quot;var reg = new RegExp(&quot;mom( and dad( and baby)?)?&quot;, &quot;gi&quot;)var res = reg.exec(str)console.log(res)// [&quot;mom and dad and baby&quot;, &quot; and dad and baby&quot;, &quot; and baby&quot;, index: 2, input: &quot;  mom and dad and baby&quot;, groups: undefined]</code></pre><p>因为是第三个字符匹配，所以index2</p><h4 id="test"><a href="#test" class="headerlink" title="test"></a>test</h4><pre><code>语法 reg.test(str) 返回值为布尔值 true和false</code></pre><p>功能： 判断某个字符串是不是匹配某个正则</p><pre><code>var str = &quot;m  mom and dad and baby&quot;var reg = new RegExp(&quot;mom( and dad( and baby)?)?&quot;, &quot;gi&quot;)var res = reg.test(str)console.log(res) // true</code></pre><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="match-reg"><a href="#match-reg" class="headerlink" title="match(reg)"></a>match(reg)</h4><pre><code>语法str.match(str1)str.match(regexp)返回值和exec函数类似</code></pre><p>match()函数有两种参数，第一种是某个字符串str1，去str匹配有没有str1</p><pre><code>var str = &quot;hello&quot;var str1 = &quot;he&quot;var res = str.match(str1)console.log(res)//[&quot;he&quot;, index: 0, input: &quot;hello&quot;, groups: undefined]</code></pre><p>第二种参数是正则表达式</p><pre><code>var str = &quot;m  mom and dad and baby&quot;var reg = new RegExp(&quot;mom( and dad( and baby)?)?&quot;, &quot;i&quot;)var res =str.match(reg)console.log(res)//[&quot;mom and dad and baby&quot;, &quot; and dad and baby&quot;, &quot; and baby&quot;, index: 3, input: &quot;m  mom and dad and baby&quot;, groups: undefined]</code></pre><h4 id="search"><a href="#search" class="headerlink" title="search"></a>search</h4><pre><code>语法str.search(regexp) 如果匹配成功，会返回匹配成功的位置 ，如果匹配失败，则返回-1var str = &quot;hello,world&quot;var reg = /world/ivar res = str.search(reg)console.log(res)// 6var res1 = str.search(/hi/i)console.log(res1) // -1</code></pre><p>注意： search方法会忽略全局标’g’</p><h4 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h4><p>replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。</p><pre><code>语法 str.replace(regexp/substr,replacement) 返回值为一个新字符串var str = &quot;hello,world&quot;var reg = /he/var res = str.replace(reg,&apos;@&apos;)console.log(res) // @llo,world</code></pre><p>replacement 可以是字符串，也可以是函数。如果它是字符串，那么每个匹配都将由字符串替换。但是 replacement 中的 $ 字符具有特定的含义。</p><h4 id="split"><a href="#split" class="headerlink" title="split"></a>split</h4><p><a name="第一次课堂作业答案">第一次课堂作业答案</a></p><ol><li>/(?=(\d{3})+$)/g</li></ol><p><a name="第二次课堂作业答案">第二次课堂作业答案</a></p><ol><li>匹配16进制 /#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})/g</li><li>匹配时间 /([01][0-9]|[2][0-3]):[0-5][0-9]/g</li><li>匹配日期 /[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])/g</li></ol>]]></content>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>js原型和原型链</title>
      <link href="/2019/04/30/js%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>/2019/04/30/js%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      <content type="html"><![CDATA[<h2 id="prtotype和proto"><a href="#prtotype和proto" class="headerlink" title="prtotype和proto"></a>prtotype和<strong>proto</strong></h2><p>说到原型，我们必须要了解prototype和<strong>proto</strong>,这两个很多人可能总是会分不清，接下来我会尽可能以通俗易懂的语言去解释这两者的不同。</p><p>我们看到的大多数引用类型值：函数，数组，对象都是Object的实例，所以Object可以说是一个基本。</p><p>我们去创建一个Object的实例，有两种方法，一种是通过new</p><p>例如：</p><pre><code>var obj = new Object()</code></pre><p>还有一种通过对象字面量</p><pre><code>var obj = {}  </code></pre><p>每个构造函数都有一个原型对象，通过prototype去访问，比如Object.prototype,然后这个原型对象包含一个constructor属性，指向构造函数，也就是Object.prototype.constructor === Object，还包含了一些内置函数，或者自定义的函数。</p><p>然后实例化这个构造函数，得到的实例，有一个<strong>proto</strong>属性指向构造函数的原型对象。</p><p>下面是Object的一个例子。</p><p><img src="/2019/04/30/js原型和原型链/Object的原型.jpg" alt=""></p><p>所以我们可以看到obj.<strong>proto</strong>=== Object.prototype</p><p>总结：</p><ol><li>每个函数都有prototype指向原型对象</li><li>每个对象都有<strong>protot</strong>指向构造函数的原型对象</li></ol><p>在js中，函数是一种特殊的对象，所以函数也有<strong>proto</strong></p>]]></content>
      
      
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>this和常用css</title>
      <link href="/2019/04/26/this%E5%92%8C%E5%B8%B8%E7%94%A8css/"/>
      <url>/2019/04/26/this%E5%92%8C%E5%B8%B8%E7%94%A8css/</url>
      <content type="html"><![CDATA[<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><h3 id="第一段代码"><a href="#第一段代码" class="headerlink" title="第一段代码"></a>第一段代码</h3><pre><code>var count = 1;function a () {    this.count ++    console.log(this.count)}a.count = 0;a()console.log(a.count)</code></pre><p>谣言： this指向自身</p><h3 id="第二段代码"><a href="#第二段代码" class="headerlink" title="第二段代码"></a>第二段代码</h3><p>重要的事情说三遍</p><p>this永远指向最后调用它的对象</p><p>this永远指向最后调用它的对象</p><p>this永远指向最后调用它的对象<br><a id="more"></a></p><pre><code>var name = &apos;windowName&apos;;function a () {    var name = &apos;aName&apos;;    console.log(&apos;a: &apos; + this.name)}a()console.log(&apos;window: &apos; + this.name)</code></pre><p>输出？</p><p>两个都是输出windowName，因为a函数在全局对象里调用的，所以this指向的是window，所以第一个代码a函数里this.count++,这个count是全局的coount，也就是window.count,a.count不会变,所以输出的是2，0。然后第二段代码两个输出都是windowName</p><h3 id="第三段代码"><a href="#第三段代码" class="headerlink" title="第三段代码"></a>第三段代码</h3><pre><code>var name = &apos;windowName&apos;;function a () {    var name = &apos;aName&apos;;    console.log(&apos;a: &apos; + this.name);}var obj = {    name: &apos;objName&apos;,    fn: a}obj.fn()</code></pre><p>输出？</p><p>因为最后调用this的对象是obj，所以this指向obj，this.name指的是obj.name</p><h3 id="第四段代码"><a href="#第四段代码" class="headerlink" title="第四段代码"></a>第四段代码</h3><pre><code>var name = &apos;windowName&apos;;function a () {    var name = &apos;aName&apos;;    console.log(&apos;a: &apos; + this.name);    function b() {        console.log(&apos;b: &apos; + this.name)     }     b();}a()console.log(&apos;window: &apos; + this.name)</code></pre><p>输出？</p><p>在js里，函数是一种特殊的对象，只要函数里没有被正常对象包裹着，函数调用this都是指向window。</p><p>所以这里输出都是windowName</p><h3 id="第五段代码"><a href="#第五段代码" class="headerlink" title="第五段代码"></a>第五段代码</h3><pre><code>var name = &apos;windowName&apos;;function a () {    var name = &apos;aName&apos;;    console.log(&apos;a: &apos; + this.name);}var obj = {    name: &apos;objName&apos;,    fn: a}var foo =  obj.fn foo()</code></pre><p>这里我们变形一下第三段代码，将obj.fn赋值给一个变量foo，然后再运行foo，这样会输出什么？</p><p>很神奇，这里会输出的是‘windowName’,而不是‘objName’，这是因为把obj.fn赋值给foo时，是相当于foo指向了fn函数，然后foo时再全局执行的，所以相当于window.foo,所以this指向是window，所以输出的是‘windowName’。</p><h3 id="第六段代码"><a href="#第六段代码" class="headerlink" title="第六段代码"></a>第六段代码</h3><pre><code>var name = &apos;windowName&apos;;setTimeout(function(){    var name = &apos;setTimeout_name&apos;    console.log(this.name)},1000)</code></pre><p>我们之前说过setTimeout是window的方法，setTimeout的回调函数是在window里执行的，所以setTimeout回调函数里的this指向的是window。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>this永远指向最后调用它的对象</p><p>this永远指向最后调用它的对象</p><p>this永远指向最后调用它的对象</p><h2 id="改变this指向"><a href="#改变this指向" class="headerlink" title="改变this指向"></a>改变this指向</h2><ol><li>使用es6的箭头函数</li><li>在函数内部使用_this = this</li><li>使用apply，call，bind</li><li>new实例话一个对象。 </li></ol><h3 id="es6的箭头函数"><a href="#es6的箭头函数" class="headerlink" title="es6的箭头函数"></a>es6的箭头函数</h3><p>es6的箭头函数的this始终指向的是函数定义时的this，而非执行时。</p><pre><code>var name = &apos;windowName&apos;;var obj = {    name: &apos;objName&apos;,    fn: function() {        setTimeout(()=&gt;{            console.log(this.name)        },0)    }}obj.fn()</code></pre><h3 id="this-that-self"><a href="#this-that-self" class="headerlink" title="_this,that,self"></a>_this,that,self</h3><p>这种方法最常见了，用一个变量_this,that,self保存一下调用这个函数的对象，然后在函数里用这个变量</p><pre><code>var name = &apos;windowName&apos;;var obj = {    name: &apos;objName&apos;,    fn: function() {        var _this = this;        setTimeout(function(){            console.log(_this.name)        },0)    }}obj.fn()</code></pre><h3 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call,apply,bind"></a>call,apply,bind</h3><pre><code>var name = &apos;window_name&apos;var a = {    name: &apos;a_name&apos;,    fn: function(age){        console.log(this.name);    }}var b = {    name: &apos;b_name&apos;,    fn1: function(){        console.log(this.name);    }}a.fn.apply(b)b.fn1.apply(a)b.fn1.apply(this)a.fn.call(b)b.fn1.call(a)b.fn1.call(this)a.fn.bind(b)()b.fn1.bind(a)()b.fn1.bind(this)()</code></pre><p>apply 语法 fun.apply(thisArg, [argsArr])</p><ul><li>thisArg fun函数运行时指定的this值</li><li>argsArr 一个数组或者类数组对象。</li></ul><p>call 语法 fun.call(thisArgs, arg1, arg2…)</p><p>apply和call的区别是call是接受多个参数，apply接受一个参数数组</p><pre><code>var a = {    name: &apos;a_name&apos;,    fn: function(age, sex){        debugger        var age = age;var sex = sex;        console.log(this.name);    }}var b = {    name: &apos;b_name&apos;,    fn1: function(age, sex){        debugger        console.log(this.name);    }}a.fn.apply(b,[ 11, &apos;man&apos;])b.fn1.call(b,  11, &apos;man&apos;)</code></pre><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>我们经常说没有对象，new一个就行。这里的new将this指向</p><pre><code>var Person (name) {    this.name = name}new Person(&apos;zzilcc&apos;)</code></pre><p>new 做了什么，下面解释一下</p><ol><li>创建了一个空对象obj</li><li>把obj的_proto_z指向Person的原型对象prototype，此时便建立了obj对象的原型链obj-&gt;Person.prototype-&gt;Object.prototype-&gt;null</li><li>在obj的执行环境调用Person的方法，也就是Person.call(obj,’zzilcc’),然后执行obj.name = ‘zzilcc’</li><li>将obj当作返回值返回</li></ol><p>所以我们用一个变量去接受下这个obj</p><pre><code>var person1 = new Person(&apos;zzilcc&apos;)person1.name === &apos;zzilcc&apos; // true</code></pre><h2 id="常用css属性"><a href="#常用css属性" class="headerlink" title="常用css属性"></a>常用css属性</h2><ol><li><p>css背景属性</p><ul><li>background: #fff url() center 100% no-repeat<ul><li>background-color</li><li>background-image</li><li>background-position</li><li>background-size</li><li>background-repeat</li></ul></li></ul></li><li><p>css边框属性</p><ul><li>border<ul><li>border-color</li><li>border-width</li><li>border-style</li></ul></li><li>border-top: 1px solid #fff<ul><li>border-top-color: #fff</li><li>border-top-width: 1px</li><li>border-top-style: solid(实线)/dotted(点状)/dashed(虚线)</li></ul></li><li>border-right<ul><li>border-right-color</li><li>border-right-width</li><li>border-right-style</li></ul></li><li>border-bottom<ul><li>border-bottom-color</li><li>border-bottom-width</li><li>border-bottom-style</li></ul></li><li>border-left<ul><li>border-left-color</li><li>border-left-width</li><li>border-left-style</li></ul></li></ul></li><li><p>css尺寸属性</p><ul><li>height</li><li>max-height</li><li>min-height</li><li>width</li><li>min-width</li><li>max-width</li></ul></li><li><p>css字体属性</p><ul><li>font<ul><li>font-size</li><li>font-family</li><li>font-style</li><li>font-weight</li></ul></li></ul></li><li><p>css外边距属性</p><ul><li>margin<ul><li>margin-top</li><li>margin-right</li><li>margin-bottom</li><li>margin-left</li></ul></li></ul></li><li><p>css内边距属性</p><ul><li>padding<ul><li>padding-top</li><li>padding-right</li><li>padding-bottom</li><li>padding-left</li></ul></li></ul></li><li><p>css定位属性</p><ul><li>position</li><li>top</li><li>right</li><li>bottom</li><li>left</li><li>overflow</li><li>float</li><li>display</li><li>z-index</li><li>vertical-align</li><li>cursor: default|pointer</li></ul></li><li><p>css文本属性</p><ul><li>color: #fff; // 颜色</li><li>line-height:40px; //行高 </li><li>text-align: left|center|right// 规定文本的水平对齐方式</li><li>text-indent: 2px|1% // 属性规定文本块中首行文本的缩进。</li><li>white-space:nowrap //     文本不会换行，文本会在在同一行上继续，直到遇到 <br> 标签为止</li><li>text-overflow:ellipsis // 规定当文本溢出包含元素时发生的事情。</li><li>word-break: normal|break-all|keep-all;// 规定非中日韩文本的换行规则。</li><li>word-wrap: normal|break-word // 单词分割且换行</li></ul></li></ol><h2 id="常用css解决某些问题"><a href="#常用css解决某些问题" class="headerlink" title="常用css解决某些问题"></a>常用css解决某些问题</h2><ol><li>css画各种形状</li></ol><h3 id="圆形"><a href="#圆形" class="headerlink" title="圆形"></a>圆形</h3><pre><code>div {    width: 100px;    height: 100px;    background: red;    border-radius: 50%;}&lt;div&gt;&lt;/div&gt;</code></pre><h3 id="三角形"><a href="#三角形" class="headerlink" title="三角形"></a>三角形</h3><pre><code>div {      width: 0;      border-left: 50px solid transparent;      border-right: 50px solid transparent;      border-bottom: 100px solid red;}</code></pre><ol start="2"><li><p>省略号</p><h3 id="省略号"><a href="#省略号" class="headerlink" title="省略号"></a>省略号</h3><pre><code>max-width: 100px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap</code></pre></li></ol><h2 id="绑定数据"><a href="#绑定数据" class="headerlink" title="绑定数据"></a>绑定数据</h2><h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><p>git reflog &amp;&amp; git reset –hard ‘哈希数’</p><p>遇到一些奇怪的现象时我们可以用git reflog 找到我们最新的一次commit时的哈希数。</p><p>然后灭霸一个响指可以消灭一半的‘人’</p><p>我们git reset –hard ‘哈希数’则能让我们回到刚刚commit完的时候，仿佛之前进行了一切操作犹如云烟飘散。</p>]]></content>
      
      
        <tags>
            
            <tag> this | css </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>js作用域和闭包</title>
      <link href="/2019/04/15/js%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/"/>
      <url>/2019/04/15/js%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/</url>
      <content type="html"><![CDATA[<h2 id="一、js引擎执行过程"><a href="#一、js引擎执行过程" class="headerlink" title="一、js引擎执行过程"></a>一、js引擎执行过程</h2><pre><code>var a;console.log(a);console.log(b);</code></pre><p>输出？</p><pre><code>a = 2;var a;console.log(a);</code></pre><p>输出？</p><pre><code>console.log(a);var a = 2;</code></pre><p>输出？</p><p>我们之前说过js代码是由上到下去执行的，但是上面代码的输出结果好像显示的不是这样，其实不是的，js代码确实是由上到下去执行的，只是执行的不是我们直接写的代码，而是我们代码通过编译后生成的代码。</p><p>我们可以将js引擎执行过程分为三个阶段，分别是语法分析，预编译和解释执行阶段。<br><a id="more"></a></p><h2 id="（1）语法分析"><a href="#（1）语法分析" class="headerlink" title="（1）语法分析"></a>（1）语法分析</h2><p>语法分析主要是对代码进行语法检查，如果语法有错，会抛出错误，如果没有错，则进入预编译阶段，</p><h2 id="（2）预编译"><a href="#（2）预编译" class="headerlink" title="（2）预编译"></a>（2）预编译</h2><p>我们可以将预编译分成四个步骤</p><ol><li>创建GO（全局）/ AO（活动）对象</li><li>找形参和变量声明，将变量和形参名作为GO/AO属性名，值为undefined</li><li>将实参和形参统一</li><li>在函数体里找函数声明，值赋予函数体</li></ol><h3 id="函数声明和函数表达式的区别"><a href="#函数声明和函数表达式的区别" class="headerlink" title="函数声明和函数表达式的区别"></a>函数声明和函数表达式的区别</h3><p>主要看第一个词是不是function,第一个词是function为函数声明，其他的都是函数表达式</p><pre><code>function () {} // 函数声明var a = function () {} // 函数表达式</code></pre><p>示例： （代码已经过语法检查，没有语法错误）</p><pre><code>function a () {    var b =10;    function c () {        var b =123;        console.log(b);        function d (){}    }    console.log(b);    console.log(c);}var b =123;a();</code></pre><ol><li><p>一进来默认的是全局对象GO，在此是window对象</p></li><li><p>找变量声明b，将其作为window的属性，值为undefined </p></li><li><p>找函数声明，发现a函数, 将其作为window属性，值为a函数的函数体</p></li></ol><p>此时Go对象为： </p><pre><code>GO = {    b: undefined,    a: function () {        var b =10;        function c () {            var b =123;            console.log(b);            function d (){}        }        console.log(b);        console.log(c);    }}</code></pre><p>所以此时代码可以理解成 </p><pre><code>var b;var a = function(){    // a的函数体};b = 123;a();</code></pre><h2 id="（3）解释执行"><a href="#（3）解释执行" class="headerlink" title="（3）解释执行"></a>（3）解释执行</h2><p>此时引擎开始执行代码</p><p>把123赋值给b，运行a，运行a之前也会进行预编译。</p><pre><code>function a () {    var b =10;    function c () {        var b =123;        console.log(b);        function d (){}    }    console.log(b);    console.log(c);}</code></pre><ol><li>新建一个AO对象</li><li>查找变量声明，发现b,给AO对象添加一个属性b，值为undefined</li><li>查找函数声明，发现c函数，给AO对象添加一个属性c，值为c函数体</li></ol><p>AO对象</p><pre><code>AO = {    b: undefined,    c: function () {        var b =123;        console.log(b);        function d (){}    }}</code></pre><p>此时代码可以理解成</p><pre><code>function a () {    var b;    function c () {        var b =123;        console.log(b);        function d (){}    }    b = 10;    console.log(b);    console.log(c);}</code></pre><p>然后开始执行a函数</p><h2 id="变量和函数提升的一些注意事项"><a href="#变量和函数提升的一些注意事项" class="headerlink" title="变量和函数提升的一些注意事项"></a>变量和函数提升的一些注意事项</h2><p>重名的声明后一个会覆盖前一个</p><pre><code>function foo () {    console.log(a)}function foo () {    console.log(b)}console.log(foo)</code></pre><p>如果函数声明和变量声明重名了，函数声明会优先</p><pre><code>function foo () {}var foo;console.log(foo)</code></pre><h2 id="二、js作用域"><a href="#二、js作用域" class="headerlink" title="二、js作用域"></a>二、js作用域</h2><h3 id="作用域是什么？"><a href="#作用域是什么？" class="headerlink" title="作用域是什么？"></a>作用域是什么？</h3><p>作用域是根据名称查找变量一套规则。可以把作用域假设成一个管家。</p><h3 id="作用域的类型"><a href="#作用域的类型" class="headerlink" title="作用域的类型"></a>作用域的类型</h3><p>作用域可以分为全局作用域和局部作用域。</p><p>在执行<code>&lt;script&gt;&lt;/script&gt;</code>块或者js文件时，会生成一个全局作用域和一个window对象，在全局作用域里定义的变量和函数会变成window对象的属性。</p><p>局部作用域包括函数作用域和块级作用域</p><p>每次声明一个函数，就会生成一个函数作用域。</p><p>块级作用域： </p><pre><code>1. with（不推荐）2. try/catch catch会创建一个块级作用域3. let</code></pre><p>注意： 作用域可以嵌套，但是不能重叠。</p><pre><code>var a = 1;function get2 () {    var a = 2;    console.log(&apos;get2 a: &apos;+ a);    function get3 () {        console.log(&apos;get3 a: &apos; + a);    }    get3();    console.log(&apos;get3.prototype: &apos;);    console.log(get3.prototype);}function set2 () {}console.log(&apos;get2.prototype: &apos;);console.log(get2.prototype);get2();</code></pre><p>输出结果</p><p><img src="/2019/04/15/js作用域和闭包/作用域1.png" alt=""></p><p>可以看到我们在全局声明了一个函数叫get2，产生了一个函数作用域，这个作用域是被全局作用域包裹着，然后在get2函数里我们也声明了一个get3函数，也产生了一个函数作用域，这个作用域是被get2的作用域包裹着，所以是一层套一层。</p><p><img src="/2019/04/15/js作用域和闭包/作用域嵌套.jpg" alt=""></p><p>###执行环境和作用域</p><p>执行环境是js中很重要的一个概念，他包括三部分： 变量对象（AO），作用域链，this。</p><p>执行环境有三个类型</p><pre><code>1. 全局执行环境 （js默认执行环境，在web浏览器的话是window对象）2. 函数执行环境 （每个函数自己的执行环境）3. eval执行环境</code></pre><p><img src="/2019/04/15/js作用域和闭包/eventLoop.png" alt=""></p><p>每个执行环境都有一个变量对象，环境中定义的函数和变量都保存在这个对象中。</p><pre><code>var c = 1;function a () {    console.log(c)    return function b () {        console.log(c)    }}a()let aa = a()aa()</code></pre><p>当执行到一个函数a时，该函数a的执行环境会被推进一个执行栈，函数a里调用了其他函数b的话，会将调用的函数b的执行环境推进栈，然后执行完b函数的代码后，b执行环境被推出栈，然后继续执行a函数的代码，a执行完后，把a的执行环境推出栈，以此类推。</p><p>被推出栈的执行环境会被销毁，保存在其中的所有变量和函数定义也会被销毁，全局执行环境在页面关闭或者浏览器关闭时被销毁。</p><p><img src="/2019/04/15/js作用域和闭包/执行栈.jpg" alt=""></p><pre><code>function aa () {    for(var a = 0; a &lt; 5; a++){        console.log(a)    }}console.log(a)for(var b = 0; b &lt; 5; b++){    console.log(b)}console.log(b)</code></pre><p>在函数外部是不能访问到函数内部定义的变量，所以第一个输出a会报错。然后b会输出5，因为js没有块级作用域，所以声明的b是被当作window的属性的，所以可以访问到。</p><p><img src="/2019/04/15/js作用域和闭包/作用域链.jpg" alt=""></p><p>当代码在一个环境执行的时候会创建变量对象的一个作用域链，全局执行环境的变量对象始终都是作用域链的最后一个。</p><p>很明显，a函数有自己的作用域，然后a函数又是在全局定义的，所以被包裹在全局作用域里，所以a的作用域链是自身作用域-全局作用域，在a中查找一个变量是，会在自身作用域查找（也就是找自身的变量对象里有没有这个属性），如果没有查找到就沿着作用域链上去找，找他的上一级作用域链，在这里是全局作用域。</p><p>我们之前说过作用域根据名称查找变量一套规则，可以把作用域理解成管家。</p><p>全局执行环境是一个酒店，函数执行环境是一个房间。</p><p>全局作用域是总管家，a函数作用域是a管家，依次类推。</p><p>我们以下面例子来说：</p><pre><code>var c = 1;function a () {    console.log(c)    return function b () {        console.log(c)    }}a()let aa = a()aa()</code></pre><p>js引擎执行代码，从上到下执行，执行到a函数时发现<code>console.log(a)</code>，这时候引擎和作用域的对话如下：</p><p><img src="/2019/04/15/js作用域和闭包/js引擎与作用域聊天.jpeg" alt=""></p><p>b函数里<code>console.log(c)</code>里查找c以此类推，一层层找。如果在某个作用域里找到了，就不会继续找了，只会返回当前找到的值。</p><p>作用域链是单向的，只能从内到外，外面的执行环境是访问不到函数内部的变量。</p><h2 id="三、闭包"><a href="#三、闭包" class="headerlink" title="三、闭包"></a>三、闭包</h2><pre><code>function foo () {    var a = 2;    function bar () {        console.log(a)    }    return bar;}var f = foo();f();</code></pre><p>我们来执行一下这段代码，</p><p>首先是语法检查，看有没有语法错误，没有，下一步</p><p>创建了全局对象GO，然后进行声明查找，先找变量声明，发现var a = foo();然后声明了一个a，作为GO的属性，值为undefined，然后查找函数声明，发现function foo，然后声明了一个函数foo作为GO的属性，值为foo的函数体。</p><p>然后开始解释执行代码，从上至下，首先将全局执行环境推进栈。</p><p>然后var f = foo() 执行foo函数。</p><p>将foo函数执行环境推进执行栈，然后进行第1-第2步，然后开始执行foo预编译后的代码，给a赋值为2，然后返回了一个函数bar。</p><p>将foo返回的bar赋值给f。这时候foo函数执行完，按照之前我们说的，函数执行完对应函数执行环境栈会被推出执行栈，但是这里没有，这就是闭包的神奇之处。</p><p>f()执行f函数，也就是foo里的bar函数。</p><p>在foo()执行之后，为什么内部作用域还在，没有被回收，是因为有‘人’在使用这个作用域，也就是f()，因为他保持着对foo作用域的引用，所以这个作用域没有被回收，这个引用就是闭包。</p><pre><code>var fn;function foo () {    var a = 2;    function baz () {        console.log(a);    }    fn = baz;}function bb () {    fn();}foo();bb();</code></pre><p>也就是，将函数里的内部函数传递到他定义时所在定义域A之前，这个函数都会保留着对原始定义域A的引用，无论在何时调用这个内部函数都会使用闭包。</p><pre><code>function sleep (message) {    setTimeout(function(){        console.log(message)    }, message)}sleep(&apos;hello&apos;);</code></pre><p>这里也体现了闭包，我们可以先把代码再分解一下。</p><pre><code>function sleep (message) {    function a () {        console.log(message)    }    setTimeout(a, 1000)}sleep(&apos;hello&apos;);</code></pre><p>我们在sleep函数里定义里一个函数a，然后将这个函数a当作参数传给了setTimeout函数，然后执行sleep函数，设置了一个定时器，此时sleep运行完了，理论上他的执行环境要被弹出执行栈，但是因为1秒后这个setTimeout函数时在全局执行环境里去执行的，也就是不是在sleep函数里执行，所以a函数当作参数执行时会保留着对sleep作用域的引用，所以此时输出message是‘hello’。</p><p>这就是闭包的神奇之处。</p><pre><code>for (var i = 0; i &lt; 5; i++) {    setTimeout(function(){        console.log(i)    }, i * 1000)}</code></pre><p>上篇博客说这个程序是隔秒输出5，那么我们想要隔秒输出0，1，2，3，4呢？</p><p>这时候我们就可以利用函数作用域了，我们可以在for循环里定义一个函数，然后将每次循环的i传进函数里，函数里用一个变量存储，这样就能保存每次的i的值。</p><pre><code>for (var i = 0; i &lt; 5; i++) {    function aa(){        var j = i;        setTimeout(function(){            console.log(j)        }, j * 1000)    }    aa(i)}</code></pre><p>然后我们再优化一下这个函数，</p><pre><code>for (var i = 0; i &lt; 5; i++) {    function aa(j){        setTimeout(function(){            console.log(j)        }, j * 1000)    }    aa(i)}</code></pre><p>在aa函数的形参里接收i的值。</p><p>然后我们再可以优化一下</p><pre><code>for (var i = 0; i &lt; 5; i++) {    (function(j){        setTimeout(function(){            console.log(j)        }, j * 1000)    })(i)}</code></pre><p>在这里我们定义了一个匿名函数，然后立即执行了它。</p><p>上面的立即执行函数还有一种写法，把(i)放到（）里</p><pre><code>for (var i = 0; i &lt; 5; i++) {    (function(j){        setTimeout(function(){            console.log(j)        }, j * 1000)    }(i))}</code></pre><p>一个函数怎么执行，一般是函数名+(),比如前面的aa(),然后我们要怎么让一个匿名函数执行呢，匿名函数没有函数名，其实只要把匿名函数的函数声明转换成一个函数表达式然后再加()就可以。</p><p>那么问题就变成了怎么把函数声明变成函数表达式</p><p>上面代码里用一对括号把函数括起来是其中一种方法，在函数前加上一元操作符<code>+</code>,<code>-</code>,<code>!</code>也可以将函数声明转换成表达式。</p><pre><code>-function    (j) {    console.log(j)}(1)+function    (j) {    console.log(j)}(1)!function    (j) {    console.log(j)}(1)</code></pre><p>但是不推荐用<code>+,-,!</code>，因为如果函数有返回值的话，<code>+,-,!</code>会和返回值进行操作。</p><pre><code>var result = -function    (j) {    return j}(1) // result: -1</code></pre>]]></content>
      
      
        <tags>
            
            <tag> js作用域 闭包 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript运行机制</title>
      <link href="/2019/04/12/JavaScript%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/04/12/JavaScript%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h2 id="0-1-前言"><a href="#0-1-前言" class="headerlink" title="0.1. 前言"></a>0.1. 前言</h2><h3 id="0-1-1-ES5，ES6和JavaScript的关系"><a href="#0-1-1-ES5，ES6和JavaScript的关系" class="headerlink" title="0.1.1. ES5，ES6和JavaScript的关系"></a>0.1.1. ES5，ES6和JavaScript的关系</h3><p>众所周知，JavaScript是一位网景公司的奇人布兰登艾奇花了十天就开发出来的。一开始JavaScript叫LiveScript，当时Java特别火，为了蹭个热度，网景公司将其改名成了JavaScript。</p><p>微软在IE3的时候加入了JavaScript的实现，为了避免纠纷，命名为JScript。还有其他公司自己研发了JavaScript，所以这样兼容性就称为一个很头疼的事情，所以业内人士强烈呼吁定制一个标准。</p><p>1996年，网景公司将JavaScript提交给国际标准化组织ECMA，次年，该组织发布了浏览器脚本语言的标准，并将这种语言称为ECMAScript，也就是我们常说的ES。所以ES是一种标准，JavaScript是ES的实现。</p><p>ES5是指ECMAScript5.0，ECMAScript5.1版本，ES6是泛指，指5.1版本以后的JavaScript的下一代标准。</p><a id="more"></a><h2 id="0-2-编译性语言-vs-解释性语言"><a href="#0-2-编译性语言-vs-解释性语言" class="headerlink" title="0.2. 编译性语言 vs 解释性语言"></a>0.2. 编译性语言 vs 解释性语言</h2><p>高级语言要经过翻译，称为机器语言，然后才能被计算机识别。</p><p>翻译分为编译和解释。</p><p>编译性语言在程序运行前有一个专门的编译过程，把程序编译成计算机可执行的文件，比如.exe,以后要运行的话就不用在编译了，直接执行就可以了。Java就是比较典型的编译性语言。Java有一句很有名的口号：一次编译，到处运行。</p><p>解释性语言也是要转换成计算机能识别的语言，只是它是在代码运行时执行，所以需要将解释器安装在环境中。</p><p>JavaScript，python是解释性语言。</p><p>需要注意的一点是解释性语言不是说没有编译，它们有的会有编译特性，即时编译的。</p><h2 id="0-3-浏览器内核"><a href="#0-3-浏览器内核" class="headerlink" title="0.3. 浏览器内核"></a>0.3. 浏览器内核</h2><p>浏览器内核指的是浏览器运行的最核心的程序，分为两个部分，JS引擎和渲染引擎。</p><p><img src="/2019/04/12/JavaScript运行机制/浏览器内核.jpg" alt=""></p><p><img src="/2019/04/12/JavaScript运行机制/js引擎.jpg" alt=""></p><p>JavaScript引擎的主要作用是，读取网页中的JavaScript代码，对其处理后运行。</p><h2 id="0-4-引子"><a href="#0-4-引子" class="headerlink" title="0.4. 引子"></a>0.4. 引子</h2><pre><code>console.log(0)setTimeout(function(){    console.log(1)},0)console.log(2)</code></pre><p>输出结果是什么？</p><h2 id="0-5-单线程"><a href="#0-5-单线程" class="headerlink" title="0.5. 单线程"></a>0.5. 单线程</h2><p>单线程说明在同一个时间里只能做一件事情，有人会说js为什么是单线程，不能多线程，多线程效率不更高吗。原因是js主要用来做页面交互，操作DOM。如果是多线程的话，有可能会发生两个线程同时对一个DOM进行操作，比如一个是添加了一个节点，一个是删除节点，那么浏览器怎么去执行？所以为了避免复杂性，js就是单线程的。</p><h2 id="0-6-事件循环机制"><a href="#0-6-事件循环机制" class="headerlink" title="0.6. 事件循环机制"></a>0.6. 事件循环机制</h2><p>事件循环机制分为浏览器和node事件循环机制，在此主要介绍浏览器事件循环机制。</p><p><img src="/2019/04/12/JavaScript运行机制/eventLoop.png" alt=""></p><p>在js中任务分为两种，同步任务和异步任务。</p><p>所谓同步就是函数或方法执行时要接收到返回的值或者消息才会往下执行，相当于打电话，你说一句，我说一句，一句接一句。</p><p>异步则是函数或方法执行时，不需要等待收到返回的信息和值，直接向系统委托一个异步过程，系统接收到返回结果时，系统会触发委托的异步过程，从而完成一个完整的流程。</p><p>一般异步任务有：</p><ol><li>setTimeout和setlnterval</li><li>DOM事件</li><li>ES6中的Promise</li><li>Ajax异步请求</li></ol><p>事件循环机制的流程是这样的：</p><ol><li>主流程上有一个执行栈，同步任务依次进栈排队，任务从栈的顶部开始执行，执行完的任务会被弹出去。</li><li>异步任务有了结果的时候，会在任务队列里放入‘回调’事件。</li><li>执行栈里所有的同步任务运行完后，会去任务队列里查看，是否还有任务，如果有的话就会将任务读进执行栈中，开始执行。</li><li>主线程不断重复以上3个行为。</li></ol><p>因为这个过程是循环不断的，所以称为事件循环机制。</p><h3 id="0-6-1-练习题-写出以下输出结果"><a href="#0-6-1-练习题-写出以下输出结果" class="headerlink" title="0.6.1. 练习题 写出以下输出结果"></a>0.6.1. 练习题 写出以下输出结果</h3><p>练习题1</p><pre><code>console.log(&apos;a&apos;)while(true){}console.log(&apos;b&apos;)</code></pre><p>练习题2</p><pre><code>console.log(&apos;1&apos;)setTimeout(function(){     console.log(&apos;2&apos;) },0)while(true){}</code></pre><p>练习题3</p><pre><code>for(var i = 0; i &lt; 5; i++) {    setTimeout(function(){        console.log(i)    },1000)} </code></pre><p>练习题4</p><pre><code>for(var i = 0; i &lt; 5; i++) {    setTimeout(function(){        console.log(i)    },1000 * i)} </code></pre><p>作业</p><p>怎么依次隔秒输出0，1，2，3，4</p><h2 id="0-7-css常见布局"><a href="#0-7-css常见布局" class="headerlink" title="0.7. css常见布局"></a>0.7. css常见布局</h2><h3 id="0-7-1-上定高，中间分左右，左定宽，右自适应"><a href="#0-7-1-上定高，中间分左右，左定宽，右自适应" class="headerlink" title="0.7.1. 上定高，中间分左右，左定宽，右自适应"></a>0.7.1. 上定高，中间分左右，左定宽，右自适应</h3><h3 id="0-7-2-div垂直水平居中"><a href="#0-7-2-div垂直水平居中" class="headerlink" title="0.7.2. div垂直水平居中"></a>0.7.2. div垂直水平居中</h3><ol><li><p>行内元素居中 缺点： 会继承，影响到后代行内内容，子元素大于父元素宽度时无效</p><p> text-align: center</p></li><li><p>单个块级元素 必须定宽，且元素宽度要小于父元素宽度</p><p> width: 100px // 定宽<br> margin: 0 auto</p></li><li><p>多个块级元素</p><p> <code>#parant</code> { text-aligin: center}</p><p> <code>#son</code> {display: inline-block}</p></li><li><p>使用绝对定位 （子元素定宽定高）</p><p> <code>#parant</code> { </p><pre><code>position: relativewidth: 100px</code></pre><p> }</p><p> <code>#son</code> {</p><pre><code>position: absoluteleft: 50%width： 100pxheight：100pxmargin-left: -50px // 或者translateX(-50%)margin-top：-50px; // translateY(-50%)</code></pre><p> }</p></li></ol>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>D3.js画3D方柱</title>
      <link href="/2019/03/28/D3.js%E7%94%BB3D%E6%96%B9%E6%9F%B1/"/>
      <url>/2019/03/28/D3.js%E7%94%BB3D%E6%96%B9%E6%9F%B1/</url>
      <content type="html"><![CDATA[<h2 id="D3-js入门实例-3D方柱"><a href="#D3-js入门实例-3D方柱" class="headerlink" title="D3.js入门实例-3D方柱"></a>D3.js入门实例-3D方柱</h2><p>最近由于项目需要去实现3D可视化，所以学了一下D3.js。使用版本是v4.x。<br><a id="more"></a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们先定义下要引用的参数</p><pre><code>let param = {    data: [        {            xName: &apos;1月&apos;，            value: &apos;0.01&apos;        },        {            xName: &apos;2月&apos;，            value: &apos;0.1&apos;        },        {            xName: &apos;3月&apos;，            value: &apos;1000&apos;        },        {            xName: &apos;4月&apos;，            value: &apos;7&apos;        },        {            xName: &apos;5月&apos;，            value: &apos;22&apos;        },        {            xName: &apos;6月&apos;，            value: &apos;90&apos;        },        {            xName: &apos;7月&apos;，            value: &apos;700&apos;        }    ],    padding: { // svg内部padding        top: 20,        bottom: 20,        left: 20,        right: 20    },    svgHeight: 500, // svg高度    svgWdith: 500, // svg宽度    id: &apos;#js-svg&apos; // svg标签}</code></pre><h3 id="比例尺"><a href="#比例尺" class="headerlink" title="比例尺"></a>比例尺</h3><p>我们画一个柱状图，y轴的数据大小如上，最大值和最小值之间间隔由差不多1000，我们不可能在y轴坐标上显示0到1000都显示出来,这时候我们需要一个映射关系，由某个区域的值去映射到另一个区域，但是它们之间的关系不变。</p><p>在这里，我主要介绍两个常用比例尺，线性比例尺和序数比例尺。</p><p>这个实例中，我们X轴用的是序数比例尺，Y轴用的是线性比例尺。</p><h4 id="线性比例尺（Y轴）"><a href="#线性比例尺（Y轴）" class="headerlink" title="线性比例尺（Y轴）"></a>线性比例尺（Y轴）</h4><p>定义一个Y轴比例尺函数</p><pre><code>let drawYscale () {}</code></pre><p>在函数里定义一个线性比例尺</p><pre><code>d3.scaleLinear()</code></pre><p>接下来我们要规定其定义域 domain(arr)</p><pre><code>d3.scaleLinear().domain(param.data.map((d) =&gt; {    return d.value}))</code></pre><p>注意：这里domain(arr)接受一个数值数组，数组需要包含两个及两个以上值，而且如果不是数值会被强制转换成数值类型。多个值会形成分段比例尺。</p><p>然后我们规定值域 range([range])</p><pre><code>d3.scaleLinear().domain(param.data.map((d) =&gt; {    return d.value})).range([svgHeight - padding.top - padding.bottom, 0])</code></pre><p>range和domain一样，接受一个数组，和domain不一样的是数组不一定是要数值类型。</p>]]></content>
      
      
        <tags>
            
            <tag> D3.js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git浅解</title>
      <link href="/2018/09/05/Git%E6%B5%85%E8%A7%A3/"/>
      <url>/2018/09/05/Git%E6%B5%85%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h1 id="Git浅解"><a href="#Git浅解" class="headerlink" title="Git浅解"></a><center>Git浅解</center></h1><h2 id="一、为什么选择Git"><a href="#一、为什么选择Git" class="headerlink" title="一、为什么选择Git"></a>一、为什么选择Git</h2><p>比如我们写东西的时候刚开始写了一部分，先保存为了文章1，然后后续写的时候，改了一些东西，删除了之前的一部分，但是你又可能需要之前的部分，所以你会另存为文章2，所以这样下去，等你的文章写完，可能会有文章1,2,3,4。。。很多个副本，然后你想去找其中的一段，但是又可能不记得在哪了，所以要一个个文件查看，这样就没有效率，重复做了很多事情，而且很乱。</p><p>然后Git可以帮你解决这些问题，它能帮我们记录每次文件的改动，而且可以多人协同完成，这样我们可以快速，高效的进行版本管理。</p><p>GIt是分布式版本控制系统。</p><p>Git不需要联网，每个人都可以拷贝一份完整的版本库到本地，然后在本地进行一系列操作。</p><h2 id="二、学习Git前须知"><a href="#二、学习Git前须知" class="headerlink" title="二、学习Git前须知"></a>二、学习Git前须知</h2><h3 id="（1）git文件的四种状态"><a href="#（1）git文件的四种状态" class="headerlink" title="（1）git文件的四种状态"></a>（1）git文件的四种状态</h3><ol><li>modified 修改了，但没有被保存在本地版本库</li><li>staged（已暂存）</li><li>untracked（）</li><li>commit（已提交）</li></ol><h3 id="（2）git的五个区域"><a href="#（2）git的五个区域" class="headerlink" title="（2）git的五个区域"></a>（2）git的五个区域</h3><h2 id="三、一般使用Git的流程"><a href="#三、一般使用Git的流程" class="headerlink" title="三、一般使用Git的流程"></a>三、一般使用Git的流程</h2>]]></content>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《JavaScript高级程序设计》DOM扩展</title>
      <link href="/2018/09/04/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8BDOM%E6%89%A9%E5%B1%95/"/>
      <url>/2018/09/04/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8BDOM%E6%89%A9%E5%B1%95/</url>
      <content type="html"><![CDATA[<h1 id="DOM扩展"><a href="#DOM扩展" class="headerlink" title="DOM扩展"></a><center>DOM扩展</center></h1><h2 id="一、选择符API（重要）"><a href="#一、选择符API（重要）" class="headerlink" title="一、选择符API（重要）"></a>一、选择符API（重要）</h2><p>平时我们写代码的时候最常用的一个操作就是根据css选择符选择与某个模式匹配的DOM元素，比如$(“css选择符”)。但是用jquery的话我们必须引用jquery库。现在我们可以不需要引js库就可以实现这个功能。</p><p>选择符API的核心是两个方法：querySelector()和querySelectorAll()。还有一个matchesSelector()方法。</p><p>Document、Element，DocumentFragment三种类型的元素都有这两个方法。<br><a id="more"></a><br>兼容性(2018.09.04查询)<br><img src="/2018/09/04/《JavaScript高级程序设计》DOM扩展/jrx.png" alt=""></p><h3 id="1-querySelector"><a href="#1-querySelector" class="headerlink" title="1. querySelector()"></a>1. querySelector()</h3><p>该方法接收一个css选择器，返回与该模式匹配的第一个元素，如果没有找到匹配的元素，则会返回null。如果传入了不被支持的选择符，会报错。</p><p>通过Document类型调用该方法，会在文档元素的范围内查找匹配的元素。而通过Element类型调用，只会在该元素后代元素范围内查找匹配的元素。</p><p><code>html</code></p><pre><code>&lt;span class=&quot;outside&quot;&gt;outside&lt;/span&gt;&lt;div id=&quot;my-id&quot;&gt;        &lt;span class=&quot;outside&quot;&gt;my-id outside&lt;/span&gt;     &lt;span id=&quot;inside&quot;&gt;inside&lt;/span&gt;     &lt;div class=&quot;lonely&quot;&gt;lonely&lt;/div&gt;     &lt;div class=&quot;outer&quot;&gt;          &lt;div class=&quot;inner&quot;&gt;inner&lt;/div&gt;     &lt;/div&gt;&lt;/div&gt;</code></pre><p>Document</p><p><code>js</code></p><pre><code>var lonely = document.querySelector(&quot;#my-id .lonely&quot;);var outside1 = document.querySelector(&quot;#outside1&quot;); //nullvar inside = document.querySelector(&quot;#.inside&quot;);//报错</code></pre><p>结果：</p><p><img src="/2018/09/04/《JavaScript高级程序设计》DOM扩展/querySelector.png" alt=""></p><p>Element</p><pre><code>var myId = document.querySelector(&quot;#my-id&quot;);var outer = myId.querySelector(&quot;.outer&quot;);var outside = myId.querySelector(&quot;.outside&quot;);</code></pre><p><img src="/2018/09/04/《JavaScript高级程序设计》DOM扩展/querySelector-element.png" alt=""></p><h3 id="2-querySelectorAll"><a href="#2-querySelectorAll" class="headerlink" title="2.querySelectorAll()"></a>2.querySelectorAll()</h3><p>该方法接收的参数也是一个css选择符，返回的是一个NodeList的实例，返回的是所有匹配的元素而不仅仅是返回的一个元素。</p><p>NodeList 对象是一个节点的集合，是由 Node.childNodes 和 document.querySelectorAll 返回的.</p><p>大多数情况下，我们使用Node.childNodes返回的NodeList是一个实时的集合，也就是页面节点又变化是，NodeList会跟着改变。</p><pre><code>var myId = document.querySelector(&quot;#my-id&quot;);var childNodes = myId.childNodes; //9myId.appendChild(document.createElement(&apos;div&apos;));var childNodes2 = myId.childNodes;//10</code></pre><p><img src="/2018/09/04/《JavaScript高级程序设计》DOM扩展/childnodes.png" alt=""> </p><p>querySelectorAll()返回的是一个静态的nodeList，是一个快照。这样可以避免使用NodeList对象通常会引起的大多数性能问题。</p><pre><code>var myId = document.querySelector(&quot;#my-id&quot;);var nodes = document.querySelectorAll(&quot;div&quot;);console.log(&quot;nodes:&quot;);console.log(nodes);myId.appendChild(document.createElement(&apos;div&apos;));var nodes2 = document.querySelectorAll(&quot;div&quot;);console.log(&quot;nodes2:&quot;);console.log(nodes2);console.log(&quot;nodes:&quot;);console.log(nodes);</code></pre><p><img src="/2018/09/04/《JavaScript高级程序设计》DOM扩展/querySelectorAll.png" alt=""></p><p> 只要传给querySelectorAll()方法的css选择符有效，该方法都会返回一个NodeList对象，如果没有找到匹配的元素，NodeList就是空的。  </p><pre><code>var aNodes = document.querySelectorAll(&quot;a&quot;);   console.log(&quot;aNodes&quot;);console.log(aNodes);</code></pre><p><img src="/2018/09/04/《JavaScript高级程序设计》DOM扩展/nodelist-null.png" alt=""><br>思考：下面两个获取方法得到的内容是一样的么？</p><pre><code>var div = document.querySelectorAll(&quot;#my-id div div&quot;);console.log(&quot;div:&quot;);console.log(div);var div2 = document.querySelector(&quot;#my-id&quot;).querySelectorAll(&quot;div div&quot;);console.log(&quot;div2:&quot;);console.log(div2);</code></pre><p><img src="/2018/09/04/《JavaScript高级程序设计》DOM扩展/querySelectorAll2.png" alt=""></p><p>原因：CSS选择器是独立于整个页面的！</p><p>这里的querySelectorAll里面的选择器也同样是这也全局特性。document.querySelector(“#my-id”).querySelectorAll(“div div”)翻译成白话文就是：查询#my-id的子元素，同时满足整个页面下div div选择器条件的DOM元素们。</p><p>使用场景？</p><h3 id="3-matchesSelector（）方法"><a href="#3-matchesSelector（）方法" class="headerlink" title="3.matchesSelector（）方法"></a>3.matchesSelector（）方法</h3><p>这个方法接收一个参数，css选择符，如果调用元素与该选择符匹配，返回true，否则为false。</p><p>if(document.body.webkitMatchesSelector(“body”)){<br>        console.log(“webkitMatchesSelector”);<br>    }</p><h2 id="二、元素遍历"><a href="#二、元素遍历" class="headerlink" title="二、元素遍历"></a>二、元素遍历</h2><p> 对于元素间的空格，IE9及之前的版本不会返回文本节点，这样就导致了在使用childNodes和firstChild等属性时行为不一致。</p><p> 所以Element Traversal API 为DOM元素添加了以下5个属性。</p><p> childElementCount： 返回子元素（不包括文本节点和注释）的个数</p><p> firstElementChild：只想第一个子元素</p><p> lastElementChild： 指向最后一个元素</p><p> previousElmentSlibling：指向前一个同辈元素</p><p> nextElementSibling：指向后一个同辈元素</p><h2 id="三、HTML5（重要）"><a href="#三、HTML5（重要）" class="headerlink" title="三、HTML5（重要）"></a>三、HTML5（重要）</h2><h3 id="1-与类相关的扩充"><a href="#1-与类相关的扩充" class="headerlink" title="1.与类相关的扩充"></a>1.与类相关的扩充</h3><ol><li><p>getElementsByClassName()<br> 该方法接收一个参数，即包含一或多个类名的字符串，返回带有指定类的所有元素的NodeList。类名的先后顺序无所谓。</p></li><li><p>classLists属性</p><pre><code>&lt;div id=&quot;dd&quot; class=&quot;bd user do&quot;&gt;2222&lt;/div&gt;var dd = document.querySelector(&quot;#dd&quot;);console.log(dd.classList);</code></pre></li></ol><p>add(value): 将给定的字符串添加到列表中，如果值有，就不添加</p><p>contains(value): 表示列表中是否存在给定的值，如果存在则返回true，如果不存在false</p><p>remove(value):从列表中删除给定的字符串</p><p>toggle(value):如果列表中已经存在给定的值，删除它，如果列表中每一给定的值，添加它。</p><h3 id="2-自定义数据属性"><a href="#2-自定义数据属性" class="headerlink" title="2 自定义数据属性"></a>2 自定义数据属性</h3><p>html5规定要添加非标准的属性，但是要加前缀data-，目的是为元素提供与渲染无关的信息，或者提供语义信息</p><p>例如：</p><pre><code>&lt;div id=&quot;myDiv&quot; data-appId=&quot;123&quot; data-myname=&quot;hzq&quot;&gt;</code></pre><p>t添加了自定义属性后，我们可以通过元素的dataset属性来访问自定义属性的值</p><h3 id="3-插入标记"><a href="#3-插入标记" class="headerlink" title="3.插入标记"></a>3.插入标记</h3><p>使用场景：</p><p>我们需要给文档插入大量新的标记，我们不仅要创建一系列DOM节点，然后还要小心的按照正确的顺序把他们连接起来。</p><h4 id="a：innerHTML属性"><a href="#a：innerHTML属性" class="headerlink" title="a：innerHTML属性"></a>a：innerHTML属性</h4><p>在读模式，innerHTML属性返回与调用元素的所有子节点（包括元素，注释和文本节点）对应的HTML标记。</p><p>在写模式，innnerHTML会根据制定的值创建新的DOM树，然后用这个DOM树完全替换调用元素原先的所有子节点。</p><pre><code>&lt;div id=&quot;content&quot;&gt;    &lt;p&gt;hello&lt;/p&gt;    &lt;ul&gt;        &lt;li&gt;item 1&lt;/li&gt;        &lt;li&gt;item 1&lt;/li&gt;        &lt;li&gt;item 1&lt;/li&gt;     &lt;/ul&gt; &lt;/div&gt;var innerHTML = document.querySelector(&quot;#content&quot;).innerHTML;console.log(innerHTML);</code></pre><p>返回的是</p><pre><code>&lt;p&gt;hello&lt;/p&gt;    &lt;ul&gt;        &lt;li&gt;item 1&lt;/li&gt;        &lt;li&gt;item 1&lt;/li&gt;        &lt;li&gt;item 1&lt;/li&gt;    &lt;/ul&gt;</code></pre><p> 写模式：</p><pre><code>document.querySelector(&quot;#content&quot;).innerHTML = &quot;&lt;p&gt;hello,world&lt;/p&gt;&quot;;   var innerHTML = document.querySelector(&quot;#content&quot;).innerHTML; console.log(innerHTML);//&lt;p&gt;hello,world&lt;/p&gt;</code></pre><p>并不是所有元素都支持innerHTML属性，不支持的有：<br>    <code>&lt;col</code>&gt;,<code>&lt;colgroup</code>&gt;,<code>&lt;frameset&gt;</code>,<code>&lt;head&gt;</code>,<code>&lt;html&gt;</code>,<code>&lt;style&gt;</code>,<code>&lt;table&gt;</code>,<code>&lt;tbody&gt;</code>,<code>&lt;thead&gt;</code>,<code>&lt;tfoot&gt;</code>,<code>&lt;tr&gt;</code></p><h4 id="b-outerHTML"><a href="#b-outerHTML" class="headerlink" title="b: outerHTML"></a>b: outerHTML</h4><p>在读模式，outerHTML返回调用它的元素及所有子节点的HTML标签，在写模式下，outerHTML会根据制定的HTML字符串去创建新的DOM子树，然后用这个DOM树去完全替换调用元素。</p><h4 id="c：内存与性能问题"><a href="#c：内存与性能问题" class="headerlink" title="c：内存与性能问题"></a>c：内存与性能问题</h4><p>我们在使用这两个属性时，可能删除了之前的元素，元素上有一个事件处理程序，从文档树中删除了元素，但是元素与事件处理程序之间的绑定关系在内存中并没有删除，这样日积月累，页面占有的内存会越来越多，所以我们使用上面的方法时最好手动删除要被删除的元素的事件处理程序和js对象属性。</p><h3 id="4-scrollIntoView"><a href="#4-scrollIntoView" class="headerlink" title="4.scrollIntoView()"></a>4.scrollIntoView()</h3><p>为了方便开发人员更好的控制页面滚动，HTML5选择了scrollIntoView()作为标准方法。</p><p>scrollIntoView()可以在所有HTML元素上调用，通过滚动浏览器窗口或者某个容器元素，调用元素就会出现在视口中。如果给这个方法传入true作为参数，或者不传入参数，那么窗口滚动之后会 让调用元素的顶部与视口顶部尽可能齐平。如果传入false作为参数，调用元素会尽可能全部出现在视口中，可能的话调用元素的底部会与视口底部齐平。</p><p>移动端开发可能用的比较多，input和键盘。</p>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>变基git rebase中的基是什么</title>
      <link href="/2018/08/28/%E5%8F%98%E5%9F%BAgit-rebase%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>/2018/08/28/%E5%8F%98%E5%9F%BAgit-rebase%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      <content type="html"><![CDATA[<h1 id="变基-git-rebase-中的基是什么？"><a href="#变基-git-rebase-中的基是什么？" class="headerlink" title="变基(git rebase)中的基是什么？"></a>变基(git rebase)中的基是什么？</h1><p>git rebase 在官网中的定义是：重新应用commits到要合并到的分支的顶端。（一个英语渣的直译，见笑了）。其实也可以这么说是重新应用commits到要合并到的分支的最新提交。如果现在还没有理解，没有关系，现在我开始仔细说明git rebase都干了什么。</p><p>假设我们现在是A研发人员，此时本地分支是master,然后远程有两个分支：origin/master,origin/develop。此时我们接到一个任务，我们要在develop分支上开发一个功能，所以此时我们要切换分支。<br><a id="more"></a></p><p><img src="/2018/08/28/变基git-rebase中的基是什么/changj.png" alt=""></p><p>切换分支我们需要用到的命令是：</p><pre><code>git checkout -b local_develop origin/develop</code></pre><p>该命令其实做了两个操作，第一个是拷贝了远程的origin/develop到本地，致使本地多了一个分支，第二个是把该分支命名为local_develop。</p><p>假设此时远程的origin/develop分支上已经有两个提交。，所以我们查看远程分支的日志（git log origin/develop）可以看到提交的树状图如下：</p><p><img src="/2018/08/28/变基git-rebase中的基是什么/001.png" alt=""></p><p>此时你本地的提交日志（git log）的树状图如下：</p><p><img src="/2018/08/28/变基git-rebase中的基是什么/002.png" alt=""></p><p>经过一段时间，你把功能开发完成了，此时提交代码(git commit -m “[+]添加功能”)，把你本地的代码提交到远程分支上。这时候你发现在你提交之前，有其他的同事在develop分支（这里指的是origin/develop）上提交了两次代码。所以此时的树状图是这样的：远程分支的提交已经有四次了，此时你的提交编号应该为5.</p><p><img src="/2018/08/28/变基git-rebase中的基是什么/003.png" alt=""></p><p>commit后，如果有修改过但是未commit的文件，我们应该执行驻藏命令 git stash 将这些文件保留到驻藏区，然后进行代码的拉取git fetch ，然后执行合并分支，git rebase. </p><p>该命令会执行两个步骤，第一个是把你本地分支的新添加的全部的commit的补丁（patch）,我理解为是备份，也就是把他们的备份临时放到.git/rebase目录下，然后把commit撤销掉。<br>也就是这样：</p><p><img src="/2018/08/28/变基git-rebase中的基是什么/004.png" alt=""></p><p>第二个步骤是在要合并到的分支（origin/develop）的最新的commit的基础上应用这些补丁。也就是把4和5’进行合并，然后推送代码 git push.</p><p><img src="/2018/08/28/变基git-rebase中的基是什么/005.png" alt=""></p><p>到这里，我们可以知道变基的基是什么了吧。就是要要合并到的分支（origin/develop）的最新的提交（在上面例子里，这个基就是4）。</p><p>明白了git rebase的操作后，我们可以发现，如果使用git rebase命令来合并分支的话，分支的树状图都是“单线”，都是一条直线。这样的树状图是非常优美的。</p><p>现在我们也可以来了解一下另一个合并分支的命令(git merge).</p><p>merge命令非常简单粗暴，就是把你本地最新的提交和远程最新的提交合并一下，得到一份最新的提交。</p><p><img src="/2018/08/28/变基git-rebase中的基是什么/006.png" alt=""></p><p>用merge命令的话树状图就会看着很乱，有各种线交叉，看着非常不友好。</p><p>所以拉代码推荐git fetch + git rebase.</p>]]></content>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript的創建方法</title>
      <link href="/2018/08/23/JavaScript%E7%9A%84%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95/"/>
      <url>/2018/08/23/JavaScript%E7%9A%84%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="JavaScript创建对象的几种方法"><a href="#JavaScript创建对象的几种方法" class="headerlink" title="JavaScript创建对象的几种方法"></a>JavaScript创建对象的几种方法</h1><h2 id="一、理解对象"><a href="#一、理解对象" class="headerlink" title="一、理解对象"></a>一、理解对象</h2><p>ECMA-262把对象定义为： 无序属性的集合，其属性可以包含基本值，对象或者函数。每个对象都是基于一个引用<br>类型创建的，这个引用类型可以是原生类型，比如Object，Array等，也可以是自己定义的类型。<a id="more"></a></p><h2 id="二、常用方法"><a href="#二、常用方法" class="headerlink" title="二、常用方法"></a>二、常用方法</h2><h3 id="（1）创建单个对象"><a href="#（1）创建单个对象" class="headerlink" title="（1）创建单个对象"></a>（1）创建单个对象</h3><p>情景模式： 现在我们要创建一家公司的人员。<br>创建单个对象，也就是我们要创建一个人员。</p><h4 id="a-创建Object实例"><a href="#a-创建Object实例" class="headerlink" title="a. 创建Object实例"></a>a. 创建Object实例</h4><pre><code>传说女娲造人，Object其实可以想象成女娲，所有的对象都是Object的实例。   var person = new Object();   person.name = &quot;zzilcc&quot;;   person.age = 23;</code></pre><p>new 其实做了四件事情。</p><pre><code>1. 创建了一个对象2. 把当前作用域赋值给这个对象3. 执行构造函数里的代码4. 返回这个对象但是我们更常用的方法是对象字面量方法。简单好理解。</code></pre><h4 id="b-对象字面量方法"><a href="#b-对象字面量方法" class="headerlink" title="b .对象字面量方法"></a>b .对象字面量方法</h4><pre><code>var person = {    name: &quot;bbb&quot;,    age: 23,    sayName: function(){        console.log(this.name);    }}</code></pre><h3 id="2-创建多个对象"><a href="#2-创建多个对象" class="headerlink" title="(2) 创建多个对象"></a>(2) 创建多个对象</h3><h4 id="a-工厂模式"><a href="#a-工厂模式" class="headerlink" title="a. 工厂模式"></a>a. 工厂模式</h4><p>此时，如果我们要创建多个人员，我们可能会这样写</p><pre><code>var person1 = new Object();person1.name = &quot;aaa&quot;;person1.age = 23;person1.sayName = function(){    console.log(this.name);};var person2 = new Object();person2.name = &quot;bbb&quot;;person2.age = 23;person2.sayName = function(){    console.log(this.name);};var person3 = new Object();person3.name = &quot;ccc&quot;;person3.age = 23;person3.sayName = function(){    console.log(this.name);};var person4 = new Object();person4.name = &quot;ddd&quot;;person4.age = 23;person4.sayName = function(){    console.log(this.name);};</code></pre><p>这是我们会发现，我们写了大量重复的代码，能不能把相同代码放到一起，每次调用一下就好了，所以就有了工厂模式。</p><pre><code>function  createPerson (name,age) {    var o = new Object();    o.name = name;    o.age = age;    o.sayName = function(){        console.log(this.name);    }}var person1 = createPerson(&quot;aaa&quot;,23);var person2 = createPerson(&quot;bbb&quot;,21);var person3 = createPerson(&quot;ccc&quot;,24);var person4 = createPerson(&quot;ddd&quot;,22);</code></pre><p>这样我们创建相似对象就可以减少重复代码量。但是这个方法有的缺点就是无法解决对象识别的问题。也就是通过工厂模式产生的对象只能知道是“女娲”（object）造出来的实例，他们之间不能细分到是这是男人还是女人。</p><h4 id="b-构造函数模式"><a href="#b-构造函数模式" class="headerlink" title="b. 构造函数模式"></a>b. 构造函数模式</h4><p>这时候构造函数模式就可以解决对象识别的问题了。因为构造函数可以用来创建特定类型的对象。构造函数可以想象成女娲的各种法术，一种法术产生一种类型的人员，比如这种法术是生成“女性”，那种法术是生成“男性”。构造函数有原生构造函数和自定义的构造函数，非常人性化。</p><pre><code>function Male(name,age){    this.sex = &quot;male&quot;;    this.name = name;    this.age = age;    this.sayName = function(){        console.log(this.name)    }}var male1 = Male(&quot;aa&quot;,23);var male2 = Male(&quot;xx&quot;,22);</code></pre><p>按照惯例，构造函数的函数名首字母要大写。<br>我们可以通过instanceof操作符检测对象类型。使用构造函数意味着把它实例标识为一种特定的类型，比如男人，女人，老人，小孩等等。这也是工厂函数无法解决的问题。</p><pre><code>console.log(male1 instanceof Object); //trueconsole.log(male2 instanceof Object); //trueconsole.log(male1 instanceof Male); //trueconsole.log(male1 instanceof Male); //true</code></pre><p>male1,,male2是Object的实例，也是Male的实例。</p><p>但是这个方法也是有自己的缺点的，也就是每个方法都要在每个实例上重新创建一遍。</p><pre><code>function Male(name,age){    this.sex = &quot;male&quot;;    this.name = name;    this.age = age;    this.sayName = function(){        console.log(this.name)    }}</code></pre><p>也就是我们每次new Male()的时候，我们都要去重新创建一次sayName方法。<br>        因为函数也是一个对象，所以上面的函数我们可以改写成</p><pre><code>function Male(name,age){        this.sex = &quot;male&quot;;        this.name = name;        this.age = age;        this.sayName = new Function(&quot;console.log(this.name)&quot;);    }</code></pre><p>也就是我们每次new Male()的时候我们都创建了一个Function的实例，那为什么我们不能在全局环境中创建一个，然后再Male函数里调用。</p><p>所以我们可以改写成下面这样：</p><pre><code>function Male(name,age){        this.sex = &quot;male&quot;;        this.name = name;        this.age = age;        this.sayName = sayName;    }    function sayName(){        console.log(this.name);    }</code></pre><p>但是这么干的话，其实也不合适，因为sayName函数明明是为你Male所用的，但是你却把它放到全局里，这不符合全局的概念。<br>而且要是构造很熟有很多函数的话，那么全局作用域就有很多“全局”函数，那样我们自定义的引用类型就没有封装性可言了。</p><h4 id="c-原型模式"><a href="#c-原型模式" class="headerlink" title="c. 原型模式"></a>c. 原型模式</h4><p>我们创建的每个函数都有一个原型（prototype）属性,这个属性是一个指针，指向一个对象。这个对象包含了一些属性和方法，这些属性和方法是被特定类型的所有实例共享的。也就是说prototype是我们通过构造函数创建的对象实例的原型对象。也就是我们把想要所有对象实例都共享的方法和实行都添加到原型中，而不是构造函数中。</p><pre><code>funtiton Person(){};Person.prototype.name = &quot;aa&quot;;Person.prototype.age = 23;Person.sayName.sayName = function() {    console.log(this.name)}var person1 = new Person();person1.sayName();//&quot;aa&quot;</code></pre><p>我们把公用属性和方法放到了Person的原型中， 所以每个实例访问的都是同一组属性和同一个方法。这样就不用把方法放到全局环境去写了，就解决了构造函数把私有方法放到全局的问题</p><h4 id="d-组合使用构造函数-原型模式"><a href="#d-组合使用构造函数-原型模式" class="headerlink" title="d. 组合使用构造函数+原型模式"></a>d. 组合使用构造函数+原型模式</h4><p>俗话说，我们要去其糟粕，取其精华，我们将两种方式的精华合并到一起，集两家之长，形成了组合模式。使用构造函数模式定义实例属性，用原型模式定义方法和共享的属性。</p><pre><code>function Peroson (name, age) {    this.name = name;    this.age = age;    this.friends = [&apos;zz&apos;, &apos;aa&apos;];}Person.prototype = {    constructor: Person,    sayName: function () {        console.log(this.name)    }}var person1 = new Person(&apos;zzilcc&apos;, 23);var person2 = new Person(&apos;aaa&apos;, 22);</code></pre>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript对象 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vue指令</title>
      <link href="/2018/07/16/vue%E6%8C%87%E4%BB%A4/"/>
      <url>/2018/07/16/vue%E6%8C%87%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h1 id="vue指令"><a href="#vue指令" class="headerlink" title="vue指令"></a>vue指令</h1><p>这章介绍的是vue的一些指令，是以“v-”开头的指令，它的值预估是单个<br>JavaScript表达式(v-for例外)。指令的作用是在表达式的值改变的时候，<br>将产生的影响，响应的作用在DOM上。<a id="more"></a></p><h2 id="v-if、v-else和v-else-if"><a href="#v-if、v-else和v-else-if" class="headerlink" title="v-if、v-else和v-else-if"></a>v-if、v-else和v-else-if</h2><p>使用场景：我们需要进行条件判断来决定这个元素是否显示的时候，就需要用到这些指令。</p><p>有v-else指令的元素必须跟在带有v-if或者v-else-if的元素后面，否则将不会被识别</p><p>使用方法：</p><pre><code>&lt;div id=&quot;app&quot;&gt;    &lt;div v-if=&quot;param&quot;&gt;        登陆成功       &lt;!--param的值为true的时候--&gt;    &lt;/div&gt;    &lt;div v-else&gt;        请登录    &lt;!--param的值为false的时候--&gt;    &lt;/div&gt;&lt;/div&gt;var vue = new Vue({    el: &quot;#app&quot;,    data: {        param: true    }});</code></pre><p>v-else-if 是在2.1.0版本新增的一个指令。学过c,c++,java语言的都应该可以理解，也就是否则如果，可以连续使用，该指令也是只能跟在v-if后面。</p><p>使用方法：</p><pre><code>&lt;div id=&quot;app&quot;&gt;    &lt;div v-if=&quot;param===0&quot;&gt;         &lt;!--param的值为0的时候--&gt;    &lt;/div&gt;    &lt;div v-else-if=&quot;param===1&quot;&gt;         &lt;!--param的值为1的时候--&gt;    &lt;/div&gt;    &lt;div v-else-if=&quot;param===2&quot;&gt;         &lt;!--param的值为2的时候--&gt;    &lt;/div&gt;    &lt;div v-else&gt;         &lt;!--param的值是非1，非2，非0的时候--&gt;    &lt;/div&gt;&lt;/div&gt;var vue = new Vue({    el: &quot;#app&quot;,    data: {        param: 0    }});</code></pre><h2 id="v-show和v-once"><a href="#v-show和v-once" class="headerlink" title="v-show和v-once"></a>v-show和v-once</h2><p>v-show指令也是用于条件展示的，用法和v-if一样，只不过没有v-else指令在后面。</p><p>不同的是带有v-show的元素是一开始就会被渲染并保留在DOM中，它是决定的是css属性display来显示或者不显示元素。而v-if是条件渲染，为真才渲染，若为假是不会渲染出相应的元素的，也就是为假的时候DOM上是找不到该元素的。</p><p>v-once顾名思义，一次性的插值。</p><p>此时渲染结果为 Hello!,若是后期我们把message的值改为Hello,world！,元素p里的内容还是Hello!，不会随着data里的message的改变而改变</p><h2 id="v-text和v-html"><a href="#v-text和v-html" class="headerlink" title="v-text和v-html"></a>v-text和v-html</h2><p>v-text的作用等价于两个双括号,用两个双括号不好的地方是当网速很慢或者js报错的时候，会直接显示两个双括号，但是使用v-text就不会，所以在实际开发的时候，建议使用v-text。</p><pre><code>&lt;div id=&quot;app&quot;&gt;    &lt;p&gt;{{message}}&lt;/p&gt; == &lt;p v-text=&quot;message&quot;&gt;&lt;/p&gt;&lt;/div&gt;var vue = new Vue({    el: &quot;#app&quot;,    data: {        message: &quot;Hello!&quot;    }});</code></pre><p>v-html: 会将元素当成html标签解析然后输出。</p><pre><code>&lt;div id=&quot;app&quot;&gt;    &lt;p v-text=&quot;message&quot;&gt;&lt;/p&gt;    &lt;p v-html=&quot;message&quot;&gt;&lt;/p&gt;&lt;/div&gt;var vue = new Vue({    el: &quot;#app&quot;,    data: {        message: &quot;&lt;h1&gt;hello&lt;/h1&gt;&quot;    }});</code></pre><p>输出结果为：</p><p><img src="/2018/07/16/vue指令/v-html.png" alt=""></p><p>注意： 在站点上动态的渲染任意的HTML可能会很危险，因为它很容易导致XSS攻击，所以最好慎用。</p><h2 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h2><p>v-bind一般用来绑定元素属性，属性值可以是字符串，对象或数组。可以用来绑定class、style或者是图片，链接的地址属性src、href等。v-bind可以简写成“:”。</p><pre><code>&lt;style&gt;.fd-head {    color: red;}.fd-nav {    background-color: yellow;}.active {    font-size: 20px;}.text-danger {    color: red;    border: 1px solid &apos;#000&apos;;}&lt;/style&gt;&lt;div id=&quot;app&quot;&gt;    &lt;h1&gt;1. 绑定到src和href属性上&lt;/h1&gt;        &lt;img v-bind:src=&quot;imgSrc&quot;&gt;        &lt;a :href=&quot;url&quot;&gt;github传送门&lt;/a&gt;    &lt;h1&gt;2. 绑定到样式&lt;/h1&gt;        &lt;div :class=&quot;{&apos;fd-head&apos;:isOk, &apos;active&apos;:isActive}&quot;&gt;            &lt;p&gt;(1)一般绑定方法&lt;/p&gt;            字体为红色        &lt;/div&gt;        &lt;div class=&quot;fd-nav&quot; :class=&quot;{&apos;fd-head&apos;:isOk, &apos;active&apos;:isActive}&quot;&gt;            &lt;p&gt;(2)v-bind:class也可以与普通的class属性共存&lt;/p&gt;            字体为红色且背景颜色为黄色        &lt;/div&gt;        &lt;div :class=&quot;isTrue?fd-head:active&quot;&gt;            &lt;p&gt;用三元运算符来选择样式,字体大小为20px&lt;/p&gt;        &lt;/div&gt;        &lt;div :class=&quot;[activeClass,errorClass]&quot;&gt;            绑定到数组        &lt;/div&gt;    &lt;h1&gt;3. 绑定内联样式style&lt;/h1&gt;        &lt;h2&gt;对象语法&lt;/h2&gt;        &lt;div :style=&quot;{color:activeColor,fontSize:fontSize + &apos;px&apos;,&apos;background-color&apos;:bgcolor}&quot;&gt;            (1)我们给:style赋值的是一个对象，该对象语法看上去有点像css，但其实是一个JavaScript对象，css的属性名可以用驼峰式，这样就需要用括号括起来，或者用短横线分隔，这样就需要用括号括起来。        &lt;/div&gt;        &lt;div :style=&quot;styleObj1&quot;&gt;            &lt;p&gt;(2)或者我们直接绑定到一个样式对象，这样比较简单明了。        &lt;/div&gt;        &lt;h2&gt;数组语法&lt;/h2&gt;        &lt;div :style=&quot;[styleObj1,styleObj2,styleObj3]&quot;&gt;            &lt;p&gt;数组语法可以将多个样式对象应用到同一个元素上。        &lt;/div&gt;&lt;/div&gt;var vue = new Vue({    el: &quot;#app&quot;,    data: {        imgSrc: &quot;http://2b.zol-img.com.cn/product/131/741/ceUvYp3mRk5w.jpg&quot;,        url: &quot;https://github.com/zzilcc&quot;,        isOk: true,        isActive: false,        isTrue: false,        activeClass: &apos;active&apos;,        errorClass: &apos;text-danger&apos;,        activeColor: &apos;red&apos;,        &apos;fd-head&apos;: &apos;fd-head&apos;,        active: &apos;active&apos;,        fontSize: 30,        bgcolor: &apos;blue&apos;,        styleObj1: {            color: &apos;red&apos;,            fontSize: &apos;13px&apos;        },        styleObj2: {            position: &apos;relative&apos;        },        styleObj3: {            backgroundColor: &apos;blue&apos;        }    }})</code></pre><p>结果为：<br><img src="/2018/07/16/vue指令/v-bind1.png" alt=""></p><p><img src="/2018/07/16/vue指令/v-bind2.png" alt=""></p><h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><p>v-model指令主要用来在表单<code>&lt;input&gt;</code>及<code>&lt;textarea&gt;</code>元素上进行双向数据绑定。v-model会忽略所有表单元素的value,checked,selected特性的初始值，而总是将Vue实例的数据当做数据来源。</p><h3 id="文本绑定"><a href="#文本绑定" class="headerlink" title="文本绑定"></a>文本绑定</h3><pre><code>&lt;div id=&quot;app&quot;&gt;    &lt;input v-model=&quot;message&quot; placeholder=&quot;请输入&quot;&gt;    &lt;p&gt; Message is : &lt;span v-text=&quot;message&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;var vue = new Vue({    el: &quot;#app&quot;,    data: {        message: &quot;&quot;    }})</code></pre><p><img src="/2018/07/16/vue指令/v-model1.png" alt=""></p>]]></content>
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue.js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vue基础</title>
      <link href="/2018/07/16/vue%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/07/16/vue%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<h2 id="Vue-js是什么"><a href="#Vue-js是什么" class="headerlink" title="Vue.js是什么"></a>Vue.js是什么</h2><p>Vue是一个前端框架，官方的解释是一套用于构建用户界面的渐进式框架。相对于React,AngularJS框架来说是比较轻量级的，然后比较容易上手，所以一开始选择学哪个框架的时候就选择了Vue,正好入职的第一家公司也是使用这个框架。<br><a id="more"></a></p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>Vue有两个版本，一个开发版本，包含完整的警告和调试模式；一个是生产版本，删除了警告，进行了压缩。</p><p>GitHub地址传送门：<a href="https://github.com/vuejs/vue" target="_blank" rel="noopener">github</a></p><h2 id="Vue实例"><a href="#Vue实例" class="headerlink" title="Vue实例"></a>Vue实例</h2><p>我们一般通过Vue函数创建一个新的Vue实例。</p><pre><code>var vue = new Vue({    //选项});</code></pre><h2 id="声明式渲染"><a href="#声明式渲染" class="headerlink" title="声明式渲染"></a>声明式渲染</h2><p>Vue是声明式渲染，这是Vue的核心，我看过比较好的解释就是“我们只需要告诉程序我们想要什么效果，其他交给程序去做”。</p><p>官网的例子就很好理解：</p><pre><code>&lt;div id=&quot;app&quot;&gt;    {{message}} //Hi&lt;/div&gt;var vue = new Vue ({    el: &quot;#app&quot;,    data: {        message: &apos;Hi!&apos;    }}) </code></pre><p>  通过这样我们已经把数据渲染进DOM，而且是响应式的。主要data里的message值发生变化，在页面上也会跟着变化。</p><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><p>当创建一个实例后，我们可以传入一个选项对象，下面列出一些常用选项：</p><ul><li>el</li><li>data</li><li>methods</li><li>computed</li></ul><h3 id="el"><a href="#el" class="headerlink" title="el"></a>el</h3><p> 选择挂载目标，可以是css选择器，也可以是html元素，在实例挂载后，元素可以通过vue.$el访问。</p><p> 如果是在实例化时存在这个选项，实例将立即进入编译过程，否则需要显式调用vue.$mount()手动开始编译。</p><h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><p> Vue实例的数据对象。Vue是响应式的数据变化的，因为Vue会递归的将data的属性转换为getter/setter。data对象必须是纯粹的对象，也就是含有零个或多个的键值对。</p><p> 实例创建后，可以通过vue.$data访问，并且Vue实例，也就是vue实际上也代理了data对象上的不是以“_”或者“$”开头的属性。也就是vue.$data.a等价于 vue.a.</p><pre><code>&lt;div id=&quot;app&quot;&gt;    {{message}}  //Hello,world&lt;/div&gt;var vue = new Vue({    el: &quot;#app&quot;,    data: {        message: &quot;Hello world!&quot;    }});vue.$data.message === vue.message //true</code></pre><h3 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h3><p> 用来定义一些方法，用这些方法是实现你想要的一些功能，比如点击事件，或者发送ajax请求等等。这些方法可以通过实例来访问，或者在指令表达式中使用，方法中的this会自动绑定为Vue实例。</p><pre><code>&lt;div id=&quot;app&quot;&gt;     {{message}}  //Hello     &lt;button v-on:click=&quot;show&quot;&gt;展示完整信息&lt;/button&gt;//点击按钮后会出现Hello,world!&lt;/div&gt;var vue = new Vue({    el: &quot;#app&quot;,    data: {        message: &quot;Hello&quot;    },    methods: {        show: function() {            return message = + &quot;,world!&quot;        }    }})</code></pre><p> 在这个例子我们使用v-on命令，用来监听事件，这个命令下节会解释。我们在button标签里绑定了点击事件，所以一点击的时候，就会触发了show函数，该函数就会执行，所以message的值为“Hello,world！”。</p><h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><p> 计算属性，它是基于依赖进行缓存的，只有相关的依赖的值发生了改变，才会重新执行函数，否则只会返回之前的结果。</p><p> 类型：{[key: string]: Function|{get: Function,set: Function}}</p><pre><code>var vue = new Vue({    el: &quot;#app&quot;,    data: {        a: 1    },    computed: {        add: function() {             return this.a + 1        }    }})</code></pre><p> or</p><pre><code>var vue = new Vue({    el: &quot;#app&quot;,    data: {        a: 1    },    computed: {        add: {            get: function() {                return this.a + 1            },            set: function(data) {                this.a = data -1            }        }    }})</code></pre>]]></content>
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue.js </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
